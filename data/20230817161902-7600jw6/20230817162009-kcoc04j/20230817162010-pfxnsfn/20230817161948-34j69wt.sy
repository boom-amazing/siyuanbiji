{"ID":"20230817161948-34j69wt","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161948-34j69wt","title":"最短路径","updated":"20230817161948"},"Children":[{"ID":"20230817161949-s492jn1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161949-s492jn1","updated":"20230817161949"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"最短路径"}]},{"ID":"20230817161950-yyza4no","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161950-yyza4no","updated":"20230817161950"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"fload算法："}]},{"ID":"20230817161951-9ztz3q5","Type":"NodeParagraph","Properties":{"id":"20230817161951-9ztz3q5","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"例题："}]},{"ID":"20230817161952-7ugmask","Type":"NodeParagraph","Properties":{"id":"20230817161952-7ugmask","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。"}]},{"ID":"20230817161953-d8m2wp7","Type":"NodeParagraph","Properties":{"id":"20230817161953-d8m2wp7","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"小蓝的图由 2021 个结点组成，依次编号 1 至 2021。"}]},{"ID":"20230817161954-sn8oep6","Type":"NodeParagraph","Properties":{"id":"20230817161954-sn8oep6","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。"}]},{"ID":"20230817161955-7pdkk2i","Type":"NodeParagraph","Properties":{"id":"20230817161955-7pdkk2i","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。"}]},{"ID":"20230817161956-dweob9k","Type":"NodeParagraph","Properties":{"id":"20230817161956-dweob9k","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"请计算，结点 1 和结点 2021 之间的最短路径长度是多少。"}]},{"ID":"20230817161957-p3i3kpf","Type":"NodeParagraph","Properties":{"id":"20230817161957-p3i3kpf","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"代码:"}]},{"ID":"20230817161958-b8so4b6","Type":"NodeParagraph","Properties":{"id":"20230817161958-b8so4b6","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"核心思路：要求i到j的最短路劲 可以先求通过1中转 再求经过2中转 。。。直到经过所有点中转 初始最大值为99999999这样两个数相加不会超过int范围 初始时两个点无边初始化为最大值"}]},{"ID":"20230817161959-u102rvk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161959-u102rvk","updated":"20230817161959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.lanqiao.Y2021;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class Q4 {\n    public static void main(String[] args) {\n        int [][]g=new int[2022][2022];\n        int inf=99999999;\n        for(int i=1;i\u003c=2021;i++){\n            for(int j=1;j\u003c=2021;j++){\n                if(Math.abs(i-j)\u003c=21){\n                    int num=(i*j)/gcd(i,j);\n                    g[i][j]=num;\n                    g[j][i]=num;\n                }else {\n                    g[i][j]=inf;\n                    g[j][i]=inf;\n                }\n            }\n        }\n        for(int k=1;k\u003c=2021;k++){\n            for(int i=1;i\u003c=2021;i++){\n                for(int j=1;j\u003c=2021;j++){\n                    if(g[i][j]\u003eg[i][k]+g[k][j]){\n                        g[i][j]=g[i][k]+g[k][j];\n                    }\n                }\n            }\n        }\n        System.out.println(g[1][2021]);\n    }\n\n    public  static int gcd(int a,int b){\n        if(a%b==0)return b;\n        return gcd(b,a%b);\n    }\n\n\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161960-jv9vp4b","Type":"NodeParagraph","Properties":{"id":"20230817161960-jv9vp4b","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"floyad的缺点："}]},{"ID":"20230817161961-dpsus7q","Type":"NodeParagraph","Properties":{"id":"20230817161961-dpsus7q","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"时间复杂度为o(n^3) 且不能算带有负权边的有环图 因为会无限循环下去 但可以算负权变的无环图"}]},{"ID":"20230817161962-fx25dog","Type":"NodeParagraph","Properties":{"id":"20230817161962-fx25dog","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"fload的优点："}]},{"ID":"20230817161963-idf1kuu","Type":"NodeParagraph","Properties":{"id":"20230817161963-idf1kuu","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"他可以算多源的路径最小值 即任意点到任意点的最小值"}]},{"ID":"20230817161964-nh208da","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161964-nh208da","updated":"20230817161964"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"dijkstra算法"}]},{"ID":"20230817161965-kf47piv","Type":"NodeParagraph","Properties":{"id":"20230817161965-kf47piv","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"主要是解决单源路径问题 即一个点到其他所有点的最短路径"}]},{"ID":"20230817161966-tlw640w","Type":"NodeParagraph","Properties":{"id":"20230817161966-tlw640w","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"核心思想是每次找到离源点最近的点 然后以该点为中心进行拓展 最终得到原点到其余点的最短路径"}]},{"ID":"20230817161967-cvtnh16","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161967-cvtnh16","updated":"20230817161967"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.lanqiao.Y2021;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class Q4V2 {//dijstra算法\n    public static void main(String[] args) {\n        int [][]g=new int[2022][2022];\n        int inf=99999999;\n        int []dis=new int[2022];\n        int []book=new int[2022];\n        for(int i=1;i\u003c=2021;i++){\n            for(int j=1;j\u003c=2021;j++){\n                if(Math.abs(i-j)\u003c=21){\n                    int num=(i*j)/gcd(i,j);\n                    g[i][j]=num;\n                    g[j][i]=num;\n                }else {\n                    g[i][j]=inf;\n                    g[j][i]=inf;\n                }\n            }\n        }\n        for(int j=1;j\u003c=2021;j++){\n            dis[j]=g[1][j];\n        }\n        book[1]=1;\n        //dijkstra的核心算法\n        for(int n=1;n\u003c=2020;n++){\n            int min=inf;\n            int u=0;\n            for(int j=1;j\u003c=2021;j++){//找离源点最近的且为找过的点\n                if(book[j]==0\u0026\u0026book[j]\u003cmin){\n                    min=book[j];\n                    u=j;\n                }\n            }\n            book[u]=1;\n            for(int v=1;v\u003c=2021;v++){更新以u点作为跳板的最短路\n                if(g[u][v]\u003cinf\u0026\u0026(dis[v]\u003edis[u]+g[u][v])){\n                    dis[v]=dis[u]+g[u][v];\n                }\n            }\n\n        }\n        System.out.println(dis[2021]);\n    }\n    public  static int gcd(int a,int b){\n        if(a%b==0)return b;\n        return gcd(b,a%b);\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161968-covq9uu","Type":"NodeParagraph","Properties":{"id":"20230817161968-covq9uu","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"用堆优化后的程序：时间复杂度为n^(logn+n)"}]},{"ID":"20230817161969-f2rx6nx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-f2rx6nx","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.lanqiao.Y2021;\n\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class Q4V2 {//dijstra算法\n    public static void main(String[] args) {\n        int [][]g=new int[2022][2022];\n        int inf=99999999;\n        int []dis=new int[2022];\n        for(int i=1;i\u003c=2021;i++){\n            for(int j=1;j\u003c=2021;j++){\n                if(Math.abs(i-j)\u003c=21){\n                    int num=(i*j)/gcd(i,j);\n                    g[i][j]=num;\n                    g[j][i]=num;\n                }else {\n                    g[i][j]=inf;\n                    g[j][i]=inf;\n                }\n            }\n        }\n        PriorityQueue\u003cNode\u003e priorityQueue = new PriorityQueue\u003cNode\u003e();\n        for(int j=1;j\u003c=2021;j++){\n            dis[j]=g[1][j];\n            if(j!=1)priorityQueue.offer(new Node(j,g[1][j]));\n        }\n        //dijkstra的核心算法\n         int []vis=new int[2022];\n          vis[1]=1;\n           while (!priorityQueue.isEmpty()){\n            Node node = priorityQueue.poll();\n            int u=node.ind;\n            if(vis[u]==1)continue;\n             vis[u]=1;\n            for(int v=1;v\u003c=2021;v++){\n                if(g[u][v]\u003cinf\u0026\u0026(dis[v]\u003edis[u]+g[u][v])){\n                    dis[v]=dis[u]+g[u][v];\n                    priorityQueue.offer(new Node(v,dis[v]));\n                }\n            }\n\n        }\n        System.out.println(dis[2021]);\n    }\n    public  static int gcd(int a,int b){\n        if(a%b==0)return b;\n        return gcd(b,a%b);\n    }\n    static class  Node implements  Comparable\u003cNode\u003e{\n        int ind;\n        int value;\n\n        public Node(int ind, int value) {\n            this.ind = ind;\n            this.value = value;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return  this.value-o.value;\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}