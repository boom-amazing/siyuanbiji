{"ID":"20230817161856-o9vfag1","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161856-o9vfag1","title":"二分算法","updated":"20230817161856"},"Children":[{"ID":"20230817161857-lqitay1","Type":"NodeParagraph","Properties":{"id":"20230817161857-lqitay1","updated":"20230817161857"},"Children":[{"Type":"NodeText","Data":"二分算法"}]},{"ID":"20230817161858-twzujni","Type":"NodeParagraph","Properties":{"id":"20230817161858-twzujni","updated":"20230817161858"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"二分的是区间 一定要保证待查找的值在区间范围内"}]},{"ID":"20230817161859-8rbzhxj","Type":"NodeParagraph","Properties":{"id":"20230817161859-8rbzhxj","updated":"20230817161859"},"Children":[{"Type":"NodeText","Data":"二分算法主要注意边界条件的控制 左右指针的调整 还有就是最后的返回值 二分很容易导致无限循环 即内存溢出 所以要特别注意"}]},{"ID":"20230817161860-g8yv4ob","Type":"NodeParagraph","Properties":{"id":"20230817161860-g8yv4ob","updated":"20230817161860"},"Children":[{"Type":"NodeText","Data":"二分查找"}]},{"ID":"20230817161861-0ghwl9v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161861-0ghwl9v","updated":"20230817161861"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"  public static int binarySearchFind(int []arr,int target){\n      int head=0,tail=arr.length-1;\n        while(head\u003c=tail){\n          int mid=head+(tail-head)/2;\n          if(arr[mid]==target)return mid;\n          if(arr[mid]\u003etarget){\n              tail=mid-1;\n          }else{\n              head=mid+1;\n          }\n        }\n        return -1;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161862-sakdc4m","Type":"NodeParagraph","Properties":{"id":"20230817161862-sakdc4m","updated":"20230817161862"},"Children":[{"Type":"NodeText","Data":"二分泛型："}]},{"ID":"20230817161863-skaf6aq","Type":"NodeParagraph","Properties":{"id":"20230817161863-skaf6aq","updated":"20230817161863"},"Children":[{"Type":"NodeText","Data":"00000000111111111"}]},{"ID":"20230817161864-a6k4ip5","Type":"NodeParagraph","Properties":{"id":"20230817161864-a6k4ip5","updated":"20230817161864"},"Children":[{"Type":"NodeText","Data":"11111111000000000"}]},{"ID":"20230817161865-cphjuu9","Type":"NodeParagraph","Properties":{"id":"20230817161865-cphjuu9","updated":"20230817161865"},"Children":[{"Type":"NodeText","Data":"01模型 找第一个1"}]},{"ID":"20230817161866-oob6yhu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161866-oob6yhu","updated":"20230817161866"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public  static int binarySearch01(int []arr,int target){\n    int head=0,tail=arr.length-1;\n    while (head\u003ctail){\n        int mid=head+((tail-head)\u003e\u003e1);\n        if(arr[mid]\u003ctarget){\n            head=mid+1;\n        }else{\n            tail=mid;\n        }\n    }\n    return head;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161867-0tf1xfp","Type":"NodeParagraph","Properties":{"id":"20230817161867-0tf1xfp","updated":"20230817161867"},"Children":[{"Type":"NodeText","Data":"骚操作 二分区间范围 然后在一定范围内顺序查找 避免while的死循环"}]},{"ID":"20230817161868-wiuugve","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161868-wiuugve","updated":"20230817161868"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public  static int binarySearch01Sao(int []arr,int target){\n    int head=0,tail=arr.length-1;\n    while (tail-head\u003e3){\n        int mid=head+((tail-head)\u003e\u003e1);\n        if(arr[mid]\u003ctarget){\n            head=mid+1;\n        }else{\n            tail=mid;\n        }\n    }\n    for(int i=head;i\u003c=tail;i++){\n      if(arr[i]\u003e=target)return i;\n    }\n    return head;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161869-6irqo7g","Type":"NodeParagraph","Properties":{"id":"20230817161869-6irqo7g","updated":"20230817161869"},"Children":[{"Type":"NodeText","Data":"10模型："}]},{"ID":"20230817161870-qv0xrbr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161870-qv0xrbr","updated":"20230817161870"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/sqrtx/","TextMarkTextContent":"69. x 的平方根 "}]},{"ID":"20230817161871-kfuwg4s","Type":"NodeParagraph","Properties":{"id":"20230817161871-kfuwg4s","updated":"20230817161871"},"Children":[{"Type":"NodeText","Data":"难度简单930"}]},{"ID":"20230817161872-0xk06ou","Type":"NodeParagraph","Properties":{"id":"20230817161872-0xk06ou","updated":"20230817161872"},"Children":[{"Type":"NodeText","Data":"给你一个非负整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" ，计算并返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"算术平方根"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161873-mcjgsqi","Type":"NodeParagraph","Properties":{"id":"20230817161873-mcjgsqi","updated":"20230817161873"},"Children":[{"Type":"NodeText","Data":"由于返回类型是整数，结果只保留 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"整数部分"},{"Type":"NodeText","Data":" ，小数部分将被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"舍去 。"}]},{"ID":"20230817161874-v1qxzev","Type":"NodeParagraph","Properties":{"id":"20230817161874-v1qxzev","updated":"20230817161874"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"注意："},{"Type":"NodeText","Data":"不允许使用任何内置指数函数和算符，例如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"pow(x, 0.5)"},{"Type":"NodeText","Data":" 或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x ** 0.5"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161875-6u53qd1","Type":"NodeParagraph","Properties":{"id":"20230817161875-6u53qd1","updated":"20230817161875"},"Children":[{"Type":"NodeText","Data":"找到最后一个数的平方\u003c=x的值"}]},{"ID":"20230817161876-ymwe16d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161876-ymwe16d","updated":"20230817161876"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int mySqrt(int x) {\n      int head=0,tail=x;\n      while(tail-head\u003e3){\n        int mid=head+((tail-head)\u003e\u003e1);\n        if((long)mid*mid\u003c=x){\n          head=mid;\n        }else{\n          tail=mid-1;\n        }\n      }\n      int ans=-1;\n      for(int i=head;i\u003c=tail;i++){\n        if((long)i*i\u003c=x) ans=i;\n      }\n      return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161877-1px6epd","Type":"NodeParagraph","Properties":{"id":"20230817161877-1px6epd","updated":"20230817161877"},"Children":[{"Type":"NodeText","Data":"01模型："}]},{"ID":"20230817161878-rdqja63","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161878-rdqja63","updated":"20230817161878"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/search-insert-position/","TextMarkTextContent":"35. 搜索插入位置"}]},{"ID":"20230817161879-fkpnl3x","Type":"NodeParagraph","Properties":{"id":"20230817161879-fkpnl3x","updated":"20230817161879"},"Children":[{"Type":"NodeText","Data":"难度简单1419"}]},{"ID":"20230817161880-qluivsq","Type":"NodeParagraph","Properties":{"id":"20230817161880-qluivsq","updated":"20230817161880"},"Children":[{"Type":"NodeText","Data":"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。"}]},{"ID":"20230817161881-dh7s8ka","Type":"NodeParagraph","Properties":{"id":"20230817161881-dh7s8ka","updated":"20230817161881"},"Children":[{"Type":"NodeText","Data":"请必须使用时间复杂度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(log n)"},{"Type":"NodeText","Data":" 的算法。"}]},{"ID":"20230817161882-1xuddxi","Type":"NodeParagraph","Properties":{"id":"20230817161882-1xuddxi","updated":"20230817161882"},"Children":[{"Type":"NodeText","Data":"因为存在[1,5,7] target=8 即找不到第一个大于等于7的位置 处理策略就是找不到就返回数组的最后一个位置 即nums.length"}]},{"ID":"20230817161883-nijfmvd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161883-nijfmvd","updated":"20230817161883"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n      return  search(nums,target);\n    }\n     public int search(int[] nums,int target){\n        int l=0,r=nums.length-1;\n        while(r-l\u003e3){\n            int mid=(r+l)\u003e\u003e1;\n            if(nums[mid]\u003e=target)\n                r=mid;\n            else\n                l=mid+1;\n        }\n       for(int i=l;i\u003c=r;i++){\n         if(nums[i]\u003e=target)return i;//如果找到了返回\n       }\n       return nums.length;//找不到返回数组大小\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161884-3gk61uz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161884-3gk61uz","updated":"20230817161884"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/","TextMarkTextContent":"34. 在排序数组中查找元素的第一个和最后一个位置"}]},{"ID":"20230817161885-57nq9r1","Type":"NodeParagraph","Properties":{"id":"20230817161885-57nq9r1","updated":"20230817161885"},"Children":[{"Type":"NodeText","Data":"难度中等1537"}]},{"ID":"20230817161886-qy9f5ar","Type":"NodeParagraph","Properties":{"id":"20230817161886-qy9f5ar","updated":"20230817161886"},"Children":[{"Type":"NodeText","Data":"给定一个按照升序排列的整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":"，和一个目标值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":"。找出给定目标值在数组中的开始位置和结束位置。"}]},{"ID":"20230817161887-n4fohxo","Type":"NodeParagraph","Properties":{"id":"20230817161887-n4fohxo","updated":"20230817161887"},"Children":[{"Type":"NodeText","Data":"如果数组中不存在目标值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":"，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[-1, -1]"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230817161888-owz9fgm","Type":"NodeParagraph","Properties":{"id":"20230817161888-owz9fgm","updated":"20230817161888"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"进阶："}]},{"ID":"20230817161889-4lwzb03","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161889-4lwzb03","updated":"20230817161889"},"Children":[{"ID":"20230817161890-5tv52fy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161890-5tv52fy","updated":"20230817161890"},"Children":[{"ID":"20230817161891-8epczke","Type":"NodeParagraph","Properties":{"id":"20230817161891-8epczke","updated":"20230817161891"},"Children":[{"Type":"NodeText","Data":"你可以设计并实现时间复杂度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(log n)"},{"Type":"NodeText","Data":" 的算法解决此问题吗？"}]}]}]},{"ID":"20230817161892-wn5nr1o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161892-wn5nr1o","updated":"20230817161892"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    //先找\u003e=target的第一个\n    //再找\u003e=target+1的第一个\n    public int[] searchRange(int[] nums, int target) {\n        int l=search(nums,target);\n        int r=search(nums,target+1);\n        if(l==nums.length||nums[l]!=target)//如果找不到大于等于target的第一个位置 或者找到的数不等于target 直接返回-1，-1\n           return new int[]{-1,-1};\n        return new int[]{l,r-1};\n    }\n    public int search(int[] nums,int target){\n        int l=0,r=nums.length-1;\n        while(r-l\u003e3){\n            int mid=(r+l)\u003e\u003e1;\n            if(nums[mid]\u003e=target)\n                r=mid;\n            else\n                l=mid+1;\n        }\n       for(int i=l;i\u003c=r;i++){\n         if(nums[i]\u003e=target)return i;//如果找到了返回\n       }\n       return nums.length;//找不到返回数组大小\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161893-8qtz31w","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161893-8qtz31w","updated":"20230817161893"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/","TextMarkTextContent":"剑指 Offer 53 - I. 在排序数组中查找数字 I"}]},{"ID":"20230817161894-4uvexls","Type":"NodeParagraph","Properties":{"id":"20230817161894-4uvexls","updated":"20230817161894"},"Children":[{"Type":"NodeText","Data":"难度简单283"}]},{"ID":"20230817161895-mpt56bv","Type":"NodeParagraph","Properties":{"id":"20230817161895-mpt56bv","updated":"20230817161895"},"Children":[{"Type":"NodeText","Data":"统计一个数字在排序数组中出现的次数。"}]},{"ID":"20230817161896-cb27r91","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161896-cb27r91","updated":"20230817161896"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int search(int[] nums, int target) {//这么做其实有点复杂 最好是查找第一个\u003e=8的数 然后在顺序查找\n        if(nums.length==0)return 0;\n        int start=binarysearch(nums,target);\n        if(start==nums.length||nums[start]!=target)return 0;\n        int end=start;\n        while(end\u003cnums.length\u0026\u0026nums[end]==target)end++;\n        return end-start;\n    }\n   public int binarysearch(int[] nums,int target){\n        int l=0,r=nums.length-1;\n        while(r-l\u003e3){\n            int mid=(r+l)\u003e\u003e1;\n            if(nums[mid]\u003e=target)\n                r=mid;\n            else\n                l=mid+1;\n        }\n       for(int i=l;i\u003c=r;i++){\n         if(nums[i]\u003e=target)return i;//如果找到了返回\n       }\n       return nums.length;//找不到返回数组大小\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161897-ut2u244","Type":"NodeParagraph","Properties":{"id":"20230817161897-ut2u244","updated":"20230817161897"},"Children":[{"Type":"NodeText","Data":"01模型加10模型"}]},{"ID":"20230817161898-7auye17","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161898-7auye17","updated":"20230817161898"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/heaters/","TextMarkTextContent":"475. 供暖器"}]},{"ID":"20230817161899-moj68se","Type":"NodeParagraph","Properties":{"id":"20230817161899-moj68se","updated":"20230817161899"},"Children":[{"Type":"NodeText","Data":"难度中等382"}]},{"ID":"20230817161900-wp9e173","Type":"NodeParagraph","Properties":{"id":"20230817161900-wp9e173","updated":"20230817161900"},"Children":[{"Type":"NodeText","Data":"冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。"}]},{"ID":"20230817161901-xkob7d5","Type":"NodeParagraph","Properties":{"id":"20230817161901-xkob7d5","updated":"20230817161901"},"Children":[{"Type":"NodeText","Data":"在加热器的加热半径范围内的每个房屋都可以获得供暖。"}]},{"ID":"20230817161902-r12z4sn","Type":"NodeParagraph","Properties":{"id":"20230817161902-r12z4sn","updated":"20230817161902"},"Children":[{"Type":"NodeText","Data":"现在，给出位于一条水平线上的房屋 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"houses"},{"Type":"NodeText","Data":" 和供暖器 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"heaters"},{"Type":"NodeText","Data":" 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。"}]},{"ID":"20230817161903-wz6j1xm","Type":"NodeParagraph","Properties":{"id":"20230817161903-wz6j1xm","updated":"20230817161903"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：所有供暖器都遵循你的半径标准，加热的半径也一样。"}]},{"ID":"20230817161904-5eqfjei","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161904-5eqfjei","updated":"20230817161904"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n      Arrays.sort(heaters);\n      int ans=Integer.MIN_VALUE;\n      for(int i=0;i\u003chouses.length;i++){\n        int lower=binartSearch10(heaters,houses[i]);\n        int upper=binartSearch01(heaters,houses[i]);\n        int r;\n        if(lower==-1\u0026\u0026upper==heaters.length){\n          continue;\n        }else if(lower==-1\u0026\u0026upper\u003cheaters.length){\n          r=Math.abs(heaters[upper]-houses[i]);\n        }else if(upper==heaters.length\u0026\u0026lower\u003e=0){\n          r=Math.abs(heaters[lower]-houses[i]);\n        }else{\n          r=Math.min(Math.abs(heaters[lower]-houses[i]),Math.abs(heaters[upper]-houses[i]));\n        }\n        ans=Math.max(r,ans);\n      }\n      return ans;\n    }\n    public int binartSearch10(int []nums,int target){\n      int head=0,tail=nums.length-1;\n      while(tail-head\u003e3){\n        int mid=(head+tail)\u003e\u003e1;\n        if(nums[mid]\u003c=target){\n          head=mid;\n        }else{\n          tail=mid-1;\n        }\n      }\n      int ans=-1;\n      for(int i=head;i\u003c=tail;i++){\n        if(nums[i]\u003c=target)ans=i;\n      }\n      return ans;\n    }\n     public int binartSearch01(int []nums,int target){\n      int head=0,tail=nums.length-1;\n      while(tail-head\u003e3){\n        int mid=(head+tail)\u003e\u003e1;\n        if(nums[mid]\u003ctarget){\n          head=mid+1;\n        }else{\n          tail=mid;\n        }\n      }\n      for(int i=head;i\u003c=tail;i++){\n        if(nums[i]\u003e=target)return i;\n      }\n      return nums.length;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161905-3svber9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161905-3svber9","updated":"20230817161905"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/","TextMarkTextContent":"33. 搜索旋转排序数组"}]},{"ID":"20230817161906-vidck73","Type":"NodeParagraph","Properties":{"id":"20230817161906-vidck73","updated":"20230817161906"},"Children":[{"Type":"NodeText","Data":"难度中等1916"}]},{"ID":"20230817161907-358lund","Type":"NodeParagraph","Properties":{"id":"20230817161907-358lund","updated":"20230817161907"},"Children":[{"Type":"NodeText","Data":"整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 按升序排列，数组中的值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"互不相同"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161908-bag9j8u","Type":"NodeParagraph","Properties":{"id":"20230817161908-bag9j8u","updated":"20230817161908"},"Children":[{"Type":"NodeText","Data":"在传递给函数之前，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 在预先未知的某个下标 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0 \u0026lt;= k \u0026lt; nums.length"},{"Type":"NodeText","Data":"）上进行了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"旋转"},{"Type":"NodeText","Data":"，使数组变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]"},{"Type":"NodeText","Data":"（下标 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从 0 开始"},{"Type":"NodeText","Data":" 计数）。例如， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[0,1,2,4,5,6,7]"},{"Type":"NodeText","Data":" 在下标 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"3"},{"Type":"NodeText","Data":" 处经旋转后可能变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[4,5,6,7,0,1,2]"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161909-83359s8","Type":"NodeParagraph","Properties":{"id":"20230817161909-83359s8","updated":"20230817161909"},"Children":[{"Type":"NodeText","Data":"给你 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"旋转后"},{"Type":"NodeText","Data":" 的数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 和一个整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" ，如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 中存在这个目标值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" ，则返回它的下标，否则返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-1"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161910-m99wddi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161910-m99wddi","updated":"20230817161910"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int search(int[] nums, int target) {//二分区间 相当于两次二分 第一次主要是确定有序区间 第二次来缩小区间\n       int head=0,tail=nums.length-1;\n       while(head\u003c=tail){\n         int mid=(head+tail)\u003e\u003e1;\n         if(nums[mid]==target)return mid;\n         if(nums[mid]\u003c=nums[tail]){\n            if(target\u003enums[mid]\u0026\u0026target\u003c=nums[tail]){\n              head=mid+1;\n            }else{\n              tail=mid-1;\n            }      \n           }else{\n           if(target\u003e=nums[head]\u0026\u0026target\u003cnums[mid]){\n             tail=mid-1;\n           }else{\n             head=mid+1;\n           }\n         }\n       }\n       return -1;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161911-airkrbk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161911-airkrbk","updated":"20230817161911"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/","TextMarkTextContent":"81. 搜索旋转排序数组 II"}]},{"ID":"20230817161912-th8y2hh","Type":"NodeParagraph","Properties":{"id":"20230817161912-th8y2hh","updated":"20230817161912"},"Children":[{"Type":"NodeText","Data":"难度中等558"}]},{"ID":"20230817161913-62cglgb","Type":"NodeParagraph","Properties":{"id":"20230817161913-62cglgb","updated":"20230817161913"},"Children":[{"Type":"NodeText","Data":"已知存在一个按非降序排列的整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" ，数组中的值不必互不相同。"}]},{"ID":"20230817161914-eu81kau","Type":"NodeParagraph","Properties":{"id":"20230817161914-eu81kau","updated":"20230817161914"},"Children":[{"Type":"NodeText","Data":"在传递给函数之前，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 在预先未知的某个下标 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0 \u0026lt;= k \u0026lt; nums.length"},{"Type":"NodeText","Data":"）上进行了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"旋转"},{"Type":"NodeText","Data":" ，使数组变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]"},{"Type":"NodeText","Data":"（下标 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"从 0 开始"},{"Type":"NodeText","Data":" 计数）。例如， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[0,1,2,4,4,4,5,6,6,7]"},{"Type":"NodeText","Data":" 在下标 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"5"},{"Type":"NodeText","Data":" 处经旋转后可能变为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[4,5,6,6,7,0,1,2,4,4]"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161915-3wcqwiw","Type":"NodeParagraph","Properties":{"id":"20230817161915-3wcqwiw","updated":"20230817161915"},"Children":[{"Type":"NodeText","Data":"给你 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"旋转后"},{"Type":"NodeText","Data":" 的数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 和一个整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 中存在这个目标值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" ，则返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" ，否则返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161916-vpmw4ib","Type":"NodeParagraph","Properties":{"id":"20230817161916-vpmw4ib","updated":"20230817161916"},"Children":[{"Type":"NodeText","Data":"你必须尽可能减少整个操作步骤。"}]},{"ID":"20230817161917-h5rnum9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161917-h5rnum9","updated":"20230817161917"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public boolean search(int[] nums, int target) {\n    //因为有重复元素 相比与33题我们需要对首尾元素进行判重 如果不去重 会导致左右有序区间无法确定\n     int head=0,tail=nums.length-1;\n     if(nums[head]==target||nums[tail]==target)return true;\n     while(head\u003cnums.length\u0026\u0026nums[head]==nums[0])head++;\n     while(tail\u003e=0\u0026\u0026nums[tail]==nums[0])tail--;\n     while(head\u003c=tail){\n       int mid=(head+tail)\u003e\u003e1;\n       if(nums[mid]==target)return true;\n       if(nums[mid]\u003c=nums[tail]){\n         if(target\u003enums[mid]\u0026\u0026target\u003c=nums[tail])head=mid+1;\n         else tail=mid-1;\n       }else{\n        if(target\u003e=nums[head]\u0026\u0026target\u003cnums[mid])tail=mid-1;\n        else head=mid+1;\n       }\n     }\n    return false;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161918-47dzioa","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161918-47dzioa","updated":"20230817161918"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/","TextMarkTextContent":"4. 寻找两个正序数组的中位数"}]},{"ID":"20230817161919-wr9a7t4","Type":"NodeParagraph","Properties":{"id":"20230817161919-wr9a7t4","updated":"20230817161919"},"Children":[{"Type":"NodeText","Data":"难度困难5152"}]},{"ID":"20230817161920-n0uylos","Type":"NodeParagraph","Properties":{"id":"20230817161920-n0uylos","updated":"20230817161920"},"Children":[{"Type":"NodeText","Data":"给定两个大小分别为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"n"},{"Type":"NodeText","Data":" 的正序（从小到大）数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums1"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"。请你找出并返回这两个正序数组的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中位数"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161921-zolu24w","Type":"NodeParagraph","Properties":{"id":"20230817161921-zolu24w","updated":"20230817161921"},"Children":[{"Type":"NodeText","Data":"算法的时间复杂度应该为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"O(log (m+n))"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161922-nr0kp9k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161922-nr0kp9k","updated":"20230817161922"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {//寻找两个有序数组中的第k个元素 \n    //复杂度位log(m+n) \n     int n=nums1.length,m=nums2.length;\n     int mid=(n+m+1)/2;\n     int  a=findk(nums1,nums2,0,0,mid);\n     if((n+m)%2==1)return a/1.0;\n     int b=findk(nums1,nums2,0,0,mid+1);\n     return (a+b)/2.0;\n   }\n    public  int  findk(int []nums1,int[] nums2,int i,int j,int k){\n      if(i==nums1.length)return nums2[j+k-1];\n      if(j==nums2.length)return nums1[i+k-1];\n      if(k==1)return nums1[i]\u003cnums2[j]?nums1[i]:nums2[j];\n      int a=Math.min(k/2,nums1.length-i);\n      int b=Math.min(k-a,nums2.length-j);\n      a=k-b;\n      if(nums1[i+a-1]\u003c=nums2[j+b-1]){\n        return findk(nums1,nums2,i+a,j,k-a);\n      }\n      return findk(nums1,nums2,i,j+b,k-b);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161923-hydljrq","Type":"NodeParagraph","Properties":{"id":"20230817161923-hydljrq","updated":"20230817161923"},"Children":[{"Type":"NodeText","Data":"寻找两个有序数组的第K大元素 时间复杂度为log(m+n)"}]},{"ID":"20230817161924-5fsnsm8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161924-5fsnsm8","updated":"20230817161924"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class FindK {\n    public static int  findk(int []nums1,int[] nums2,int i,int j,int k){\n        if(i==nums1.length)return nums2[j+k-1];\n        if(j==nums2.length)return nums1[i+k-1];\n        if(k==1)return nums1[i]\u003cnums2[j]?nums1[i]:nums2[j];\n        int a=Math.min(k/2,nums1.length-i);\n        int b=Math.min(k-a,nums2.length-j);\n        a=k-b;\n        if(nums1[i+a-1]\u003c=nums2[j+b-1]){\n            return findk(nums1,nums2,i+a,j,k-a);\n        }\n        return findk(nums1,nums2,i,j+b,k-b);\n    }\n\n    public static void main(String[] args) {\n        int []arr1={1,2,3,4,5};\n        int []arr2={3,4,5,6,7};\n        System.out.println(findk(arr1,arr2,0,0,10));\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161925-hqvbckw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161925-hqvbckw","updated":"20230817161925"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/longest-increasing-subsequence/","TextMarkTextContent":"300. 最长递增子序列"}]},{"ID":"20230817161926-xvr0kgm","Type":"NodeParagraph","Properties":{"id":"20230817161926-xvr0kgm","updated":"20230817161926"},"Children":[{"Type":"NodeText","Data":"难度中等2327"}]},{"ID":"20230817161927-kqlzwj8","Type":"NodeParagraph","Properties":{"id":"20230817161927-kqlzwj8","updated":"20230817161927"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" ，找到其中最长严格递增子序列的长度。"}]},{"ID":"20230817161928-hi9zj27","Type":"NodeParagraph","Properties":{"id":"20230817161928-hi9zj27","updated":"20230817161928"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"子序列"},{"Type":"NodeText","Data":" 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[3,6,2,7]"},{"Type":"NodeText","Data":" 是数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[0,3,1,6,2,2,7]"},{"Type":"NodeText","Data":" 的子序列。"}]},{"ID":"20230817161929-ulcgcus","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161929-ulcgcus","updated":"20230817161929"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n      List\u003cInteger\u003e arr=new ArrayList();\n      arr.add(nums[0]);\n      for(int j=1;j\u003cnums.length;j++){\n        if(nums[j]\u003earr.get(arr.size()-1)){\n          arr.add(nums[j]);\n        }else{\n          int ind=binarySearch01(arr,nums[j]);\n          arr.set(ind,nums[j]);\n        }\n       }\n       return arr.size();\n    }\n    public int binarySearch01(List\u003cInteger\u003enums,int target){\n      int head=0,tail=nums.size()-1;\n      while(head\u003ctail){\n      int mid=(head+tail)\u003e\u003e1;\n      if(nums.get(mid)\u003ctarget){\n        head=mid+1;\n      }else{\n        tail=mid;\n      }\n      }\n      return head;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}