{"ID":"20230817161957-9ygrhq2","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161957-9ygrhq2","title":"TWO SUM问题","updated":"20230817161957"},"Children":[{"ID":"20230817161958-kbhh39q","Type":"NodeParagraph","Properties":{"id":"20230817161958-kbhh39q","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"TWO SUM问题"}]},{"ID":"20230817161959-8l41455","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161959-8l41455","updated":"20230817161959"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/two-sum/","TextMarkTextContent":"1. 两数之和"}]},{"ID":"20230817161960-dfgx4r3","Type":"NodeParagraph","Properties":{"id":"20230817161960-dfgx4r3","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"难度简单13756"}]},{"ID":"20230817161961-l5n9u2f","Type":"NodeParagraph","Properties":{"id":"20230817161961-l5n9u2f","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"给定一个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 和一个整数目标值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":"，请你在该数组中找出 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"和为目标值"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" 的那 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"两个"},{"Type":"NodeText","Data":" 整数，并返回它们的数组下标。"}]},{"ID":"20230817161962-pfz2j7y","Type":"NodeParagraph","Properties":{"id":"20230817161962-pfz2j7y","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。"}]},{"ID":"20230817161963-1dbsijw","Type":"NodeParagraph","Properties":{"id":"20230817161963-1dbsijw","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"你可以按任意顺序返回答案。"}]},{"ID":"20230817161964-4oiek90","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161964-4oiek90","updated":"20230817161964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n     HashMap\u003cInteger,Integer\u003e h=new HashMap();\n     for(int i=0;i\u003cnums.length;i++){\n       if(h.containsKey(target-nums[i])){\n         int ind=h.get(target-nums[i]);\n         return new int[]{ind,i};\n       }\n       h.put(nums[i],i);\n     }\n     return new int[]{-1,-1};\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161965-r54gdzt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161965-r54gdzt","updated":"20230817161965"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/","TextMarkTextContent":"1658. 将 x 减到 0 的最小操作数"}]},{"ID":"20230817161966-8vl6rj8","Type":"NodeParagraph","Properties":{"id":"20230817161966-8vl6rj8","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"难度中等89"}]},{"ID":"20230817161967-b7m83mv","Type":"NodeParagraph","Properties":{"id":"20230817161967-b7m83mv","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 和一个整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 。每一次操作时，你应当移除数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 最左边或最右边的元素，然后从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 中减去该元素的值。请注意，需要 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"修改"},{"Type":"NodeText","Data":" 数组以供接下来的操作使用。"}]},{"ID":"20230817161968-j0m0br1","Type":"NodeParagraph","Properties":{"id":"20230817161968-j0m0br1","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"如果可以将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"恰好"},{"Type":"NodeText","Data":" 减到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":" ，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"最小操作数"},{"Type":"NodeText","Data":" ；否则，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"-1"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161969-2e1y09r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-2e1y09r","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int minOperations(int[] nums, int x) {//这个题其实就是两数之和的变种 可以统计左右两边的前缀和\n       int n=nums.length;\n       int []lsum=new int[n+1];\n       int []rsum=new int[n+1];\n       \n       for(int i=0;i\u003cnums.length;i++){\n         lsum[i+1]=lsum[i]+nums[i];\n       }\n       for(int j=nums.length-1;j\u003e=0;j--){\n         rsum[nums.length-j]=rsum[nums.length-j-1]+nums[j];\n       }\n      HashMap\u003cInteger,Integer\u003e h=new HashMap();\n      for(int i=0;i\u003crsum.length;i++){\n        h.put(rsum[i],i);\n      }\n      int ans=Integer.MAX_VALUE;\n      for(int i=0;i\u003clsum.length;i++){\n        if(h.containsKey(x-lsum[i])){\n          int ind=h.get(x-lsum[i]);\n          if(i+ind\u003c=nums.length){\n           ans=Math.min(ans,i+ind);\n          }\n        }\n      }\n     if(ans==Integer.MAX_VALUE)return -1;\n     return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}