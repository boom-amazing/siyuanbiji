{"ID":"20230817161932-ce9ngix","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161932-ce9ngix","title":"堆(优先队列)","updated":"20230817161932"},"Children":[{"ID":"20230817161933-ql8uw1h","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161933-ql8uw1h","updated":"20230817161933"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"堆(优先队列)"}]},{"ID":"20230817161934-gp1pn1p","Type":"NodeParagraph","Properties":{"id":"20230817161934-gp1pn1p","updated":"20230817161934"},"Children":[{"Type":"NodeText","Data":"堆化的过程：其中插入和删除元素时间复杂度都是logn 而获取堆顶元素时间复杂度是o(1) 下表从1开始"}]},{"ID":"20230817161935-dlk0m9j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161935-dlk0m9j","updated":"20230817161935"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class HeapDemo {\n    int []arr;\n    int cnt;//堆中的元素\n    int capacity;\n    public HeapDemo(int capacity) {\n        this.arr = new int[capacity+1];\n        this.capacity=capacity;//堆中可以存储的最大数量\n        this.cnt = 0;\n    }\n    public  void insert(int val){\n        if(cnt\u003ecapacity)return;\n        arr[++cnt]=val;\n        int i=cnt;\n      heapUp(arr,i);\n    }\n    public void  heapUp(int []arr,int ind){\n        while(ind/2\u003e0\u0026\u0026arr[ind]\u003earr[ind/2]){//注意应该是ind/2\u003e0 而不是ind\u003e0\n            swap(arr,ind,ind/2);\n            ind=ind/2;\n        }\n    }\n    public  void remove(int val){\n        if(cnt==0)return;\n        arr[1]=arr[cnt];\n        cnt--;\n        heapDown(arr,1);\n\n    }\n    public  void  heapDown(int []arr,int ind){\n        while(true){\n            int maxind=ind;\n            if(ind*2\u003c=cnt\u0026\u0026arr[ind*2]\u003earr[maxind])maxind=ind*2;\n            if(ind*2+1\u003c=cnt\u0026\u0026arr[ind*2+1]\u003earr[maxind])maxind=ind*2+1;\n            if(maxind==ind)break;\n            swap(arr,ind,maxind);\n            ind=maxind;\n        }\n    }\n\n    public  int getmax(){\n        return arr[1];\n    }\n    public  void swap(int []arr,int i,int j){\n        int temp= arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161936-7682ocw","Type":"NodeParagraph","Properties":{"id":"20230817161936-7682ocw","updated":"20230817161936"},"Children":[{"Type":"NodeText","Data":"堆排序：//错误的"}]},{"ID":"20230817161937-hjg4wpx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161937-hjg4wpx","updated":"20230817161937"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class HeapSort {\n    public static void main(String[] args) {\n        HeapSort heapSort = new HeapSort();\n        int []arr={1,3,5,4,6};\n//         heapSort.buildHeap(arr,arr.length);\n        heapSort.sort(arr,arr.length);\n        for(int x:arr){\n            System.out.print(x+\" \");\n        }\n    }\n    public void buildHeap(int[] arr, int n) {//n代表数组中的元素个数\n        for (int i = n / 2; i \u003e= 0; --i) {//建堆选择从后向前建 并且选择自顶向下堆化\n            heapDown(arr, i, n);\n        }\n    }\n\n    public void sort(int[] arr, int n) {//n代表数组个数\n        buildHeap(arr, n);//o(n)\n        int k=n-1;\n        while(k\u003e0){\n            swap(arr,0,k);\n            k-=1;\n            heapDown(arr,0,k);\n        }\n    }\n\n  public  void  swap(int []arr,int i,int j){\n        int temp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n  }\n    public void heapDown(int[] arr, int i, int n) {\n        while (true) {\n            int maxpos = i;\n            if (i * 2+1 \u003cn \u0026\u0026 arr[i * 2+1] \u003e arr[i]) maxpos = i * 2+1;\n            if (i * 2 + 2\u003c n \u0026\u0026 arr[i * 2 +2] \u003e arr[maxpos]) maxpos = i * 2 + 2;\n            if (i == maxpos) break;\n            swap(arr,i,maxpos);\n            i = maxpos;\n        }\n\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161938-kn8qxex","Type":"NodeParagraph","Properties":{"id":"20230817161938-kn8qxex","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"堆排序的建堆时间复杂度为o(n) 排序时间复杂度为o(logn)"}]},{"ID":"20230817161939-crxbpkd","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161939-crxbpkd","updated":"20230817161939"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么堆排序和快速排序都是nlogn 实际工程中却要选择快速排序作为排序的方式呢？"}]},{"ID":"20230817161940-5y0uy67","Type":"NodeParagraph","Properties":{"id":"20230817161940-5y0uy67","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"1、堆排序的数据访问是随机访问 堆排序的堆化会按照跳序访问 他不会像快速排序那样顺序访问数据 这样堆排序就无法利用cpu缓存预读数据"}]},{"ID":"20230817161941-ystavuo","Type":"NodeParagraph","Properties":{"id":"20230817161941-ystavuo","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"2、堆排序在排序过程中交换元素的次数要多于快速排序"}]},{"ID":"20230817161942-m3smfcw","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161942-m3smfcw","updated":"20230817161942"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"堆的应用"}]},{"ID":"20230817161943-y95hd0f","Type":"NodeParagraph","Properties":{"id":"20230817161943-y95hd0f","updated":"20230817161943"},"Children":[{"Type":"NodeText","Data":"1、优先级队列"}]},{"ID":"20230817161944-8scczl5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161944-8scczl5","updated":"20230817161944"},"Children":[{"ID":"20230817161945-openmhf","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161945-openmhf","updated":"20230817161945"},"Children":[{"ID":"20230817161946-likf9rm","Type":"NodeParagraph","Properties":{"id":"20230817161946-likf9rm","updated":"20230817161946"},"Children":[{"Type":"NodeText","Data":"合并多个有序文件"}]}]},{"ID":"20230817161947-53p31vl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161947-53p31vl","updated":"20230817161947"},"Children":[{"ID":"20230817161948-azvjppt","Type":"NodeParagraph","Properties":{"id":"20230817161948-azvjppt","updated":"20230817161948"},"Children":[{"Type":"NodeText","Data":"高性能定时器"}]}]}]},{"ID":"20230817161949-s3l3aid","Type":"NodeParagraph","Properties":{"id":"20230817161949-s3l3aid","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"2、求TOPk"}]},{"ID":"20230817161950-vzlflr0","Type":"NodeParagraph","Properties":{"id":"20230817161950-vzlflr0","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"直接使用大顶堆或者小顶对就能实现"}]},{"ID":"20230817161951-9mguzb7","Type":"NodeParagraph","Properties":{"id":"20230817161951-9mguzb7","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"3、求中位数和百分位数"}]},{"ID":"20230817161952-7sem6fx","Type":"NodeParagraph","Properties":{"id":"20230817161952-7sem6fx","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"维护两个堆 一个大顶堆 一个小顶堆"}]},{"ID":"20230817161953-e3l9gea","Type":"NodeParagraph","Properties":{"id":"20230817161953-e3l9gea","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"LC295 数据流中的中位数"}]},{"ID":"20230817161954-ugg6qhe","Type":"NodeParagraph","Properties":{"id":"20230817161954-ugg6qhe","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"难度困难649"}]},{"ID":"20230817161955-ye420hr","Type":"NodeParagraph","Properties":{"id":"20230817161955-ye420hr","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。"}]},{"ID":"20230817161956-3dqbpp0","Type":"NodeParagraph","Properties":{"id":"20230817161956-3dqbpp0","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"例如，"}]},{"ID":"20230817161957-0uf905t","Type":"NodeParagraph","Properties":{"id":"20230817161957-0uf905t","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"[2,3,4] 的中位数是 3"}]},{"ID":"20230817161958-ahwbazz","Type":"NodeParagraph","Properties":{"id":"20230817161958-ahwbazz","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"[2,3] 的中位数是 (2 + 3) / 2 = 2.5"}]},{"ID":"20230817161959-uikpaz5","Type":"NodeParagraph","Properties":{"id":"20230817161959-uikpaz5","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"设计一个支持以下两种操作的数据结构："}]},{"ID":"20230817161960-mkz4mb4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161960-mkz4mb4","updated":"20230817161960"},"Children":[{"ID":"20230817161961-46sgxf2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161961-46sgxf2","updated":"20230817161961"},"Children":[{"ID":"20230817161962-z7n2kbp","Type":"NodeParagraph","Properties":{"id":"20230817161962-z7n2kbp","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"void addNum(int num) - 从数据流中添加一个整数到数据结构中。"}]}]},{"ID":"20230817161963-zc7k9an","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161963-zc7k9an","updated":"20230817161963"},"Children":[{"ID":"20230817161964-doo3rk1","Type":"NodeParagraph","Properties":{"id":"20230817161964-doo3rk1","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"double findMedian() - 返回目前所有元素的中位数。"}]}]}]},{"ID":"20230817161965-240xva5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161965-240xva5","updated":"20230817161965"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class MedianFinder {\n     //因为要求有序列表的中位数 插入的过程还是动态的 如果是静态的我们可以直接排序来去中位数 如果是动态的我们可以使用\n     //两个堆来维护动态列表中的中位数\n    PriorityQueue\u003cInteger\u003e qmax;\n    PriorityQueue\u003cInteger\u003e qmin;\n    public MedianFinder() {\n      qmax=new PriorityQueue\u003c\u003e((o1,o2)-\u003eo2-o1);\n       qmin=new PriorityQueue\u003c\u003e((o1,o2)-\u003eo1-o2);\n    }\n    \n    public void addNum(int num) {\n      if(qmin.size()==0||num\u003e=qmin.peek()){\n        qmin.offer(num);\n      }else{\n        qmax.offer(num);\n      }\n      //约定小顶堆中的元素比大顶堆中的元素多一\n      if(qmax.size()\u003eqmin.size()){\n        qmin.offer(qmax.poll());\n      }\n      if(qmin.size()==qmax.size()+2){\n        qmax.offer(qmin.poll());\n      }\n    }\n    \n    public double findMedian() {\n      if(qmin.size()==qmax.size())return (qmin.peek()+qmax.peek())/2.0;\n      else return qmin.peek();\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161966-7e7oxep","Type":"NodeParagraph","Properties":{"id":"20230817161966-7e7oxep","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"%99分位的数"}]},{"ID":"20230817161967-00wc20m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161967-00wc20m","updated":"20230817161967"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Persent99num {\n    public static void main(String[] args) {\n        Persent99num persent99num = new Persent99num();\n        for(int i=1;i\u003c=100;i++) {\n            persent99num.add(i);\n        }\n        System.out.println(persent99num.getPersent99());\n    }\n    PriorityQueue\u003cInteger\u003eqmax;\n    PriorityQueue\u003cInteger\u003eqmin;\n    public  Persent99num(){\n        qmax=new PriorityQueue\u003c\u003e((o1,o2)-\u003eo2-o1);\n        qmin=new PriorityQueue\u003c\u003e(((o1, o2) -\u003e o1-o2));\n    }\n    public  void  add(int num){\n        if(qmax.isEmpty()||num\u003c=qmax.peek()){\n            qmax.offer(num);\n        }else{\n            qmin.offer(num);\n        }\n        if(qmax.size()\u003cqmin.size()*99)qmax.offer(qmin.poll());\n        if(qmax.size()==qmin.size()*99+1)qmin.offer(qmax.poll());\n    }\n    public  int getPersent99(){\n        return qmax.peek();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161968-mvtrct4","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161968-mvtrct4","updated":"20230817161968"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何从包含10亿个搜索关键词的日志文件中 在单机系统中 限定内存为1Gb 统计出TOP10的热门搜索关键词？"}]},{"ID":"20230817161969-ab6icyw","Type":"NodeParagraph","Properties":{"id":"20230817161969-ab6icyw","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"我们可以创建10个空文件 然后通过哈希算法计算这10亿个关键词的哈希值 因为相同的元素得到的哈希值是一样的 这样我们就可以把相同的搜索关键词分到同一个文件中 然后对10取模 依次放入对应的文件编号中去 然后可以利用哈希表计数 去重之后 假设每个关键词的大小为50B 去出重复的就剩下1000万个不重复的文件 那么1000万个关键词就是500MB 用1G的内存对每个小文件排序取出top10 再从10个文件中最终取出top10"}]}]}