{"ID":"20230817161842-ovixelf","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161842-ovixelf","title":"动态规划入门","updated":"20230817161842"},"Children":[{"ID":"20230817161843-1ufrve6","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161843-1ufrve6","updated":"20230817161843"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"动态规划入门"}]},{"ID":"20230817161844-aeblavc","Type":"NodeParagraph","Properties":{"id":"20230817161844-aeblavc","updated":"20230817161844"},"Children":[{"Type":"NodeText","Data":"动态规划就是递推性问题的最优解的解答"}]},{"ID":"20230817161845-yhhr063","Type":"NodeParagraph","Properties":{"id":"20230817161845-yhhr063","updated":"20230817161845"},"Children":[{"Type":"NodeText","Data":"动态规划四部曲："}]},{"ID":"20230817161846-jw8c23d","Type":"NodeParagraph","Properties":{"id":"20230817161846-jw8c23d","updated":"20230817161846"},"Children":[{"Type":"NodeText","Data":"1、确定递推状态 函数符号 f(x)以及这个函数符号的描述"}]},{"ID":"20230817161847-bfifwgb","Type":"NodeParagraph","Properties":{"id":"20230817161847-bfifwgb","updated":"20230817161847"},"Children":[{"Type":"NodeText","Data":"2、确定递推公式"}]},{"ID":"20230817161848-n3nb3t5","Type":"NodeParagraph","Properties":{"id":"20230817161848-n3nb3t5","updated":"20230817161848"},"Children":[{"Type":"NodeText","Data":"3、分析边界条件"}]},{"ID":"20230817161849-vwh6rc3","Type":"NodeParagraph","Properties":{"id":"20230817161849-vwh6rc3","updated":"20230817161849"},"Children":[{"Type":"NodeText","Data":"4、程序实现"}]},{"ID":"20230817161850-6dkr9sn","Type":"NodeParagraph","Properties":{"id":"20230817161850-6dkr9sn","updated":"20230817161850"},"Children":[{"Type":"NodeText","Data":"经典例题："}]},{"ID":"20230817161851-bwefw3o","Type":"NodeParagraph","Properties":{"id":"20230817161851-bwefw3o","updated":"20230817161851"},"Children":[{"Type":"NodeText","Data":"01背包问题：题目描述"}]},{"ID":"20230817161852-jc1tolu","Type":"NodeParagraph","Properties":{"id":"20230817161852-jc1tolu","updated":"20230817161852"},"Children":[{"Type":"NodeText","Data":"给一个能承重VV的背包，和nn件物品，我们用重量和价值的二元组来表示一个物品，第ii件物品表示为（Vi，Wi）（Vi，Wi），问：在背包不超重的情况下，得到物品的最大价值是多少？"}]},{"ID":"20230817161853-ajz9bxv","Type":"NodeParagraph","Properties":{"id":"20230817161853-ajz9bxv","updated":"20230817161853"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"54E9C51263E1462585A8F6595841EEC0.jpg","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"http://47.93.11.51:88/img/2019-05-26/54E9C51263E1462585A8F6595841EEC0.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161854-vrc0zkv","Type":"NodeThematicBreak","Properties":{"id":"20230817161854-vrc0zkv","updated":"20230817161854"}},{"ID":"20230817161855-darb547","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161855-darb547","updated":"20230817161855"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"输入"}]},{"ID":"20230817161856-j9a08g3","Type":"NodeParagraph","Properties":{"id":"20230817161856-j9a08g3","updated":"20230817161856"},"Children":[{"Type":"NodeText","Data":"第一行输入两个数 V,n，分别代表背包的最大承重和物品数。"}]},{"ID":"20230817161857-vx8g43z","Type":"NodeParagraph","Properties":{"id":"20230817161857-vx8g43z","updated":"20230817161857"},"Children":[{"Type":"NodeText","Data":"接下来n行，每行两个数Vi,Wi，分别代表第i件物品的重量和价值。"}]},{"ID":"20230817161858-kadp1yr","Type":"NodeParagraph","Properties":{"id":"20230817161858-kadp1yr","updated":"20230817161858"},"Children":[{"Type":"NodeText","Data":"(Vi≤V≤10000,n≤100,Wi≤1000000)"}]},{"ID":"20230817161859-wf3wtja","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161859-wf3wtja","updated":"20230817161859"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"输出"}]},{"ID":"20230817161860-flt80ta","Type":"NodeParagraph","Properties":{"id":"20230817161860-flt80ta","updated":"20230817161860"},"Children":[{"Type":"NodeText","Data":"输出一个整数，代表在背包不超重情况下所装物品的最大价值。"}]},{"ID":"20230817161861-ivhp4q4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161861-ivhp4q4","updated":"20230817161861"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Package01 {\n    /*\n    状态定义:f(i，j)代表前i个物品 最大承重为j所获得的的最大价值\n    递推方程:f(i,j)=max f(i-1,j),不选择第i个物品\n                  f(i,j-v[i])+w[i],选择第i个物品 那么前i-1个物品最大承重就为j-v[i] 所获得的价值加上w[i]\n     */\n    static int []vi=new int[105];\n    static int []wi=new int[105];\n    static  int[][]dp=new int[2][10005];\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int V = sc.nextInt();\n         int n=sc.nextInt();\n         for(int i=1;i\u003c=n;i++){\n             vi[i]=sc.nextInt();\n             wi[i]=sc.nextInt();\n         }\n         for(int i=1;i\u003c=n;i++){\n             for(int j=0;j\u003c=V;j++){\n                 int ind=i%2;\n                 int preind=1-ind;\n                 dp[ind][j]=dp[preind][j];\n                 if(j\u003e=vi[i])dp[ind][j]=Math.max(dp[preind][j-vi[i]]+wi[i],dp[ind][j]);\n             }\n         }\n        System.out.println(dp[n%2][V]);\n    }\n}\n//输入输出结果:\n15 4\n4 10\n3 7\n12 12\n9 8\n19\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161862-gznh1up","Type":"NodeParagraph","Properties":{"id":"20230817161862-gznh1up","updated":"20230817161862"},"Children":[{"Type":"NodeText","Data":"因为当前状态只与前一个状态有关 还可以继续优化"}]},{"ID":"20230817161863-m6lpyc0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161863-m6lpyc0","updated":"20230817161863"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Package01 {\n    /*\n    状态定义:f(i，j)代表前i个物品 最大承重为j所获得的的最大价值\n    递推方程:f(i,j)=f(i-1,j),不选择第i个物品\n                  f(i,j-v[i])+w[i],选择第i个物品 那么前i-1个物品最大承重就为j-v[i] 所获得的价值加上w[i]\n     */\n    static int []vi=new int[105];\n    static int []wi=new int[105];\n    static  int[]dp=new int[10005];\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int V = sc.nextInt();\n         int n=sc.nextInt();\n         for(int i=1;i\u003c=n;i++){\n             vi[i]=sc.nextInt();\n             wi[i]=sc.nextInt();\n         }\n         for(int i=1;i\u003c=n;i++){\n             for(int j=V;j\u003e=vi[i];j--){//一定要从后往前扫描 因为 dp[j]依赖于dp[i-vi] 所以当扫描到j时 i位置的原始数据不能变  而本层for循环就是对上一版代码进行了优化 如果j\u003cv[i]相当于什么都不做 dp[j]还是原来那个dp[j]对应上一版的  dp[ind][j]=dp[preind][j]; 如果 j\u003e=v[i]就证明当前所提供的背包容积 大于所选择的背包容积 此时就可以更新最大值 即dp[j]\n                 dp[j]=Math.max(dp[j],dp[j-vi[i]]+wi[i]);\n             }\n         }\n        System.out.println(dp[V]);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161864-yo9g4ek","Type":"NodeParagraph","Properties":{"id":"20230817161864-yo9g4ek","updated":"20230817161864"},"Children":[{"Type":"NodeText","Data":"更上题类似 LC416分割等和子集也是同样的优化思路"}]},{"ID":"20230817161865-q3lhe0g","Type":"NodeParagraph","Properties":{"id":"20230817161865-q3lhe0g","updated":"20230817161865"},"Children":[{"Type":"NodeText","Data":"问题描述：给你一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"只包含正整数"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"非空"},{"Type":"NodeText","Data":" 数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。"}]},{"ID":"20230817161866-jtj4014","Type":"NodeParagraph","Properties":{"id":"20230817161866-jtj4014","updated":"20230817161866"},"Children":[{"Type":"NodeText","Data":"本体的f(i,j)定义为前i个数能否凑成 j大小 跟01背包类似 01背包要求在最多容积情况下选择所给目标的数组 使得最优 而本题只是从所给目标数组中选出值来使满足条件"}]},{"ID":"20230817161867-zpzyypj","Type":"NodeParagraph","Properties":{"id":"20230817161867-zpzyypj","updated":"20230817161867"},"Children":[{"Type":"NodeText","Data":"f(i,j)=f(i-1,j)||f(i-1,j-nums[i])递推公式中j满足j\u003e=nums[i] 而这种问题本质其实是枚举了0~target所有的可能性"}]},{"ID":"20230817161868-l6utwus","Type":"NodeParagraph","Properties":{"id":"20230817161868-l6utwus","updated":"20230817161868"},"Children":[{"Type":"NodeText","Data":"优化前："}]},{"ID":"20230817161869-f74n4nr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161869-f74n4nr","updated":"20230817161869"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public boolean canPartition(int[] nums) {\n      int n=nums.length;\n      int sum=0;\n      for(int i=0;i\u003cn;i++){\n        sum+=nums[i];\n      }\n      if((sum\u00261)==1)return false;\n      boolean [][]dp=new boolean[2][sum/2+1];\n      if(nums[0]\u003c=sum/2)dp[0][nums[0]]=true;//初始化\n      for(int i=1;i\u003cn;i++){\n        int ind=i%2;\n        int preind=1-ind;\n       if(nums[i]\u003c=sum/2) dp[ind][nums[i]]=true;\n        for(int j=0;j\u003c=sum/2;j++){\n       if(j\u003e=nums[i])dp[ind][j]=dp[preind][j]||dp[preind][j-nums[i]];\n       else dp[ind][j]=dp[preind][j];\n        }\n      }\n      return dp[(n-1)%2][sum/2];\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161870-7u9qptk","Type":"NodeParagraph","Properties":{"id":"20230817161870-7u9qptk","updated":"20230817161870"},"Children":[{"Type":"NodeText","Data":"优化后："}]},{"ID":"20230817161871-8imw8rx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161871-8imw8rx","updated":"20230817161871"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public boolean canPartition(int[] nums) {\n        int sum=0;  //dp[i]代表是否可以到达i  此时的i称为可到达状态\n        int n=nums.length;\n        for(int i=0;i\u003cn;i++){\n          sum+=nums[i];\n        }\n        if(sum%2==1)return false;\n        boolean []dp=new boolean[sum/2+1]; \n        dp[0]=true;\n        for(int x:nums){\n           for(int j=sum/2;j\u003e=x;j--){\n             dp[j]|=dp[j-x];\n           }\n        }\n        return dp[sum/2];\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161872-2c1orub","Type":"NodeParagraph","Properties":{"id":"20230817161872-2c1orub","updated":"20230817161872"},"Children":[{"Type":"NodeText","Data":"LC120三角形的最小路径和："}]},{"ID":"20230817161873-u24f56j","Type":"NodeParagraph","Properties":{"id":"20230817161873-u24f56j","updated":"20230817161873"},"Children":[{"Type":"NodeText","Data":"给定一个三角形 triangle ，找出自顶向下的最小路径和。"}]},{"ID":"20230817161874-jj4rg5d","Type":"NodeParagraph","Properties":{"id":"20230817161874-jj4rg5d","updated":"20230817161874"},"Children":[{"Type":"NodeText","Data":"每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。"}]},{"ID":"20230817161875-e682ph5","Type":"NodeParagraph","Properties":{"id":"20230817161875-e682ph5","updated":"20230817161875"},"Children":[{"Type":"NodeText","Data":"思路：本题是一个动规的经典题 可以采用自上而下的动规 也可以采用自下而上的动规 本题我们采用自下而上的动规可以省去边界条件的判断"}]},{"ID":"20230817161876-pe1nuaa","Type":"NodeParagraph","Properties":{"id":"20230817161876-pe1nuaa","updated":"20230817161876"},"Children":[{"Type":"NodeText","Data":"动规四部曲：1、f(i,j)代表从底边走到（i,j）这个点所能获得的最小值"}]},{"ID":"20230817161877-juoqli2","Type":"NodeParagraph","Properties":{"id":"20230817161877-juoqli2","updated":"20230817161877"},"Children":[{"Type":"NodeText","Data":"2、递推公式 ：f(i,j)=max(f(i+1,j),f(i+1,j+1))+val(i,j)"}]},{"ID":"20230817161878-6pmz7kj","Type":"NodeParagraph","Properties":{"id":"20230817161878-6pmz7kj","updated":"20230817161878"},"Children":[{"Type":"NodeText","Data":"因为本题的f(i)的状态只与f(i-1)有关 因此可以采用滚动数组的思想来减少空间复杂度"}]},{"ID":"20230817161879-lg9ronw","Type":"NodeParagraph","Properties":{"id":"20230817161879-lg9ronw","updated":"20230817161879"},"Children":[{"Type":"NodeText","Data":"代码实现："}]},{"ID":"20230817161880-vh3eodq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161880-vh3eodq","updated":"20230817161880"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int minimumTotal(List\u003cList\u003cInteger\u003e\u003e triangle) {\n       int n=triangle.size();\n       int [][]dp=new int[2][n];//滚动数组 让不同的行映射到0 1两行下 \n       for(int i=0;i\u003cn;i++){\n         dp[(n-1)%2][i]=triangle.get(n-1).get(i);\n       }\n       for(int i=n-2;i\u003e=0;i--){\n         int ind=i%2;//当前行\n         int next_ind=1-ind;//下一行\n         for(int j=0;j\u003c=i;j++){\n           dp[ind][j]=Math.min(dp[next_ind][j],dp[next_ind][j+1])+triangle.get(i).get(j);\n         }\n       }\n       return dp[0][0];\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161881-917ed1v","Type":"NodeParagraph","Properties":{"id":"20230817161881-917ed1v","updated":"20230817161881"},"Children":[{"Type":"NodeText","Data":"LC256："}]},{"ID":"20230817161882-mkyx8n0","Type":"NodeParagraph","Properties":{"id":"20230817161882-mkyx8n0","updated":"20230817161882"},"Children":[{"Type":"NodeText","Data":"假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。"}]},{"ID":"20230817161883-sn4kf6f","Type":"NodeParagraph","Properties":{"id":"20230817161883-sn4kf6f","updated":"20230817161883"},"Children":[{"Type":"NodeText","Data":"当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。"}]},{"ID":"20230817161884-8r5vvzo","Type":"NodeParagraph","Properties":{"id":"20230817161884-8r5vvzo","updated":"20230817161884"},"Children":[{"Type":"NodeText","Data":"例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。"}]},{"ID":"20230817161885-xpis99o","Type":"NodeParagraph","Properties":{"id":"20230817161885-xpis99o","updated":"20230817161885"},"Children":[{"Type":"NodeText","Data":"请计算出粉刷完所有房子最少的花费成本。"}]},{"ID":"20230817161886-j53b0tg","Type":"NodeParagraph","Properties":{"id":"20230817161886-j53b0tg","updated":"20230817161886"},"Children":[{"Type":"NodeText","Data":"f(i,j)表示第i个房子涂第j种颜色的最少花费"}]},{"ID":"20230817161887-zp9bluj","Type":"NodeParagraph","Properties":{"id":"20230817161887-zp9bluj","updated":"20230817161887"},"Children":[{"Type":"NodeText","Data":"f(i,j)=min(f(i-1,k),k!=j)"}]},{"ID":"20230817161888-bz8tlna","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161888-bz8tlna","updated":"20230817161888"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int minCost(int[][] costs) {\n      int n=costs.length;\n      int[][]dp=new int[2][3];\n      for(int i=0;i\u003c3;i++){//本题同样采用了滚动数组的思想\n        dp[0][i]=costs[0][i];\n      }\n      for(int i=1;i\u003cn;i++){\n        int ind=i%2;\n        int pre_ind=1-ind;\n        dp[ind][0]=Math.min(dp[pre_ind][2],dp[pre_ind][1])+costs[i][0];\n        dp[ind][1]=Math.min(dp[pre_ind][2],dp[pre_ind][0])+costs[i][1];\n        dp[ind][2]=Math.min(dp[pre_ind][0],dp[pre_ind][1])+costs[i][2];\n      }\n      int end=(n-1)%2;\n      return Math.min(dp[end][0],Math.min(dp[end][1],dp[end][2]));\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161889-02atbi8","Type":"NodeParagraph","Properties":{"id":"20230817161889-02atbi8","updated":"20230817161889"},"Children":[{"Type":"NodeText","Data":"LC198"}]},{"ID":"20230817161890-hsynbpu","Type":"NodeParagraph","Properties":{"id":"20230817161890-hsynbpu","updated":"20230817161890"},"Children":[{"Type":"NodeText","Data":"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。"}]},{"ID":"20230817161891-anhqrdt","Type":"NodeParagraph","Properties":{"id":"20230817161891-anhqrdt","updated":"20230817161891"},"Children":[{"Type":"NodeText","Data":"给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。"}]},{"ID":"20230817161892-wvzd7qp","Type":"NodeParagraph","Properties":{"id":"20230817161892-wvzd7qp","updated":"20230817161892"},"Children":[{"Type":"NodeText","Data":"用 dp(i)表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程："}]},{"ID":"20230817161893-lrzni8h","Type":"NodeParagraph","Properties":{"id":"20230817161893-lrzni8h","updated":"20230817161893"},"Children":[{"Type":"NodeText","Data":"dp(i)=max(dp(i-2)+nums[i],dp(i-1))"}]},{"ID":"20230817161894-4bfrmvt","Type":"NodeParagraph","Properties":{"id":"20230817161894-4bfrmvt","updated":"20230817161894"},"Children":[{"Type":"NodeText","Data":"dp[0]=nums[0] dp[1]=max(nums[0],nums[1])"}]},{"ID":"20230817161895-5d12eu5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161895-5d12eu5","updated":"20230817161895"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int rob(int[] nums) {\n      int n=nums.length;\n      if(n==1)return nums[0];\n      if(n==2)return Math.max(nums[0],nums[1]);\n      int preyesd=nums[0];\n      int yesd=Math.max(nums[0],nums[1]);\n      int temp=0;\n      for(int i=2;i\u003cn;i++){\n       temp=Math.max(preyesd+nums[i],yesd);\n        preyesd=yesd;\n        yesd=temp;\n      }\n      return yesd;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161896-6tcqhys","Type":"NodeParagraph","Properties":{"id":"20230817161896-6tcqhys","updated":"20230817161896"},"Children":[{"Type":"NodeText","Data":"LC53："}]},{"ID":"20230817161897-3a2prms","Type":"NodeParagraph","Properties":{"id":"20230817161897-3a2prms","updated":"20230817161897"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。"}]},{"ID":"20230817161898-9ab85ot","Type":"NodeParagraph","Properties":{"id":"20230817161898-9ab85ot","updated":"20230817161898"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"子数组"},{"Type":"NodeText","Data":" 是数组中的一个连续部分。"}]},{"ID":"20230817161899-dnch68a","Type":"NodeParagraph","Properties":{"id":"20230817161899-dnch68a","updated":"20230817161899"},"Children":[{"Type":"NodeText","Data":"f(i)代表以i下标结尾的最大子数组和"}]},{"ID":"20230817161900-j7t05s8","Type":"NodeParagraph","Properties":{"id":"20230817161900-j7t05s8","updated":"20230817161900"},"Children":[{"Type":"NodeText","Data":"f(i)=max(f(i-1)+nums[i],nums[i]) 最终的答案是在所有的f(i)中求一个最大值"}]},{"ID":"20230817161901-sm1ra9z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161901-sm1ra9z","updated":"20230817161901"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int maxSubArray(int[] nums) {\n       int maxpre=0;//f[n]=max(f[n-1]+nums[i],nums[i]);//因为前一个只有一个值 所以用个数记录一下即可 思想还是滚动数组\n       int n=nums.length;\n       int ans=Integer.MIN_VALUE;\n       for(int i=0;i\u003cn;i++){\n         maxpre=Math.max(maxpre+nums[i],nums[i]);\n         ans=Math.max(ans,maxpre);\n       } \n       return ans;\n       }\n   }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161902-rrm8q9k","Type":"NodeParagraph","Properties":{"id":"20230817161902-rrm8q9k","updated":"20230817161902"},"Children":[{"Type":"NodeText","Data":"LC 152(和上题类似)"}]},{"ID":"20230817161903-n9je4i7","Type":"NodeParagraph","Properties":{"id":"20230817161903-n9je4i7","updated":"20230817161903"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。"}]},{"ID":"20230817161904-ckem05h","Type":"NodeParagraph","Properties":{"id":"20230817161904-ckem05h","updated":"20230817161904"},"Children":[{"Type":"NodeText","Data":"测试用例的答案是一个 32-位 整数。"}]},{"ID":"20230817161905-ktasu1e","Type":"NodeParagraph","Properties":{"id":"20230817161905-ktasu1e","updated":"20230817161905"},"Children":[{"Type":"NodeText","Data":"子数组 是数组的连续子序列。"}]},{"ID":"20230817161906-3uobdcv","Type":"NodeParagraph","Properties":{"id":"20230817161906-3uobdcv","updated":"20230817161906"},"Children":[{"Type":"NodeText","Data":"f(i)代表以i下标结尾的最大乘积和 本题因为有负数的存在所以要记录以i结尾的一个最大值和最小值 以便遇到负数时的求解"}]},{"ID":"20230817161907-rlbpfgv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161907-rlbpfgv","updated":"20230817161907"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int maxProduct(int[] nums) {//和53题是一个类型的题 但是这个题要维护最大和最小两个值 因为有负数的存在\n      int n=nums.length;\n      int premax=1;\n      int premin=1;\n      int ans=Integer.MIN_VALUE;;\n      for(int i=0;i\u003cn;i++){\n         if(nums[i]\u003c0){//交换最大值和最小值很秒\n           int temp=premax;\n           premax=premin;\n           premin=temp;\n        }\n        premax=Math.max(premax*nums[i],nums[i]);\n        premin=Math.min(premin*nums[i],nums[i]);\n        ans=Math.max(ans,premax);\n      }\n      return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161908-dawx2mb","Type":"NodeParagraph","Properties":{"id":"20230817161908-dawx2mb","updated":"20230817161908"},"Children":[{"Type":"NodeText","Data":"LC322 零钱兑换"}]},{"ID":"20230817161909-aghgnxp","Type":"NodeParagraph","Properties":{"id":"20230817161909-aghgnxp","updated":"20230817161909"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。"}]},{"ID":"20230817161910-m90ajhs","Type":"NodeParagraph","Properties":{"id":"20230817161910-m90ajhs","updated":"20230817161910"},"Children":[{"Type":"NodeText","Data":"计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。"}]},{"ID":"20230817161911-rpewsa5","Type":"NodeParagraph","Properties":{"id":"20230817161911-rpewsa5","updated":"20230817161911"},"Children":[{"Type":"NodeText","Data":"你可以认为每种硬币的数量是无限的。"}]},{"ID":"20230817161912-z2pdzp2","Type":"NodeParagraph","Properties":{"id":"20230817161912-z2pdzp2","updated":"20230817161912"},"Children":[{"Type":"NodeText","Data":"f(n)代表凑成n这个面额所需要的最少硬币数"}]},{"ID":"20230817161913-9eue0i8","Type":"NodeParagraph","Properties":{"id":"20230817161913-9eue0i8","updated":"20230817161913"},"Children":[{"Type":"NodeText","Data":"f(n)=min(f(n-ci)+1)其中这个ci是coins数组中的值"}]},{"ID":"20230817161914-rcbfds5","Type":"NodeParagraph","Properties":{"id":"20230817161914-rcbfds5","updated":"20230817161914"},"Children":[{"Type":"NodeText","Data":"代码："}]},{"ID":"20230817161915-c269tmw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161915-c269tmw","updated":"20230817161915"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        int []dp=new int[amount+1]; //F[n]的定义是以n作为需要凑成的目标所需要的最少硬币个数\n        Arrays.fill(dp,amount+1); //F[n]=min(F[n-Ci])+1 ci为题中数组中所包含的硬币面额\n        dp[0]=0;//初始状态 凑成0这个面额所需要的硬币数量为0\n      for(int i=1;i\u003c=amount;i++){\n        for(int j=0;j\u003ccoins.length;j++){\n          if(coins[j]\u003c=i){//枚举的面额需要小于当前以i作为需要凑成的目标状态下的面额 比如我只需要凑10 你的面额却是20 当然就不需要了\n            dp[i]=Math.min(dp[i],dp[i-coins[j]]+1);\n          }\n        }\n      }\n     return dp[amount]==amount+1? -1:dp[amount];\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161916-tk5keac","Type":"NodeParagraph","Properties":{"id":"20230817161916-tk5keac","updated":"20230817161916"},"Children":[{"Type":"NodeText","Data":"LC 300 最长递增子序列"}]},{"ID":"20230817161917-jbfx6cc","Type":"NodeParagraph","Properties":{"id":"20230817161917-jbfx6cc","updated":"20230817161917"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。"}]},{"ID":"20230817161918-21ofx27","Type":"NodeParagraph","Properties":{"id":"20230817161918-21ofx27","updated":"20230817161918"},"Children":[{"Type":"NodeText","Data":"子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。"}]},{"ID":"20230817161919-t4zbyu8","Type":"NodeParagraph","Properties":{"id":"20230817161919-t4zbyu8","updated":"20230817161919"},"Children":[{"Type":"NodeText","Data":"f(i)代表以i坐标作为结尾的最大递增子序列长度"}]},{"ID":"20230817161920-niututo","Type":"NodeParagraph","Properties":{"id":"20230817161920-niututo","updated":"20230817161920"},"Children":[{"Type":"NodeText","Data":"f(i)=max(f(j),j\u003ci\u0026\u0026f(j)\u003cf(i))"}]},{"ID":"20230817161921-nq1wpw3","Type":"NodeParagraph","Properties":{"id":"20230817161921-nq1wpw3","updated":"20230817161921"},"Children":[{"Type":"NodeText","Data":"代码："}]},{"ID":"20230817161922-zy1cslg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161922-zy1cslg","updated":"20230817161922"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n      if(nums.length==0)return 0;\n     int []dp=new int[nums.length];//dp[i]代表以i下标作为结尾的的最大子序列的长度\n                   //状态转移方程:dp[i]=max(dp[j]+1) j\u003ci\u0026\u0026dp[j]\u003cdp[i]\n     int ans=Integer.MIN_VALUE;\n    for(int i=0;i\u003cnums.length;i++){\n       dp[i]=1;//dp初始化为1 表示一当前坐标作为结尾的最小长度为1 即他本身\n       for(int j=0;j\u003ci;j++){\n         if(nums[j]\u003cnums[i]){\n           dp[i]=Math.max(dp[i],dp[j]+1);\n         }\n       }\n       ans=Math.max(dp[i],ans);\n    }\n    return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161923-orsm9bg","Type":"NodeParagraph","Properties":{"id":"20230817161923-orsm9bg","updated":"20230817161923"},"Children":[{"Type":"NodeText","Data":"剑指offerII095："}]},{"ID":"20230817161924-h2pe4vw","Type":"NodeParagraph","Properties":{"id":"20230817161924-h2pe4vw","updated":"20230817161924"},"Children":[{"Type":"NodeText","Data":"给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。"}]},{"ID":"20230817161925-5flln6t","Type":"NodeParagraph","Properties":{"id":"20230817161925-5flln6t","updated":"20230817161925"},"Children":[{"Type":"NodeText","Data":"一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。"}]},{"ID":"20230817161926-h52tkxs","Type":"NodeParagraph","Properties":{"id":"20230817161926-h52tkxs","updated":"20230817161926"},"Children":[{"Type":"NodeText","Data":"例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。"}]},{"ID":"20230817161927-fbs38kq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161927-fbs38kq","updated":"20230817161927"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n  /* 状态定义:dp[i][j]代表text1取前i位 text2前j位 的最长公共子序列的长度\n  状态转移方程:dp[i][j]={\n     max(dp[i-1][j],dp[i][j-1]) text1[i]!=text2[j]\n     dp[i-1][j-1]+1  text1[i]==text2[j]\n     */\n   int n=text1.length();\n   int m=text2.length();\n   int [][]dp=new int[n+1][m+1];//初始化时都为0 因为两个字符串的最长公共子串的最少数量为0\n    for(int i=1;i\u003c=n;i++){\n      for(int j=1;j\u003c=m;j++)\n       if(text1.charAt(i-1)==text2.charAt(j-1)){\n            dp[i][j]=dp[i-1][j-1]+1;\n       }else{\n         dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n       }\n    }\n      return dp[n][m];\n }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161928-rhydpca","Type":"NodeParagraph","Properties":{"id":"20230817161928-rhydpca","updated":"20230817161928"},"Children":[{"Type":"NodeText","Data":"LC 132分割回文串"}]},{"ID":"20230817161929-pw3fgxu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161929-pw3fgxu","updated":"20230817161929"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int minCut(String s) {\n     int n=s.length();\n     boolean [][] g=new boolean[n][n];\n     for(int i=0;i\u003cn;i++){\n         Arrays.fill(g[i],true);\n     }\n     for(int i=n-1;i\u003e=0;i--){\n         for(int j=i+1;j\u003cn;j++){\n             g[i][j]=s.charAt(i)==s.charAt(j)\u0026\u0026g[i+1][j-1];\n         }\n     }\n     int []dp=new int[n];\n     Arrays.fill(dp,Integer.MAX_VALUE);\n     for(int i=0;i\u003cn;i++){\n        if(g[0][i]){\n            dp[i]=1;\n            continue;\n        }\n         for(int j=0;j\u003ci;j++){\n             if(g[j+1][i])dp[i]=Math.min(dp[i],dp[j]+1);\n         }\n     }\n     return dp[n-1]-1;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}