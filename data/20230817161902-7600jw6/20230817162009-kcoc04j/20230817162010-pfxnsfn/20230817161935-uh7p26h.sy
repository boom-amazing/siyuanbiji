{"ID":"20230817161935-uh7p26h","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161935-uh7p26h","title":"哈希表的实现以及经典运用场景","updated":"20230817161935"},"Children":[{"ID":"20230817161936-d7r741l","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161936-d7r741l","updated":"20230817161936"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"哈希表"}]},{"ID":"20230817161937-hd0a03a","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161937-hd0a03a","updated":"20230817161937"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"一 哈希函数的设计"}]},{"ID":"20230817161938-p5reu3x","Type":"NodeParagraph","Properties":{"id":"20230817161938-p5reu3x","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"不同场景有不同的设计方法，将不同对象映射成数据下标"}]},{"ID":"20230817161939-vs95n0a","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161939-vs95n0a","updated":"20230817161939"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"二 解决哈希冲突的方法"}]},{"ID":"20230817161940-uoe1oxg","Type":"NodeParagraph","Properties":{"id":"20230817161940-uoe1oxg","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"1、开放寻址法：当遇到冲突后 通过一种计算规则找到下一个不产生冲突规则的位置"}]},{"ID":"20230817161941-r0pj04n","Type":"NodeParagraph","Properties":{"id":"20230817161941-r0pj04n","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"计算规则常见的有线性探测、二次探测法、二次哈希法"}]},{"ID":"20230817161942-oyhor4h","Type":"NodeParagraph","Properties":{"id":"20230817161942-oyhor4h","updated":"20230817161942"},"Children":[{"Type":"NodeText","Data":"利用二次探测法简单实现一个字符哈希表："}]},{"ID":"20230817161943-xq4lurm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161943-xq4lurm","updated":"20230817161943"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class HashTable_ {\n    public static void main(String[] args) {\n        HashTable_ hashTable_ = new HashTable_();\n        hashTable_.insert(\"pyy\");\n        hashTable_.insert(\"i love\");\n        hashTable_.insert(\"zx\");\n        System.out.println( hashTable_.find(\"pyy\"));//true\n        System.out.println(hashTable_.find(\"lr\"));//false\n    }\n    private int cnt;\n    private String[] data;\n    private int[] flag;//1代表存数据 0代表没有存数据\n\n    public HashTable_() {\n        this.cnt = 0;\n        this.data = new String[100];\n        this.flag = new int[100];\n    }\n\n    public void insert(String s) {\n        int hash = hash(s);\n        int idx = hash % data.length;\n        recal_hash(idx, s);\n        data[idx] = s;\n        flag[idx]=1;\n    }\n\n    public boolean find(String s) {\n        int hash = hash(s);\n        int idx = hash % data.length;\n        recal_hash(idx, s);\n        return flag[idx]==1;\n    }\n\n    public int hash(String s) {//字符的一种哈希算法 BKDRHASH\n        int seed = 131, hash = 0;\n        for (int i = 0; i \u003c s.length(); i++) {\n            hash = hash * seed + s.charAt(i);\n        }\n        return hash \u0026 0x7fffffff;//如果是负数 将其转成一个正数\n    }\n\n    public void recal_hash(int idx, String s) {\n        int t=1;\n        while (flag[idx] == 1 \u0026\u0026 data[idx].equals(s)){\n            idx+=t*t;\n            t+=1;\n            idx%=data.length;\n        }\n        return;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161944-tbw297j","Type":"NodeParagraph","Properties":{"id":"20230817161944-tbw297j","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"2、公共溢出区：将哈希冲突的元素 用另外一个公共溢出区解决，如用红黑树"}]},{"ID":"20230817161945-p5fkirx","Type":"NodeParagraph","Properties":{"id":"20230817161945-p5fkirx","updated":"20230817161945"},"Children":[{"Type":"NodeText","Data":"3、拉链法(常用) ：就是数组加链表 每个数组下标存储的是链表的头结点"}]},{"ID":"20230817161946-r89ldk0","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161946-r89ldk0","updated":"20230817161946"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"三、扩容(出了点bug)"}]},{"ID":"20230817161947-mhvotpn","Type":"NodeParagraph","Properties":{"id":"20230817161947-mhvotpn","updated":"20230817161947"},"Children":[{"Type":"NodeText","Data":"当哈希表里面的元素已经超过了装载因子*哈希表大小时 我们就进行动态扩容"}]},{"ID":"20230817161948-4ay5ygl","Type":"NodeParagraph","Properties":{"id":"20230817161948-4ay5ygl","updated":"20230817161948"},"Children":[{"Type":"NodeText","Data":"扩容代码："}]},{"ID":"20230817161949-hqr6pcs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161949-hqr6pcs","updated":"20230817161949"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161950-2g0ti3v","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161950-2g0ti3v","updated":"20230817161950"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"常见集合的实现"}]},{"ID":"20230817161951-3ub8v91","Type":"NodeParagraph","Properties":{"id":"20230817161951-3ub8v91","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"hashset："}]},{"ID":"20230817161952-3ctei2h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161952-3ctei2h","updated":"20230817161952"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class MyHashSet {\n    Node [] arr;\n    public MyHashSet() {\n      arr=new Node[100];\n      for(int i=0;i\u003carr.length;i++){\n        arr[i]=new Node(0,null);\n      }\n      \n    }\n    public int hash(int key){\n      return key\u00260x7fffffff;\n    }\n    public void add(int key) {\n      if(contains(key))return;\n      int ind=hash(key)%arr.length;\n      Node node=arr[ind];\n      while(node.next!=null)node=node.next;\n      node.insert_next(new Node(key));\n      return;\n\n    }\n    \n    public void remove(int key) {\n       if(!contains(key))return;\n      int ind=hash(key)%arr.length;\n      Node node=arr[ind];\n      while(node.next!=null\u0026\u0026node.next.key!=key)node=node.next;\n      node.remove_next();\n      return;\n    }\n    \n    public boolean contains(int key) {\n       int ind=hash(key)%arr.length;\n       Node node=arr[ind].next;\n       while(node!=null\u0026\u0026node.key!=key)node=node.next;\n       return node!=null;\n    }\n}\nclass Node{\n  int key;\n  Node next;\n  public Node(int key){\n    this.key=key;\n  }\n  public Node (int key,Node next){\n    this.key=key;\n    this.next=next;\n    \n  }\n public void remove_next(){\n   this.next=this.next.next;\n }\n public void insert_next(Node node){\n   node.next=this.next;\n   this.next=node; \n }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161953-aoy2zop","Type":"NodeParagraph","Properties":{"id":"20230817161953-aoy2zop","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"hashmap："}]},{"ID":"20230817161954-4bahvx8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161954-4bahvx8","updated":"20230817161954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class MyHashMap {\n    Node []arr;\n    public MyHashMap() {\n       arr=new Node[100];\n       for(int i=0;i\u003c100;i++){\n         arr[i]=new Node(0,0,null);\n       }\n    }\n    public int hash(int key){\n      return key\u00260x7fffffff;\n    }\n    public void put(int key, int value) {\n      int ind=hash(key)%arr.length;\n      Node node=arr[ind];\n      while(node.next!=null\u0026\u0026node.next.key!=key)node=node.next;\n      if(node.next==null){\n        node.insert_next(new Node(key,value));\n      }else{\n        node.next.value=value;\n      }\n      return;\n    }\n    \n    public int get(int key) {\n     int ind=hash(key)%arr.length;\n      Node node=arr[ind].next;\n      while(node!=null\u0026\u0026node.key!=key)node=node.next;\n      if(node==null)return -1;\n      else return node.value;\n    }\n    \n    public void remove(int key) {\n    int ind=hash(key)%arr.length;\n      Node node=arr[ind];\n      while(node.next!=null\u0026\u0026node.next.key!=key)node=node.next;\n      if(node.next==null)return;\n      node.remove_next();\n      return;\n    }\n}\nclass Node{\n  int key;\n  int value;\n  Node next;\n  public Node(int key,int value){\n    this.key=key;\n    this.value=value;\n  }\n  public Node (int key,int value,Node next){\n    this.key=key;\n    this.next=next;\n    this.value=value;\n    \n  }\n public void remove_next(){\n   this.next=this.next.next;\n }\n public void insert_next(Node node){\n   node.next=this.next;\n   this.next=node; \n }\n\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap obj = new MyHashMap();\n * obj.put(key,value);\n * int param_2 = obj.get(key);\n * obj.remove(key);\n */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161955-3aiif9g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161955-3aiif9g","updated":"20230817161955"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"经典算法的实现"}]},{"ID":"20230817161956-z7brr3g","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161956-z7brr3g","updated":"20230817161956"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"LRU缓存算法：利用哈希表加双向链表(手动封装)"}]},{"ID":"20230817161957-55wn40r","Type":"NodeParagraph","Properties":{"id":"20230817161957-55wn40r","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"代码："}]},{"ID":"20230817161958-ort3dhn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161958-ort3dhn","updated":"20230817161958"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class LRUCache {\n    Node head;\n    Node tail;\n    int capacity;\n    HashMap\u003cInteger,Node\u003e h;\n    public LRUCache(int capacity) {\n       head=new Node(0,0);\n       tail=new Node(0,0);\n       head.next=tail;\n       tail.prev=head;\n      this.capacity=capacity;\n      h=new HashMap();\n    }\n    \n    public int get(int key) {\n      if(!h.containsKey(key))return -1;\n      Node node= h.get(key);\n      node.remove_this();\n      tail.insert_prev(node);\n      return node.value;\n    }\n    \n    public void put(int key, int value) {\n      if(h.containsKey(key)){\n       Node node= h.get(key);\n       node.remove_this();\n       node.value=value;\n       tail.insert_prev(node);\n      }else{\n       Node newnode=new Node(key,value);\n       h.put(key,newnode);\n       tail.insert_prev(newnode);\n      }\n      if(h.size()\u003ecapacity){\n        Node headnode=head.next;\n        h.remove(headnode.key);\n        headnode.remove_this();\n      }\n    }\n}\nclass Node{\n  int key;\n  int value;\n  Node next;\n  Node prev;\n  public Node (int key,int value){\n    this.key=key;\n    this.value=value;\n  }\n  public void insert_prev(Node node){\n      node.next=this;\n      node.prev=this.prev;\n      if(this.prev!=null)this.prev.next=node;\n      this.prev=node;\n  }\n  public void  remove_this(){\n    if(this.prev!=null)this.prev.next=this.next;\n    if(this.next!=null)this.next.prev=this.prev;//这里有问题\n  }\n\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161959-rdfzig5","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161959-rdfzig5","updated":"20230817161959"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"位运算(运用的其实就是哈希思想)"}]},{"ID":"20230817161960-1gslfz1","Type":"NodeParagraph","Properties":{"id":"20230817161960-1gslfz1","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"问题：给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。"}]},{"ID":"20230817161961-n05jtqb","Type":"NodeParagraph","Properties":{"id":"20230817161961-n05jtqb","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"代码块："}]},{"ID":"20230817161962-7qnjumh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161962-7qnjumh","updated":"20230817161962"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public int maxProduct(String[] words) {\n       int[] mark=new int[words.length];\n        for (int i = 0; i \u003c words.length; i++) {\n            for (int j = 0; j \u003c words[i].length(); j++) {\n               mark[i]|= (1\u003c\u003c(words[i].charAt(j)-'a'));//位运算的思想类似于哈希思想\n            }\n        }\n        int ans=0;\n        for (int i = 0; i \u003c words.length;i++){\n            for (int j = i+1; j \u003cwords.length ; j++) {\n                if((mark[i]\u0026mark[j])==0)ans=Math.max(ans,(words[i].length())*(words[j].length()));\n            }\n        }\n        return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161963-smwuldc","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161963-smwuldc","updated":"20230817161963"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"哈希计数"}]},{"ID":"20230817161964-hpwv6fn","Type":"NodeParagraph","Properties":{"id":"20230817161964-hpwv6fn","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"问题："}]},{"ID":"20230817161965-e2es3yc","Type":"NodeParagraph","Properties":{"id":"20230817161965-e2es3yc","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如：\"ACGAATTCCG\"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。"}]},{"ID":"20230817161966-5yrovks","Type":"NodeParagraph","Properties":{"id":"20230817161966-5yrovks","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。"}]},{"ID":"20230817161967-9060wlk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161967-9060wlk","updated":"20230817161967"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n  public List\u003cString\u003e findRepeatedDnaSequences(String s) {\n        HashMap\u003cString, Integer\u003e hashMap = new HashMap\u003c\u003e();\n        for (int i = 0; i \u003c s.length() - 9; i++) {\n            String s1=s.substring(i,i+10);\n            hashMap.put(s1,hashMap.getOrDefault(s1,0)+1);\n        }\n        Set\u003cString\u003e strings = hashMap.keySet();\n        List\u003cString\u003e ans = new ArrayList\u003c\u003e();\n        for (String s2 : strings) {\n            if (hashMap.get(s2) \u003e 1) {\n                ans.add(s2);\n            }\n        }\n        return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161968-ex0gqdh","Type":"NodeParagraph","Properties":{"id":"20230817161968-ex0gqdh","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"常见的哈希函数："}]},{"ID":"20230817161969-t96qekm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-t96qekm","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public long hash(PII state) {\n    return ((long) state.x\u003c\u003c31) + state.y;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}