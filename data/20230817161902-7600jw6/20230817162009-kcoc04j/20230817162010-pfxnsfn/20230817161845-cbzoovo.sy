{"ID":"20230817161845-cbzoovo","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161845-cbzoovo","title":"二叉树","updated":"20230817161845"},"Children":[{"ID":"20230817161846-xuby23v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161846-xuby23v","updated":"20230817161846"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"二叉树"}]},{"ID":"20230817161847-qveddwn","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161847-qveddwn","updated":"20230817161847"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"基本性质"}]},{"ID":"20230817161848-y7pyseb","Type":"NodeParagraph","Properties":{"id":"20230817161848-y7pyseb","updated":"20230817161848"},"Children":[{"Type":"NodeText","Data":"1、每个节点的个数最多为2"}]},{"ID":"20230817161849-mfd841y","Type":"NodeParagraph","Properties":{"id":"20230817161849-mfd841y","updated":"20230817161849"},"Children":[{"Type":"NodeText","Data":"2、度为0的节点个数比度为2的节点个数多一个"}]},{"ID":"20230817161850-7ly36w8","Type":"NodeParagraph","Properties":{"id":"20230817161850-7ly36w8","updated":"20230817161850"},"Children":[{"Type":"NodeText","Data":"特殊的二叉树："}]},{"ID":"20230817161851-u09jgch","Type":"NodeParagraph","Properties":{"id":"20230817161851-u09jgch","updated":"20230817161851"},"Children":[{"Type":"NodeText","Data":"1、完全二叉树"}]},{"ID":"20230817161852-ostts80","Type":"NodeParagraph","Properties":{"id":"20230817161852-ostts80","updated":"20230817161852"},"Children":[{"Type":"NodeText","Data":"性质："}]},{"ID":"20230817161853-qe77f06","Type":"NodeParagraph","Properties":{"id":"20230817161853-qe77f06","updated":"20230817161853"},"Children":[{"Type":"NodeText","Data":"编号为i的子节点 ：左孩子编号2"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"i  右孩子编号：2"},{"Type":"NodeText","Data":"i-1"}]},{"ID":"20230817161854-ku9lg59","Type":"NodeParagraph","Properties":{"id":"20230817161854-ku9lg59","updated":"20230817161854"},"Children":[{"Type":"NodeText","Data":"可以用连续空间存储(数组) 这样可以节约大量的地址空间 因为子孩子的地址可以通过计算得到"}]},{"ID":"20230817161855-v7a8xho","Type":"NodeParagraph","Properties":{"id":"20230817161855-v7a8xho","updated":"20230817161855"},"Children":[{"Type":"NodeText","Data":"也就是时间换空间的思想"}]},{"ID":"20230817161856-328g2tb","Type":"NodeParagraph","Properties":{"id":"20230817161856-328g2tb","updated":"20230817161856"},"Children":[{"Type":"NodeText","Data":"2、满二叉树"}]},{"ID":"20230817161857-2x89c4i","Type":"NodeParagraph","Properties":{"id":"20230817161857-2x89c4i","updated":"20230817161857"},"Children":[{"Type":"NodeText","Data":"指所有节点的度为0或者2的个数 每一层节点个数都是满的情况"}]},{"ID":"20230817161858-jitddw1","Type":"NodeParagraph","Properties":{"id":"20230817161858-jitddw1","updated":"20230817161858"},"Children":[{"Type":"NodeText","Data":"3、完美二叉树"}]},{"ID":"20230817161859-1mngitm","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161859-1mngitm","updated":"20230817161859"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"经典例题"}]},{"ID":"20230817161860-7pk1d64","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161860-7pk1d64","updated":"20230817161860"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"遍历问题"}]},{"ID":"20230817161861-2tumkcw","Type":"NodeParagraph","Properties":{"id":"20230817161861-2tumkcw","updated":"20230817161861"},"Children":[{"Type":"NodeText","Data":"先序遍历 中序遍历 后序遍历的非递归写法"}]},{"ID":"20230817161862-1ir4cqg","Type":"NodeParagraph","Properties":{"id":"20230817161862-1ir4cqg","updated":"20230817161862"},"Children":[{"Type":"NodeText","Data":"前序遍历"}]},{"ID":"20230817161863-ifj9b1i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161863-ifj9b1i","updated":"20230817161863"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public List\u003cInteger\u003e preorderTraversal(TreeNode root) {\n       List\u003cInteger\u003e ans=new ArrayList();\n       if(root==null)return ans;\n       Stack\u003cTreeNode\u003e stack=new Stack();\n       stack.push(root);\n       while(!stack.isEmpty()){\n          TreeNode top= stack.pop();\n          ans.add(top.val);\n          if(top.right!=null) stack.push(top.right);\n          if(top.left!=null)stack.push(top.left);\n       }      \n       return ans;\n     }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161864-2bij9oh","Type":"NodeParagraph","Properties":{"id":"20230817161864-2bij9oh","updated":"20230817161864"},"Children":[{"Type":"NodeText","Data":"后序遍历"}]},{"ID":"20230817161865-6hui9uv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161865-6hui9uv","updated":"20230817161865"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public List\u003cInteger\u003e postorderTraversal(TreeNode root) {\n     List\u003cInteger\u003e ans=new ArrayList();\n     Stack\u003cTreeNode\u003estack=new Stack();\n     if(root==null)return ans;\n     stack.push(root);\n     while(!stack.isEmpty()){\n       TreeNode top=stack.pop();\n       ans.add(top.val);\n       if(top.left!=null){\n         stack.push(top.left);\n       }\n       if(top.right!=null){\n         stack.push(top.right);\n       }\n     }\n     Collections.reverse(ans);\n    return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161866-yteadhp","Type":"NodeParagraph","Properties":{"id":"20230817161866-yteadhp","updated":"20230817161866"},"Children":[{"Type":"NodeText","Data":"这两种遍历主要借助于栈"}]},{"ID":"20230817161867-57ic090","Type":"NodeParagraph","Properties":{"id":"20230817161867-57ic090","updated":"20230817161867"},"Children":[{"Type":"NodeText","Data":"中序遍历 不太好理解"}]},{"ID":"20230817161868-q0f4gne","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161868-q0f4gne","updated":"20230817161868"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public List\u003cInteger\u003e inorderTraversal(TreeNode root) {\n       Stack\u003cTreeNode\u003estack= new Stack();\n       List\u003cInteger\u003eans= new ArrayList();\n        while(root!=null||!stack.isEmpty()){\n          while(root!=null){\n            stack.push(root);\n            root=root.left;\n          }//如果root等于空了 说明已经遍历到最左边节点的子空节点 这个时候栈顶元素就是我们需要的左 根右的左 其实更像是左根先进 然后出来的顺序是根左 最后右进 即左跟右\n          TreeNode top=stack.pop();\n          ans.add(top.val);//将他加入\n          root=top.right;//因为还要遍历右 所以也将其加入\n        }\n    return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161869-pr8wob2","Type":"NodeParagraph","Properties":{"id":"20230817161869-pr8wob2","updated":"20230817161869"},"Children":[{"Type":"NodeText","Data":"N叉树："}]},{"ID":"20230817161870-fyewv5g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161870-fyewv5g","updated":"20230817161870"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/","TextMarkTextContent":"559. N 叉树的最大深度"}]},{"ID":"20230817161871-i16j8lf","Type":"NodeParagraph","Properties":{"id":"20230817161871-i16j8lf","updated":"20230817161871"},"Children":[{"Type":"NodeText","Data":"难度简单252"}]},{"ID":"20230817161872-xw7j3ej","Type":"NodeParagraph","Properties":{"id":"20230817161872-xw7j3ej","updated":"20230817161872"},"Children":[{"Type":"NodeText","Data":"给定一个 N 叉树，找到其最大深度。"}]},{"ID":"20230817161873-4ayyuyx","Type":"NodeParagraph","Properties":{"id":"20230817161873-4ayyuyx","updated":"20230817161873"},"Children":[{"Type":"NodeText","Data":"最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。"}]},{"ID":"20230817161874-4yqr853","Type":"NodeParagraph","Properties":{"id":"20230817161874-4yqr853","updated":"20230817161874"},"Children":[{"Type":"NodeText","Data":"N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。"}]},{"ID":"20230817161875-31p8831","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161875-31p8831","updated":"20230817161875"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n      public int dfs(Node root){\n        if(root==null)return 0;\n        List\u003cNode\u003echildren=root.children;\n        int ans=0;\n        for(Node child:children){\n          int deep=dfs(child);\n          ans=Math.max(deep,ans);//这里获得子孩子中的最大深度\n        }\n        return ans+1;//答案最大深度加一\n      }\n    public int maxDepth(Node root) {\n      return  dfs(root);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161876-4rurb6s","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161876-4rurb6s","updated":"20230817161876"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"公共祖先问题："}]},{"ID":"20230817161877-4j1gnqu","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161877-4j1gnqu","updated":"20230817161877"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/","TextMarkTextContent":"剑指 Offer 68 - II. 二叉树的最近公共祖先"}]},{"ID":"20230817161878-42hbn28","Type":"NodeParagraph","Properties":{"id":"20230817161878-42hbn28","updated":"20230817161878"},"Children":[{"Type":"NodeText","Data":"难度简单386"}]},{"ID":"20230817161879-o09wd3f","Type":"NodeParagraph","Properties":{"id":"20230817161879-o09wd3f","updated":"20230817161879"},"Children":[{"Type":"NodeText","Data":"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。"}]},{"ID":"20230817161880-037u6n7","Type":"NodeParagraph","Properties":{"id":"20230817161880-037u6n7","updated":"20230817161880"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin","TextMarkTextContent":"百度百科"},{"Type":"NodeText","Data":"中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一个节点也可以是它自己的祖先"},{"Type":"NodeText","Data":"）。”"}]},{"ID":"20230817161881-a5eimrr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161881-a5eimrr","updated":"20230817161881"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    HashMap\u003cTreeNode,TreeNode\u003e h=new HashMap();\n    Set\u003cTreeNode\u003e set=new HashSet();\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n       dfs(root);\n       h.put(root,null);\n       while(p!=null){\n         set.add(p);\n         p=h.get(p);\n       }\n       while(q!=null){\n         if(set.contains(q))return q;\n         q=h.get(q);\n       }\n       return null;\n    }\n    public void dfs(TreeNode root){\n     if(root.left!=null){\n       h.put(root.left,root);\n       dfs(root.left);\n     }\n     if(root.right!=null){\n       h.put(root.right,root);\n       dfs(root.right);\n     }\n\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161882-xycgl3g","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161882-xycgl3g","updated":"20230817161882"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/","TextMarkTextContent":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"}]},{"ID":"20230817161883-rj92j5i","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161883-rj92j5i","updated":"20230817161883"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}}]},{"ID":"20230817161884-dz6099x","Type":"NodeParagraph","Properties":{"id":"20230817161884-dz6099x","updated":"20230817161884"},"Children":[{"Type":"NodeText","Data":"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。"}]},{"ID":"20230817161885-drubox4","Type":"NodeParagraph","Properties":{"id":"20230817161885-drubox4","updated":"20230817161885"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin","TextMarkTextContent":"百度百科"},{"Type":"NodeText","Data":"中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"一个节点也可以是它自己的祖先"},{"Type":"NodeText","Data":"）。”"}]},{"ID":"20230817161886-tbu6v4a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161886-tbu6v4a","updated":"20230817161886"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root==null)return null;\n        while(true){\n        if(root!=null\u0026\u0026p.val\u003croot.val\u0026\u0026q.val\u003croot.val){\n          root=root.left;\n        }else if(root!=null\u0026\u0026p.val\u003eroot.val\u0026\u0026q.val\u003eroot.val){\n          root=root.right;\n        }else{\n          break;\n        }\n    }\n    return root;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161887-oyw0jqx","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161887-oyw0jqx","updated":"20230817161887"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"建树问题"}]},{"ID":"20230817161888-eec2ui3","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161888-eec2ui3","updated":"20230817161888"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/","TextMarkTextContent":"105. 从前序与中序遍历序列构造二叉树"}]},{"ID":"20230817161889-lqmxa46","Type":"NodeParagraph","Properties":{"id":"20230817161889-lqmxa46","updated":"20230817161889"},"Children":[{"Type":"NodeText","Data":"难度中等1462"}]},{"ID":"20230817161890-t7dt0lt","Type":"NodeParagraph","Properties":{"id":"20230817161890-t7dt0lt","updated":"20230817161890"},"Children":[{"Type":"NodeText","Data":"给定两个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"preorder"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inorder"},{"Type":"NodeText","Data":" ，其中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"preorder"},{"Type":"NodeText","Data":" 是二叉树的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"先序遍历"},{"Type":"NodeText","Data":"， "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"inorder"},{"Type":"NodeText","Data":" 是同一棵树的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"中序遍历"},{"Type":"NodeText","Data":"，请构造二叉树并返回其根节点。"}]},{"ID":"20230817161891-hjon9al","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161891-hjon9al","updated":"20230817161891"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    HashMap\u003cInteger,Integer\u003e h=new HashMap();\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        for(int i=0;i\u003cinorder.length;i++){\n          h.put(inorder[i],i);\n        }\n        int n=preorder.length;\n      return  build(preorder,inorder,0,n-1,0,n-1);\n    }\n    public TreeNode build(int []preorder,int []inorder,int l1,int r1,int l2,int r2){\n       if(l1\u003er1)return null;\n       int value=preorder[l1];\n       int ind=h.get(value);\n       int size=ind-l2;\n       TreeNode root=new TreeNode(value);\n       root.left=build(preorder,inorder,l1+1,l1+size,l2,size-1);\n       root.right=build(preorder,inorder,l1+size+1,r1,ind+1,r2);\n       return root;\n\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161892-srr7232","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161892-srr7232","updated":"20230817161892"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/maximum-width-of-binary-tree/","TextMarkTextContent":"662. 二叉树最大宽度"}]},{"ID":"20230817161893-0g6mjqn","Type":"NodeParagraph","Properties":{"id":"20230817161893-0g6mjqn","updated":"20230817161893"},"Children":[{"Type":"NodeText","Data":"难度中等313"}]},{"ID":"20230817161894-aclceey","Type":"NodeParagraph","Properties":{"id":"20230817161894-aclceey","updated":"20230817161894"},"Children":[{"Type":"NodeText","Data":"给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"满二叉树（full binary tree）"},{"Type":"NodeText","Data":"结构相同，但一些节点为空。"}]},{"ID":"20230817161895-eqy0d0z","Type":"NodeParagraph","Properties":{"id":"20230817161895-eqy0d0z","updated":"20230817161895"},"Children":[{"Type":"NodeText","Data":"每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"节点也计入长度）之间的长度。"}]},{"ID":"20230817161896-9tlslvp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161896-9tlslvp","updated":"20230817161896"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n  //求最大宽度可以给每个节点标个号 再利用层序遍历来进行求解\n    public int widthOfBinaryTree(TreeNode root) {\n       LinkedList\u003cIndexNode\u003e list=new LinkedList();\n       list.offer(new IndexNode(root,1));\n       int ans=0;\n       while(!list.isEmpty()){\n         int size=list.size();\n          int l=0,r=0;\n         for(int i=0;i\u003csize;i++){\n             IndexNode top= list.poll();\n             if(i==0)l=top.index;\n             r=top.index;\n             if(top.node.left!=null){\n               list.offer(new IndexNode(top.node.left,top.index*2));\n              }\n              if(top.node.right!=null){\n               list.offer(new IndexNode(top.node.right,top.index*2+1));\n              }\n         }\n         ans=Math.max(ans,r-l+1);\n       } \n\n      return ans;\n      }\n    \n    \n}\nclass IndexNode{\n   TreeNode node;\n   int index;\n    public IndexNode(TreeNode node,int index){\n      this.node=node;\n      this.index=index;\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161897-eys19g5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161897-eys19g5","updated":"20230817161897"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/","TextMarkTextContent":"剑指 Offer 26. 树的子结构"}]},{"ID":"20230817161898-b2kqp9n","Type":"NodeParagraph","Properties":{"id":"20230817161898-b2kqp9n","updated":"20230817161898"},"Children":[{"Type":"NodeText","Data":"难度中等482"}]},{"ID":"20230817161899-kjmhjg0","Type":"NodeParagraph","Properties":{"id":"20230817161899-kjmhjg0","updated":"20230817161899"},"Children":[{"Type":"NodeText","Data":"输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)"}]},{"ID":"20230817161900-lzxolba","Type":"NodeParagraph","Properties":{"id":"20230817161900-lzxolba","updated":"20230817161900"},"Children":[{"Type":"NodeText","Data":"B是A的子结构， 即 A中有出现和B相同的结构和节点值。"}]},{"ID":"20230817161901-nplu365","Type":"NodeParagraph","Properties":{"id":"20230817161901-nplu365","updated":"20230817161901"},"Children":[{"Type":"NodeText","Data":"例如:"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"给定的树 A:"}]},{"ID":"20230817161902-92mlnwx","Type":"NodeParagraph","Properties":{"id":"20230817161902-92mlnwx","updated":"20230817161902"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"   3  / \\  4  5 / \\ 1  2"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"给定的树 B："}]},{"ID":"20230817161903-x49qbbh","Type":"NodeParagraph","Properties":{"id":"20230817161903-x49qbbh","updated":"20230817161903"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"  4  / 1"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。"}]},{"ID":"20230817161904-z6pnzcv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161904-z6pnzcv","updated":"20230817161904"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n   public boolean isMatch(TreeNode A,TreeNode B){\n     if(A==null\u0026\u0026B!=null)return false;\n     if(B==null)return true;\n     if(A.val!=B.val)return false;\n     return isMatch(A.left,B.left)\u0026\u0026isMatch(A.right,B.right);\n     \n   }\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n      if(A==null)return false;\n      if(B==null)return false;\n      if(A.val==B.val\u0026\u0026isMatch(A,B))return true;\n      return isSubStructure(A.left,B)||isSubStructure(A.right,B);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161905-e95t37p","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161905-e95t37p","updated":"20230817161905"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/","TextMarkTextContent":"剑指 Offer 54. 二叉搜索树的第k大节点"}]},{"ID":"20230817161906-t0aysfr","Type":"NodeParagraph","Properties":{"id":"20230817161906-t0aysfr","updated":"20230817161906"},"Children":[{"Type":"NodeText","Data":"难度简单258"}]},{"ID":"20230817161907-l8vr2n2","Type":"NodeParagraph","Properties":{"id":"20230817161907-l8vr2n2","updated":"20230817161907"},"Children":[{"Type":"NodeText","Data":"给定一棵二叉搜索树，请找出其中第 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" 大的节点的值。"}]},{"ID":"20230817161908-j36r2zg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161908-j36r2zg","updated":"20230817161908"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n  int k=0;\n  int ans=0;\n    public int kthLargest(TreeNode root, int k) {\n      this.k=k;\n      dfs(root);\n      return ans;\n    }\n    public void dfs(TreeNode root){\n       if(root==null)return ;\n       dfs(root.right);\n         k-=1;\n        if(k==0)ans=root.val;\n       dfs(root.left);\n        return;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161909-2aoonnt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161909-2aoonnt","updated":"20230817161909"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/","TextMarkTextContent":"230. 二叉搜索树中第K小的元素"}]},{"ID":"20230817161910-z0hoe77","Type":"NodeParagraph","Properties":{"id":"20230817161910-z0hoe77","updated":"20230817161910"},"Children":[{"Type":"NodeText","Data":"难度中等582"}]},{"ID":"20230817161911-xcqm96q","Type":"NodeParagraph","Properties":{"id":"20230817161911-xcqm96q","updated":"20230817161911"},"Children":[{"Type":"NodeText","Data":"给定一个二叉搜索树的根节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":" ，和一个整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" ，请你设计一个算法查找其中第 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" 个最小元素（从 1 开始计数）。"}]},{"ID":"20230817161912-mf6ml9u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161912-mf6ml9u","updated":"20230817161912"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n  int k=0;\n  int ans=0;\n    public int kthSmallest(TreeNode root, int k) {\n      this.k=k;\n      dfs(root);\n      return ans;\n    }\n    public void dfs(TreeNode root){\n      if(root==null)return;\n      dfs(root.left);\n       if(k==0)return;\n       k-=1;\n       if(k==0)ans=root.val;\n      dfs(root.right);\n      return ;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161913-47a9ara","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161913-47a9ara","updated":"20230817161913"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/path-sum/","TextMarkTextContent":"112. 路径总和"}]},{"ID":"20230817161914-9ftyel8","Type":"NodeParagraph","Properties":{"id":"20230817161914-9ftyel8","updated":"20230817161914"},"Children":[{"Type":"NodeText","Data":"难度简单802"}]},{"ID":"20230817161915-ycdhj0y","Type":"NodeParagraph","Properties":{"id":"20230817161915-ycdhj0y","updated":"20230817161915"},"Children":[{"Type":"NodeText","Data":"给你二叉树的根节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":" 和一个表示目标和的整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"targetSum"},{"Type":"NodeText","Data":" 。判断该树中是否存在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"根节点到叶子节点"},{"Type":"NodeText","Data":" 的路径，这条路径上所有节点值相加等于目标和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"targetSum"},{"Type":"NodeText","Data":" 。如果存在，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" ；否则，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161916-m7l9pil","Type":"NodeParagraph","Properties":{"id":"20230817161916-m7l9pil","updated":"20230817161916"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"叶子节点"},{"Type":"NodeText","Data":" 是指没有子节点的节点。"}]},{"ID":"20230817161917-s3g7zki","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161917-s3g7zki","updated":"20230817161917"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n       return  dfs(root,targetSum);\n    }\n    public boolean dfs(TreeNode root,int targetSum){\n        if(root==null)return false;\n        targetSum-=root.val;\n        if(root.left==null\u0026\u0026root.right==null\u0026\u0026targetSum==0)return true;\n       return  dfs(root.left,targetSum)||dfs(root.right,targetSum);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161918-yvaspll","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161918-yvaspll","updated":"20230817161918"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/","TextMarkTextContent":"863. 二叉树中所有距离为 K 的结点"}]},{"ID":"20230817161919-u2ufvsm","Type":"NodeParagraph","Properties":{"id":"20230817161919-u2ufvsm","updated":"20230817161919"},"Children":[{"Type":"NodeText","Data":"难度中等510"}]},{"ID":"20230817161920-ruhi4a0","Type":"NodeParagraph","Properties":{"id":"20230817161920-ruhi4a0","updated":"20230817161920"},"Children":[{"Type":"NodeText","Data":"给定一个二叉树（具有根结点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":"）， 一个目标结点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" ，和一个整数值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161921-vdw33we","Type":"NodeParagraph","Properties":{"id":"20230817161921-vdw33we","updated":"20230817161921"},"Children":[{"Type":"NodeText","Data":"返回到目标结点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"target"},{"Type":"NodeText","Data":" 距离为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" 的所有结点的值的列表。 答案可以以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"任何顺序"},{"Type":"NodeText","Data":" 返回。"}]},{"ID":"20230817161922-iw0a7tu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161922-iw0a7tu","updated":"20230817161922"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List\u003cInteger\u003e ans=new ArrayList();\n    HashMap\u003cTreeNode,TreeNode\u003eh=new HashMap();   \n    public List\u003cInteger\u003e distanceK(TreeNode root, TreeNode target, int k) {\n       getparent(root);\n       h.put(root,null);\n       dfs(target,null,k);\n       return ans;\n    }\n    public void dfs(TreeNode target,TreeNode from,int k){\n      if(target==null) return;\n      if(k==0){\n        ans.add(target.val);\n         return;\n      }\n      if(h.get(target)!=from){//注意不是target!=from 因为这两者本来就不等 苦笑\n        dfs(h.get(target),target,k-1);\n      }\n       if(target.left!=from){\n        dfs(target.left,target,k-1);\n      }\n       if(target.right!=from){\n        dfs(target.right,target,k-1);\n      }\n      return;\n    }      \n\n    public void getparent(TreeNode root){\n      if(root.left!=null){\n        h.put(root.left,root);\n        getparent(root.left);\n      }\n      if(root.right!=null){\n        h.put(root.right,root);\n       getparent(root.right);\n      }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161923-cmn547v","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161923-cmn547v","updated":"20230817161923"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/cousins-in-binary-tree/","TextMarkTextContent":"993. 二叉树的堂兄弟节点"}]},{"ID":"20230817161924-62w85yd","Type":"NodeParagraph","Properties":{"id":"20230817161924-62w85yd","updated":"20230817161924"},"Children":[{"Type":"NodeText","Data":"难度简单263"}]},{"ID":"20230817161925-k0xta27","Type":"NodeParagraph","Properties":{"id":"20230817161925-k0xta27","updated":"20230817161925"},"Children":[{"Type":"NodeText","Data":"在二叉树中，根节点位于深度 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":" 处，每个深度为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k"},{"Type":"NodeText","Data":" 的节点的子节点位于深度 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"k+1"},{"Type":"NodeText","Data":" 处。"}]},{"ID":"20230817161926-uoyq0lt","Type":"NodeParagraph","Properties":{"id":"20230817161926-uoyq0lt","updated":"20230817161926"},"Children":[{"Type":"NodeText","Data":"如果二叉树的两个节点深度相同，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"父节点不同"},{"Type":"NodeText","Data":" ，则它们是一对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"堂兄弟节点"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230817161927-xunt9em","Type":"NodeParagraph","Properties":{"id":"20230817161927-xunt9em","updated":"20230817161927"},"Children":[{"Type":"NodeText","Data":"我们给出了具有唯一值的二叉树的根节点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"root"},{"Type":"NodeText","Data":" ，以及树中两个不同节点的值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"y"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161928-x6o0uxk","Type":"NodeParagraph","Properties":{"id":"20230817161928-x6o0uxk","updated":"20230817161928"},"Children":[{"Type":"NodeText","Data":"只有与值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"y"},{"Type":"NodeText","Data":" 对应的节点是堂兄弟节点时，才返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" 。否则，返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"。"}]},{"ID":"20230817161929-ro4qlrf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161929-ro4qlrf","updated":"20230817161929"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n     int x;\n     TreeNode xparent;\n     int xdeepth;\n     boolean flag1;\n     \n     int y;\n     TreeNode yparent;\n     int ydeepth;\n     boolean flag2;\n    public boolean isCousins(TreeNode root, int x, int y) {\n        this.x=x;\n        this.y=y;\n        dfs(root,0,null);\n        return xparent!=yparent\u0026\u0026xdeepth==ydeepth;\n    }\n    public void dfs(TreeNode root,int deepth,TreeNode parent){\n       if(root==null)return;\n       if(root.val==x){\n         xparent=parent;\n         xdeepth=deepth;\n         flag1=true;\n       }else if(root.val==y){\n         yparent=parent;\n         ydeepth=deepth;\n         flag2=true;\n       }       \n      if(flag1\u0026\u0026flag2)return;       \n     dfs(root.left,deepth+1,root);\n       if(flag1\u0026\u0026flag2)return; \n     dfs(root.right,deepth+1,root);\n      return;\n\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}