{"ID":"20230817161920-dy1zz6u","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161920-dy1zz6u","title":"深度优先搜索和广度优先搜索","updated":"20230817161920"},"Children":[{"ID":"20230817161921-ubhsyms","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161921-ubhsyms","updated":"20230817161921"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1、深度优先搜索"}]},{"ID":"20230817161922-4qvd8wm","Type":"NodeParagraph","Properties":{"id":"20230817161922-4qvd8wm","updated":"20230817161922"},"Children":[{"Type":"NodeText","Data":"大多时候采用递归加回溯实现，深度优先搜索我们需要在脑子里思考出一颗问题状态树 通过适当的剪枝来优化问题"}]},{"ID":"20230817161923-ug38kh6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161923-ug38kh6","updated":"20230817161923"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2、广度游戏搜索"}]},{"ID":"20230817161924-whp1fcw","Type":"NodeParagraph","Properties":{"id":"20230817161924-whp1fcw","updated":"20230817161924"},"Children":[{"Type":"NodeText","Data":"一般的实现方式是通过队列来辅助实现，因为它的搜索方式类似于层序遍历，广度优先搜索主要用于最优问题的求解"}]},{"ID":"20230817161925-coot9in","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161925-coot9in","updated":"20230817161925"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Leecode刷题："}]},{"ID":"20230817161926-2016mzv","Type":"NodeParagraph","Properties":{"id":"20230817161926-2016mzv","updated":"20230817161926"},"Children":[{"Type":"NodeText","Data":"Lc 993:在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。"}]},{"ID":"20230817161927-m7nc2mv","Type":"NodeParagraph","Properties":{"id":"20230817161927-m7nc2mv","updated":"20230817161927"},"Children":[{"Type":"NodeText","Data":"如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。"}]},{"ID":"20230817161928-ppljod0","Type":"NodeParagraph","Properties":{"id":"20230817161928-ppljod0","updated":"20230817161928"},"Children":[{"Type":"NodeText","Data":"我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。"}]},{"ID":"20230817161929-dfp970q","Type":"NodeParagraph","Properties":{"id":"20230817161929-dfp970q","updated":"20230817161929"},"Children":[{"Type":"NodeText","Data":"只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。"}]},{"ID":"20230817161930-xbojixo","Type":"NodeParagraph","Properties":{"id":"20230817161930-xbojixo","updated":"20230817161930"},"Children":[{"Type":"NodeText","Data":"深搜解法："}]},{"ID":"20230817161931-sbgrtdr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161931-sbgrtdr","updated":"20230817161931"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    HashMap\u003cInteger,TreeNode\u003e h=new HashMap();\n    public void fa(TreeNode root){//用一个hashmap来记录父亲节点\n        if(root==null)return;\n        if(root.left!=null){\n          h.put(root.left.val,root);\n          fa(root.left);\n        }\n        if(root.right!=null){\n          h.put(root.right.val,root);\n          fa(root.right);\n        }\n        return;\n         }\n    public int dfs(TreeNode root,int target){//深度优先搜索目标值的深度\n      if(root==null)return -1;\n      if(root.val==target)return 0;\n      int l;\n      l=dfs(root.left,target);\n      if(l!=-1)return l+1;\n      int r;\n      r=dfs(root.right,target);\n      if(r!=-1)return r+1;\n      return -1;\n  }\n    public boolean isCousins(TreeNode root, int x, int y) {\n          int lx,ly;\n          lx=dfs(root,x);\n          ly=dfs(root,y);\n          fa(root);\n         return lx==ly\u0026\u0026h.get(x)!=h.get(y);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161932-nxatt7s","Type":"NodeParagraph","Properties":{"id":"20230817161932-nxatt7s","updated":"20230817161932"},"Children":[{"Type":"NodeText","Data":"广搜解法："}]},{"ID":"20230817161933-3gzyy15","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161933-3gzyy15","updated":"20230817161933"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n public boolean isCousins(TreeNode root, int x, int y) {\n        LinkedList\u003cData\u003e list = new LinkedList\u003c\u003e();\n        list.offer(new Data(root, null, 0));\n        int lx=-1, ly=-1;\n        TreeNode fax = null;\n        TreeNode fay = null;\n        while (!list.isEmpty()) {//利用队列进行层序遍历\n            Data data = list.poll();\n            if(data.root.val==x) {\n                lx = data.deepth;\n                fax = data.father;\n            }\n            if(data.root.val==y) {\n                ly= data.deepth;\n                fay = data.father;\n            }\n            if(lx!=-1\u0026\u0026ly!=-1)break;//如果找到了问题的答案可以提前退出\n            if(data.root.left!=null){\n                list.offer(new Data(data.root.left,data.root,data.deepth+1));\n            }\n            if(data.root.right!=null){\n                list.offer(new Data(data.root.right,data.root,data.deepth+1));\n            }\n        }\n        return  lx==ly\u0026\u0026fax!=fay;\n    }\n}\n\nclass Data {//这个就是描述问题所需要的状态\n    TreeNode  root;\n    TreeNode father;\n    int  deepth;\n\n    public Data(TreeNode root, TreeNode father, int deepth) {\n        this.root =root;\n        this.father = father;\n        this.deepth = deepth;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161934-gmnfvu2","Type":"NodeParagraph","Properties":{"id":"20230817161934-gmnfvu2","updated":"20230817161934"},"Children":[{"Type":"NodeText","Data":"LC 542："}]},{"ID":"20230817161935-s5rw350","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161935-s5rw350","updated":"20230817161935"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"    public int[][] updateMatrix(int[][] mat) {\n        int n=mat.length;\n        int m=mat[0].length;\n        int [][]vis=new int[n][m];//记录是否被访问过 同时也是结果数组\n        LinkedList\u003cData\u003e list = new LinkedList\u003c\u003e();\n        for (int i = 0; i \u003c n; i++) {\n            for (int j = 0; j \u003c m; j++) {\n                vis[i][j]=-1;\n            }\n        }\n        for (int i = 0; i \u003c n; i++) {\n            for (int j = 0; j \u003c m; j++) {\n                if(mat[i][j]!=0)continue;\n                vis[i][j]=0;\n                list.offer(new Data(i,j,0));\n            }\n        }\n        int [][]dir={{0,1},{1,0},{0,-1},{-1,0}};//方向数组\n        while (!list.isEmpty()){\n            Data poll = list.poll();\n            for (int i = 0; i \u003c 4; i++) {\n                int x=poll.i+dir[i][0];\n                int y=poll.j+dir[i][1];\n                if(x\u003c0||x\u003e=n)continue;\n                if(y\u003c0||y\u003e=m)continue;\n                if(vis[x][y]!=-1)continue;\n                vis[x][y]=poll.k+1;//满足条件 就需要将vis数组置为当前状态到0状态的层数\n                list.offer(new Data(x,y,poll.k+1));\n            }\n        }\n        return vis;\n\n    }\n    class  Data{\n        int i,j,k;//i，j代表坐标 k代表当前状态到0状态的距离\n\n        public Data(int i, int j, int k) {\n            this.i = i;\n            this.j = j;\n            this.k = k;\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161936-7kzqgfo","Type":"NodeParagraph","Properties":{"id":"20230817161936-7kzqgfo","updated":"20230817161936"},"Children":[{"Type":"NodeText","Data":"Lc 752："}]},{"ID":"20230817161937-pbzik4u","Type":"NodeParagraph","Properties":{"id":"20230817161937-pbzik4u","updated":"20230817161937"},"Children":[{"Type":"NodeText","Data":"你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。"}]},{"ID":"20230817161938-pcp29hy","Type":"NodeParagraph","Properties":{"id":"20230817161938-pcp29hy","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。"}]},{"ID":"20230817161939-7r7dwt4","Type":"NodeParagraph","Properties":{"id":"20230817161939-7r7dwt4","updated":"20230817161939"},"Children":[{"Type":"NodeText","Data":"列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。"}]},{"ID":"20230817161940-wbbhrtt","Type":"NodeParagraph","Properties":{"id":"20230817161940-wbbhrtt","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。"}]},{"ID":"20230817161941-fbq2ilz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161941-fbq2ilz","updated":"20230817161941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"   public int openLock(String[] deadends, String target) {\n        HashSet\u003cString\u003e hashSet = new HashSet\u003c\u003e();\n        for(String s:deadends){\n            hashSet.add(s);\n        }\n        if(hashSet.contains(\"0000\"))return -1;\n        LinkedList\u003cData\u003e list = new LinkedList\u003c\u003e();\n        list.offer(new Data(\"0000\",0));\n        hashSet.add(\"0000\");\n        while (!list.isEmpty()){\n            Data data = list.poll();\n            if(data.s.equals(target))return data.k;\n            for (int i = 0; i \u003c 4; i++) {\n                for (int k = 0; k \u003c 2; k++) {\n                    String s = getString(data.s, i, k);\n                    if (hashSet.contains(s)) continue;\n                    hashSet.add(s);\n                    list.offer(new Data(s, data.k + 1));\n                }\n            }\n        }\n        return -1;\n    }\n    public  String getString(String s,int i,int k){\n        char[] chars = s.toCharArray();\n        switch (k){\n            case 0:chars[i]-=1;break;\n            case 1: chars[i]+=1;break;\n        }\n        if(chars[i]\u003c'0')chars[i]='9';\n        if(chars[i]\u003e'9')chars[i]='0';\n        return new String(chars);\n\n    }\n    class  Data{\n        String s;\n        int k;\n\n        public Data(String s, int k) {\n            this.s = s;\n            this.k = k;\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161942-g7d67be","Type":"NodeParagraph","Properties":{"id":"20230817161942-g7d67be","updated":"20230817161942"},"Children":[{"Type":"NodeText","Data":"Lc 1091："}]},{"ID":"20230817161943-2cegnhd","Type":"NodeParagraph","Properties":{"id":"20230817161943-2cegnhd","updated":"20230817161943"},"Children":[{"Type":"NodeText","Data":"给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。"}]},{"ID":"20230817161944-t5b4h5q","Type":"NodeParagraph","Properties":{"id":"20230817161944-t5b4h5q","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求："}]},{"ID":"20230817161945-w5wfnod","Type":"NodeParagraph","Properties":{"id":"20230817161945-w5wfnod","updated":"20230817161945"},"Children":[{"Type":"NodeText","Data":"路径途经的所有单元格都的值都是 0 。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"畅通路径的长度 是该路径途经的单元格总数。"}]},{"ID":"20230817161946-n8xbkn3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161946-n8xbkn3","updated":"20230817161946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public int shortestPathBinaryMatrix(int[][] grid) {\n        int n=grid.length,m=grid[0].length;\n        int [][]vis=new int[n][m];\n        if(grid[0][0]!=0)return -1;\n        LinkedList\u003cData\u003e list= new LinkedList();\n        list.offer(new Data(0,0,1));\n        vis[0][0]=1;\n        int [][]dir={{0,1},{1,0},{0,-1},{-1,0},{1,-1},{-1,1},{1,1},{-1,-1}};\n        while(!list.isEmpty()){\n            Data data= list.poll();\n            if(data.i==n-1\u0026\u0026data.j==m-1\u0026\u0026grid[data.i][data.j]==0)return data.k;\n            for(int k=0;k\u003c8;k++){\n                int x=dir[k][0]+data.i;\n                int y=dir[k][1]+data.j;\n                if(x\u003c0||x\u003e=n)continue;\n                if(y\u003c0||y\u003e=m)continue;\n                if(grid[x][y]!=0)continue;\n                if(vis[x][y]!=0)continue;\n                vis[x][y]=1;\n                list.offer(new Data(x,y,data.k+1));\n            }\n        }\n        return -1;\n    }\n    class Data{\n        int i,j,k;\n        public Data(int i,int j,int k){\n            this.i=i;\n            this.j=j;\n            this.k=k;\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161947-dne4qx5","Type":"NodeParagraph","Properties":{"id":"20230817161947-dne4qx5","updated":"20230817161947"},"Children":[{"Type":"NodeText","Data":"剑指offer13："}]},{"ID":"20230817161948-72qd9xq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161948-72qd9xq","updated":"20230817161948"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public int movingCount(int m, int n, int k) {\n        LinkedList\u003cData\u003e list = new LinkedList\u003c\u003e();\n        int [][]vis=new int[m][n];\n        int ans=0;\n        int []dsum=new int[100];\n        for (int i = 0; i \u003c 10; i++) {\n            for (int j = 0; j \u003c 10; j++) {\n                dsum[i*10+j]=i+j;\n            }\n        }\n        list.offer(new Data(0,0));\n        vis[0][0]=1;\n        int [][]dir={{0,1},{1,0},{0,-1},{-1,0}};\n        while (!list.isEmpty()){\n            Data data = list.poll();\n            ans++;\n            for (int i = 0; i \u003c 4; i++) {\n                int x=data.i+dir[i][0];\n                int y=data.j+dir[i][1];\n                if(x\u003e=m||x\u003c0)continue;\n                if(y\u003e=n||y\u003c0)continue;\n                if(dsum[x]+dsum[y]\u003ek)continue;\n                if(vis[x][y]!=0)continue;\n                list.offer(new Data(x,y));\n                vis[x][y]=1;\n            }\n        }\n        return ans;\n    }\n    class Data{\n        int i,j;\n\n        public Data(int i, int j) {\n            this.i = i;\n            this.j = j;\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161949-69wlnze","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161949-69wlnze","updated":"20230817161949"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"深搜练习"}]},{"ID":"20230817161950-999sofe","Type":"NodeParagraph","Properties":{"id":"20230817161950-999sofe","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"再深搜里面 参数通常被视为状态 在开始处理问题 在结束深搜遍历"}]},{"ID":"20230817161951-k6qxxnw","Type":"NodeParagraph","Properties":{"id":"20230817161951-k6qxxnw","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"LC 130"}]},{"ID":"20230817161952-xcaex7h","Type":"NodeParagraph","Properties":{"id":"20230817161952-xcaex7h","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"给你一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"m x n"},{"Type":"NodeText","Data":" 的矩阵 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"board"},{"Type":"NodeText","Data":" ，由若干字符 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'X'"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'O'"},{"Type":"NodeText","Data":" ，找到所有被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'X'"},{"Type":"NodeText","Data":" 围绕的区域，并将这些区域里所有的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'O'"},{"Type":"NodeText","Data":" 用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"'X'"},{"Type":"NodeText","Data":" 填充。"}]},{"ID":"20230817161953-zdmun7d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161953-zdmun7d","updated":"20230817161953"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n    int n, m;\n    int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        public void dfs(int i, int j, char[][] board,int [][]vis) {\n        board[i][j] = 'o';\n        vis[i][j]=1;\n        for (int k = 0; k \u003c 4; k++) {\n            int x = i + dir[k][0];\n            int y = j + dir[k][1];\n            if (x \u003c 0 || x \u003e= n) continue;\n            if (y \u003c 0 || y \u003e= m) continue;\n            if (vis[x][y] != 0) continue;\n            if (board[x][y] != 'O') continue;\n            vis[x][y] = 1;\n            dfs(x, y, board,vis);\n        }\n        return;\n    }\n    public void solve(char[][] board) {\n        this.n = board.length;\n        this.m = board[0].length;\n        int[][] vis = new int[n][m];\n          for (int i = 0; i \u003c n; i++) {\n              if(board[i][0]=='O')dfs(i,0,board,vis);\n              if(board[i][m-1]=='O')dfs(i,m-1,board,vis);\n          }\n          for (int i = 0; i \u003c m; i++) {\n              if(board[0][i]=='O')dfs(0,i,board,vis);\n              if(board[n-1][i]=='O')dfs(n-1,i,board,vis);\n          }\n          for (int i = 0; i \u003c n; i++) {\n              for (int j = 0; j \u003c m; j++) {\n                  if(board[i][j]=='O'){\n                      board[i][j]='X';\n                  }else if(board[i][j]=='o'){\n                      board[i][j]='O';\n                  }\n              }\n          }\n          return;\n        }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161954-833oxht","Type":"NodeParagraph","Properties":{"id":"20230817161954-833oxht","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"LC494"}]},{"ID":"20230817161955-4rmnk7g","Type":"NodeParagraph","Properties":{"id":"20230817161955-4rmnk7g","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"记忆化搜索：我们可以把问题中的状态打包成一种数据结构 用hashmap进行存储 通过方式完成从函数到数组的映射 每次搜索时判断该状态存不存在 如果存在直接返回 用空间换时间"}]},{"ID":"20230817161956-g793u6k","Type":"NodeParagraph","Properties":{"id":"20230817161956-g793u6k","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"问题："}]},{"ID":"20230817161957-fn71m6i","Type":"NodeParagraph","Properties":{"id":"20230817161957-fn71m6i","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 nums 和一个整数 target 。"}]},{"ID":"20230817161958-lu71o2l","Type":"NodeParagraph","Properties":{"id":"20230817161958-lu71o2l","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ："}]},{"ID":"20230817161959-r9jtoba","Type":"NodeParagraph","Properties":{"id":"20230817161959-r9jtoba","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。"}]},{"ID":"20230817161960-e19ypwu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161960-e19ypwu","updated":"20230817161960"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n   HashMap\u003cString,Integer\u003e hashMap=new HashMap\u003c\u003e();//记忆化搜索\n     public  int dfs(int i,int target,int []nums){\n           String s=i+\"-\"+target;//状态打包\n          if(i==nums.length){\n              return target==0?1:0;\n          }\n          if(hashMap.containsKey(s))return  hashMap.get(s);//判断该状态结果是否存在 如果存在 就不需要往下进行搜索\n         int left = dfs(i + 1, target - nums[i], nums);\n         int right=dfs(i+1,target+nums[i],nums);\n         int ans=left+right;\n         hashMap.put(s,ans);//存储当前状态结果\n         return  ans;\n     }\n    public int findTargetSumWays(int[] nums, int target) {\n        int ans = dfs(0, target, nums);\n        return  ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161961-g79dvhr","Type":"NodeParagraph","Properties":{"id":"20230817161961-g79dvhr","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"LC 473"}]},{"ID":"20230817161962-j5rpxuk","Type":"NodeParagraph","Properties":{"id":"20230817161962-j5rpxuk","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。"}]},{"ID":"20230817161963-kc58sd1","Type":"NodeParagraph","Properties":{"id":"20230817161963-kc58sd1","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。"}]},{"ID":"20230817161964-sv1q578","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161964-sv1q578","updated":"20230817161964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public boolean dfs(int i, int[] tong, int[] ms) {\n        if (i == -1) {\n            //如果已经遍历到最后一个桶就回溯\n            return tong[1] == 0 \u0026\u0026 tong[2] == 0 \u0026\u0026 tong[3] == 0 \u0026\u0026 tong[0] == 0;\n\n        }\n        for (int j = 0; j \u003c 4; j++) {\n            if (tong[j] \u003c ms[i]) continue;\n            if (tong[j] == ms[i] || tong[j] - ms[i] \u003e= ms[0]) {\n                tong[j] -= ms[i];\n                if (dfs(i - 1, tong, ms)) return true;\n                tong[j] += ms[i];\n            }\n        }\n        return false;\n    }\n\n    public boolean makesquare(int[] matchsticks) {//状态分析 建立四个桶 每个桶里面表示边长剩余容量\n        Arrays.sort(matchsticks);\n        int[] tong = new int[4];\n        int temp = 0;\n        for (int i = 0; i \u003c matchsticks.length; i++) {\n            temp += matchsticks[i];\n        }\n        if (temp % 4 != 0) return false;\n        for (int i = 0; i \u003c tong.length; i++) {\n            tong[i] = temp / 4;\n        }\n        return dfs(matchsticks.length - 1, tong, matchsticks);\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161965-88tet92","Type":"NodeParagraph","Properties":{"id":"20230817161965-88tet92","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"LC39："}]},{"ID":"20230817161966-rc0z4br","Type":"NodeParagraph","Properties":{"id":"20230817161966-rc0z4br","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。"}]},{"ID":"20230817161967-xh751ro","Type":"NodeParagraph","Properties":{"id":"20230817161967-xh751ro","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。"}]},{"ID":"20230817161968-pgfe2rk","Type":"NodeParagraph","Properties":{"id":"20230817161968-pgfe2rk","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"对于给定的输入，保证和为 target 的不同组合数少于 150 个。"}]},{"ID":"20230817161969-tqkezts","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-tqkezts","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public  void dfs(int idx,int []candidates,List\u003cInteger\u003etemp,List\u003cList\u003cInteger\u003e\u003eans,int target){\n        if(target\u003c0)return;\n        if(target==0){\n            ans.add(new ArrayList\u003c\u003e(temp));\n            return;\n        }\n        if(idx==candidates.length)return;\n        dfs(idx+1,candidates,temp,ans,target);\n        temp.add(candidates[idx]);\n        dfs(idx,candidates,temp,ans,target-candidates[idx]);\n        temp.remove(temp.size()-1);\n        return;\n    }\n    public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) {\n        List\u003cList\u003cInteger\u003e\u003e ans=new ArrayList\u003c\u003e();\n        List\u003cInteger\u003etemp=new ArrayList\u003c\u003e();\n        dfs(0,candidates,temp,ans,target);\n        return  ans;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}