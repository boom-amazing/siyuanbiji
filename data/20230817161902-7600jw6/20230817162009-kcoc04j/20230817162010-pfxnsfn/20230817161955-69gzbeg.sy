{"ID":"20230817161955-69gzbeg","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161955-69gzbeg","title":"单调栈","updated":"20230817161955"},"Children":[{"ID":"20230817161956-1obew2n","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161956-1obew2n","updated":"20230817161956"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"单调栈"}]},{"ID":"20230817161957-co2w2ad","Type":"NodeParagraph","Properties":{"id":"20230817161957-co2w2ad","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"单调栈是维护当前元素最近 比他大或比他小的元素位置  单调递减可以维护最近比他大 单调递增可以维护最近比他小"}]},{"ID":"20230817161958-ycrwi4v","Type":"NodeParagraph","Properties":{"id":"20230817161958-ycrwi4v","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"LC503 ："}]},{"ID":"20230817161959-gw8vftp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161959-gw8vftp","updated":"20230817161959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n public int[] nextGreaterElements(int[] nums) {//处理循环可以对原数组操作两次\n      int [] ans=new int[nums.length];\n      Arrays.fill(ans,-1);\n      Stack\u003cInteger\u003e stack=new Stack();\n      for(int i=0;i\u003cnums.length;i++){\n       while(!stack.isEmpty()\u0026\u0026nums[i]\u003enums[stack.peek()]){\n              ans[stack.peek()]=nums[i];\n              stack.pop();         \n       }\n         stack.push(i);\n      }\n       for(int i=0;i\u003cnums.length;i++){\n       while(!stack.isEmpty()\u0026\u0026nums[i]\u003enums[stack.peek()]){\n              ans[stack.peek()]=nums[i];\n              stack.pop();         \n       }\n         stack.push(i);\n      }\n      return ans;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161960-2kizzez","Type":"NodeParagraph","Properties":{"id":"20230817161960-2kizzez","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"LC901"}]},{"ID":"20230817161961-e8kia6w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161961-e8kia6w","updated":"20230817161961"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n\n例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n\nclass StockSpanner {//题目要求小于等于的天数 我们可以找左边第一个大于他的元素\n    class PII{\n      int t;\n      int val;\n      public PII(int t,int val){\n        this.t=t;\n        this.val=val;\n      }\n    }\n    int t=0;\n    Stack\u003cPII\u003e stack=new Stack();\n    public StockSpanner() {\n       stack.push(new PII(t++,Integer.MAX_VALUE));\n    }\n    \n    public int next(int price) {\n       while(!stack.isEmpty()\u0026\u0026price\u003e=stack.peek().val){\n           stack.pop();\n       }\n       int ret=t-stack.peek().t;\n      stack.push(new PII(t++,price));\n       return ret;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161962-l2e5777","Type":"NodeParagraph","Properties":{"id":"20230817161962-l2e5777","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"LC739"}]},{"ID":"20230817161963-0n2noil","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161963-0n2noil","updated":"20230817161963"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n   public int[] dailyTemperatures(int[] temperatures) {//单调栈的裸题\n         int n=temperatures.length;\n         int []ans=new int[n];\n        Stack\u003cInteger\u003e stack=new Stack();\n        for(int i=0;i\u003ctemperatures.length;i++){\n          while(!stack.isEmpty()\u0026\u0026temperatures[i]\u003etemperatures[stack.peek()]){\n            ans[stack.peek()]=i-stack.peek();\n             stack.pop();\n           }\n           stack.push(i);\n        }\n        return ans;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161964-17v4je9","Type":"NodeParagraph","Properties":{"id":"20230817161964-17v4je9","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"LC 84"}]},{"ID":"20230817161965-d485cfa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"SkFWQQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161965-d485cfa","updated":"20230817161965"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"SkFWQQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n    public int largestRectangleArea(int[] heights) {//以每个数的高度作为基准 分别找出左右两边第一个小于他们的元素 而这两个元素的中间所选择的元素范围就是我们需要的宽\n        int n=heights.length;\n        int []l=new int[n];\n        int []r=new int[n];\n        for(int i=0;i\u003cn;i++){\n          l[i]=-1;\n          r[i]=n;\n        }\n        Stack\u003cInteger\u003e stack=new Stack();\n        for(int i=0;i\u003cn;i++){\n         while(!stack.isEmpty()\u0026\u0026heights[i]\u003c=heights[stack.peek()]){\n            r[stack.peek()]=i;\n            stack.pop();\n           }\n         if(!stack.isEmpty())l[i]=stack.peek();\n          stack.push(i);   \n        }\n        int ans=0;\n        for(int i=0;i\u003cn;i++){\n         ans=Math.max(ans,heights[i]*(r[i]-l[i]-1));\n        }\n        return ans;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161966-upqrnqd","Type":"NodeParagraph","Properties":{"id":"20230817161966-upqrnqd","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"LC 1856 与上一个题一样的思路 只是最后求结果时 用的前缀和"}]},{"ID":"20230817161967-2y4y80v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161967-2y4y80v","updated":"20230817161967"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。\n\n比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。\n给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。\n\n请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。\n\n子数组 定义为一个数组的 连续 部分。\n \npublic int maxSumMinProduct(int[] nums) {//以每个值作为最小值 搜寻左右两边比他大的元素下标 处于中间的范围就是我们满足条件的\n     int n=nums.length;\n        int []l=new int[n];\n        int []r=new int[n];\n        for(int i=0;i\u003cn;i++){\n          l[i]=-1;\n          r[i]=n;\n        }\n        Stack\u003cInteger\u003e stack=new Stack();\n        for(int i=0;i\u003cn;i++){\n         while(!stack.isEmpty()\u0026\u0026nums[i]\u003c=nums[stack.peek()]){\n            r[stack.peek()]=i;\n            stack.pop();\n           }\n         if(!stack.isEmpty())l[i]=stack.peek();\n          stack.push(i);   \n        }\n        long [] presum=new long[n+1];\n        for(int i=0;i\u003cn;i++){\n          presum[i+1]=nums[i]+presum[i];   \n       }\n       long ans=0;\n       for(int i=0;i\u003cn;i++){\n        ans=Math.max(ans,nums[i]*(presum[r[i]]-presum[l[i]+1]));\n       }\n         \n       return (int)(ans %(long)(1e9+7));\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161968-l7dt2na","Type":"NodeParagraph","Properties":{"id":"20230817161968-l7dt2na","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"LC907"}]},{"ID":"20230817161969-fxstbdx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-fxstbdx","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\n给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。\n\n由于答案可能很大，因此 返回答案模 10^9 + 7 。\n\nclass Solution {\n    public int sumSubarrayMins(int[] arr) {//运用单调栈来维护区间中每个元素的左右两边第一个比他小的元素 \n        int n=arr.length;\n        int []l=new int[n];\n        int []r=new int[n];\n        for(int i=0;i\u003cn;i++){\n          l[i]=-1;\n          r[i]=n;\n        }\n        Stack\u003cInteger\u003e stack=new Stack();\n        for(int i=0;i\u003cn;i++){\n         while(!stack.isEmpty()\u0026\u0026arr[i]\u003carr[stack.peek()]){\n            r[stack.peek()]=i;\n            stack.pop();\n           }\n         if(!stack.isEmpty())l[i]=stack.peek();\n          stack.push(i);   \n        }\n       long ans=0L;\n       for(int i=0;i\u003cn;i++){\n         ans+=(long)arr[i]*(i-l[i])*(r[i]-i);//该值能在多少个区间中满足最小 注意int溢出\n       }\n       return (int)(ans%(1e9+7));\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}