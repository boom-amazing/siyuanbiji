{"ID":"20230817162004-tr30a86","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817162004-tr30a86","title":"大公司的笔试题","updated":"20230817162004"},"Children":[{"ID":"20230817162005-9ymx4vu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817162005-9ymx4vu","updated":"20230817162005"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"大公司的笔试题"}]},{"ID":"20230817162006-chlk7g3","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817162006-chlk7g3","updated":"20230817162006"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1、给定两个字符串s1 和s2 判断s2的全排列是否是s1的子串？"}]},{"ID":"20230817162007-zvvt0yt","Type":"NodeParagraph","Properties":{"id":"20230817162007-zvvt0yt","updated":"20230817162007"},"Children":[{"Type":"NodeText","Data":"这个题的思路是利用哈希表加滑动窗口 维护一个大小为s2长度的滑动窗口 并且计算s2相关字符的个数"}]},{"ID":"20230817162008-hui0vl7","Type":"NodeParagraph","Properties":{"id":"20230817162008-hui0vl7","updated":"20230817162008"},"Children":[{"Type":"NodeText","Data":"在s1根据窗口的移动判断总个数大小是否相同就行 因为相同大小 相同字符串个数 一定有一个子串是s2全排列之一"}]},{"ID":"20230817162009-ytnzg5a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817162009-ytnzg5a","updated":"20230817162009"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.mianshi;\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class s2Tos1 {\n    public  static boolean judege(String source,String target) {\n        char[] schar = source.toCharArray();\n        char[] tchar = target.toCharArray();\n        int k = tchar.length;\n        HashMap\u003cCharacter, Integer\u003e h = new HashMap\u003c\u003e();\n        int sum = 0;\n        for (char c : tchar) {\n            h.put(c, h.getOrDefault(c, 0) + 1);\n            sum++;\n        }\n        int l = 0, r = 0;\n        for (int i = 0; i \u003c k; i++) {\n            r += 1;\n            if (h.containsKey(schar[i])) {\n                if (h.get(schar[i]) \u003e 0) sum--;\n                h.put(schar[i], h.getOrDefault(schar[i], 0) - 1);\n            }\n        }\n        if (sum == 0) return true;\n        int n=source.length();\n        while (r\u003c=n){\n            if(h.containsKey(schar[l])){\n                h.put(schar[l], h.getOrDefault(schar[l], 0) +1);\n                sum+=1;\n            }\n            l++;\n            r++;\n            if (h.containsKey(schar[r-1])\u0026\u0026h.get(schar[r-1])\u003e0) {\n                sum--;\n                if(sum==0)return true;\n                h.put(schar[r-1], h.getOrDefault(schar[r-1], 0) - 1);\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String source = scanner.next();\n        String target=scanner.next();\n        boolean ans=judege(source,target);\n        System.out.println(ans);\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}