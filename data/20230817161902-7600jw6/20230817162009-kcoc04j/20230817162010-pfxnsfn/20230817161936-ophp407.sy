{"ID":"20230817161936-ophp407","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161936-ophp407","title":"归并排序","updated":"20230817161936"},"Children":[{"ID":"20230817161937-rg0chi4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161937-rg0chi4","updated":"20230817161937"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"归并排序"}]},{"ID":"20230817161938-7ausx4w","Type":"NodeParagraph","Properties":{"id":"20230817161938-7ausx4w","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"最主要的是通过额外的存储空间来归并两个有序的数组 归并排序并不是原地排序算法 这也是他与快速排序的主要区别 同时归并排序的处理过程是先处理子问题 在进行合并 处理流程是由下到上的 而快速排序是先进行分区 在处理子问题 是由上到下的"}]},{"ID":"20230817161939-rpy9wfk","Type":"NodeParagraph","Properties":{"id":"20230817161939-rpy9wfk","updated":"20230817161939"},"Children":[{"Type":"NodeText","Data":"应用场景："}]},{"ID":"20230817161940-a4nx4to","Type":"NodeParagraph","Properties":{"id":"20230817161940-a4nx4to","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"归并排序在大数据场景下的应用："}]},{"ID":"20230817161941-8uu15sr","Type":"NodeParagraph","Properties":{"id":"20230817161941-8uu15sr","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"问题：电脑内存大小2GB 如何对一个40GB的文件进行排序呢"}]},{"ID":"20230817161942-7roeyv4","Type":"NodeParagraph","Properties":{"id":"20230817161942-7roeyv4","updated":"20230817161942"},"Children":[{"Type":"NodeText","Data":"先将40GB的文件划分成20个小文件 每个文件的大小为2GB 然后将每个文件进行排序"}]},{"ID":"20230817161943-gjqv4ns","Type":"NodeParagraph","Properties":{"id":"20230817161943-gjqv4ns","updated":"20230817161943"},"Children":[{"Type":"NodeText","Data":"接下来就是对20个已经排好序的文件进行归并的操作："}]},{"ID":"20230817161944-3ivxes4","Type":"NodeParagraph","Properties":{"id":"20230817161944-3ivxes4","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"我们可以从这20个文件中依次取出一条数据 然后将这20条数据放入数组大小为20的数组中 然后取出最小的数(这个时候可以借助于堆来快速选择) 写入到最终的排序文件中 接着从最小值对应的文件在取出一条数据替换数组中的最小值 直到整个过程结束"}]},{"ID":"20230817161945-hwx8wkr","Type":"NodeParagraph","Properties":{"id":"20230817161945-hwx8wkr","updated":"20230817161945"},"Children":[{"Type":"NodeText","Data":"不过 上述思路没有充分利用好内存 因为磁盘的读写速率远远小于内存 为了减少磁盘的读写次数 我们可以在内存中设置内存缓冲数组 我们在读取数据的时候可以一次性读取一批数据到内存 在写入数据时 我们可以先把其写入内存缓冲器 然后当数据超过阈值时 我们再将其写入文件中"}]},{"ID":"20230817161946-fsaxo39","Type":"NodeParagraph","Properties":{"id":"20230817161946-fsaxo39","updated":"20230817161946"},"Children":[{"Type":"NodeText","Data":"经典题："}]},{"ID":"20230817161947-dzge9p4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161947-dzge9p4","updated":"20230817161947"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/","TextMarkTextContent":"剑指 Offer 51. 数组中的逆序对"}]},{"ID":"20230817161948-9a7puhq","Type":"NodeParagraph","Properties":{"id":"20230817161948-9a7puhq","updated":"20230817161948"},"Children":[{"Type":"NodeText","Data":"难度困难646"}]},{"ID":"20230817161949-x7dhykm","Type":"NodeParagraph","Properties":{"id":"20230817161949-x7dhykm","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。"}]},{"ID":"20230817161950-caod9co","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161950-caod9co","updated":"20230817161950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n     int cnt=0;\n   public void  mergeSort(int []arr,int l,int r){\n        if(l\u003e=r)return;\n        int mid=(l+r)\u003e\u003e1;\n        mergeSort(arr,l,mid);\n        mergeSort(arr,mid+1,r);\n        int x=l,y=mid+1,k=0;//左半边区间是l到mid 右边区间是mid+1到r\n        int []temp=new int[r-l+1];\n        while(x\u003c=mid||y\u003c=r){\n            if(y\u003er||x\u003c=mid\u0026\u0026arr[x]\u003c=arr[y]){\n                temp[k++]=arr[x++];\n            }else{\n                temp[k++]=arr[y++];\n                cnt+=(mid-x+1);//归并排序天然后就是创造逆序对和正序对的结构\n            }\n        }\n        for(int i=l;i\u003c=r;i++)arr[i]=temp[i-l];\n        return;\n    }\n    public int reversePairs(int[] nums) {\n      mergeSort(nums,0,nums.length-1);\n      return cnt;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161951-q8x3874","Type":"NodeParagraph","Properties":{"id":"20230817161951-q8x3874","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"合并n个有序链表（使用小顶堆加速选择）"}]},{"ID":"20230817161952-7xrsa7c","Type":"NodeParagraph","Properties":{"id":"20230817161952-7xrsa7c","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"给你一个链表数组，每个链表都已经按升序排列。"}]},{"ID":"20230817161953-hqq2s9h","Type":"NodeParagraph","Properties":{"id":"20230817161953-hqq2s9h","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"请你将所有链表合并到一个升序链表中，返回合并后的链表。"}]},{"ID":"20230817161954-7ri4c17","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161954-7ri4c17","updated":"20230817161954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n   PriorityQueue\u003cListNode\u003e q=new PriorityQueue\u003cListNode\u003e(new Comparator\u003cListNode\u003e(){\n     public int compare(ListNode l1,ListNode l2){\n       return l1.val-l2.val;\n     }\n   });\n    public ListNode mergeKLists(ListNode[] lists) {\n       for(ListNode node:lists){\n         if(node!=null)q.offer(node);\n       }\n       ListNode dumpy=new ListNode(0);\n       ListNode tail=dumpy;\n       while(!q.isEmpty()){\n        ListNode top= q.poll();\n          tail.next=top;\n          tail=tail.next;\n          if(top.next!=null){\n           q.offer(top.next);\n          }\n       }\n       return dumpy.next;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161955-nsqtilf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161955-nsqtilf","updated":"20230817161955"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/7WHec2/","TextMarkTextContent":"剑指 Offer II 077. 链表排序"}]},{"ID":"20230817161956-86pkbph","Type":"NodeParagraph","Properties":{"id":"20230817161956-86pkbph","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"难度中等35"}]},{"ID":"20230817161957-36alaxr","Type":"NodeParagraph","Properties":{"id":"20230817161957-36alaxr","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"给定链表的头结点 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"head"},{"Type":"NodeText","Data":" ，请将其按 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"升序"},{"Type":"NodeText","Data":" 排列并返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"排序后的链表"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161958-2evlmu7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161958-2evlmu7","updated":"20230817161958"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n   public ListNode mergeSort(ListNode head,int n){//归并解法\n     if(head==null||head.next==null)return head;\n     int l=n/2,r=n-l;\n     ListNode lhead=head,rhead=head;\n     for(int i=0;i\u003cl-1;i++){\n       rhead=rhead.next;\n     }\n     ListNode q=rhead;\n     rhead=rhead.next;\n     q.next=null;\n     lhead=mergeSort(lhead,l);\n     rhead=mergeSort(rhead,r);\n     ListNode dumpy=new ListNode(0);\n     ListNode tail=dumpy;\n     while(lhead!=null||rhead!=null){\n       if(rhead==null||lhead!=null\u0026\u0026lhead.val\u003crhead.val){\n         tail.next=lhead;\n         tail=tail.next;\n         lhead=lhead.next;\n       }else{\n         tail.next=rhead;\n         tail=tail.next;\n         rhead=rhead.next;\n       }\n     }\n    return dumpy.next;\n   }\n    public ListNode sortList(ListNode head) {\n        int n=0;\n        ListNode cur=head;\n        while(cur!=null){\n          n++;\n          cur=cur.next;\n        }\n        return mergeSort(head,n);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161959-du78o82","Type":"NodeParagraph","Properties":{"id":"20230817161959-du78o82","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"快排解法："}]},{"ID":"20230817161960-d8sqtyb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161960-d8sqtyb","updated":"20230817161960"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n      if(head==null)return head;\n       int minvalue=head.val,maxvalue=head.val;\n       double midvalue=0;\n       ListNode p=head;\n       ListNode q1=null,q2=null;\n       while(p!=null){\n         minvalue=Math.min(minvalue,p.val);\n         maxvalue=Math.max(maxvalue,p.val);\n         p=p.next;\n       }\n       if(minvalue==maxvalue)return head;\n       midvalue=(minvalue+maxvalue)/2.0;\n       p=head;\n       ListNode q;\n       while(p!=null){\n         q=p.next;\n         if(p.val\u003cmidvalue){\n           p.next=q1;\n           q1=p;\n          }else{\n          p.next=q2;\n          q2=p;\n         }\n         p=q;\n       }\n      q1=sortList(q1);\n      q2=sortList(q2);\n      ListNode cur=q1;\n      while(cur.next!=null){\n        cur=cur.next;\n      }\n      cur.next=q2;\n      return q1;\n\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161961-nvplq1j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161961-nvplq1j","updated":"20230817161961"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/count-of-range-sum/","TextMarkTextContent":"327. 区间和的个数"}]},{"ID":"20230817161962-ago4qe7","Type":"NodeParagraph","Properties":{"id":"20230817161962-ago4qe7","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"难度困难411"}]},{"ID":"20230817161963-wac154j","Type":"NodeParagraph","Properties":{"id":"20230817161963-wac154j","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 以及两个整数 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lower"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"upper"},{"Type":"NodeText","Data":" 。求数组中，值位于范围 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"[lower, upper]"},{"Type":"NodeText","Data":" （包含 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"lower"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"upper"},{"Type":"NodeText","Data":"）之内的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区间和的个数"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20230817161964-gsnko3o","Type":"NodeParagraph","Properties":{"id":"20230817161964-gsnko3o","updated":"20230817161964"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"区间和"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"S(i, j)"},{"Type":"NodeText","Data":" 表示在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" 中，位置从 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 到 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"j"},{"Type":"NodeText","Data":" 的元素之和，包含 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"j"},{"Type":"NodeText","Data":" ("},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i"},{"Type":"NodeText","Data":" ≤ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"j"},{"Type":"NodeText","Data":")。"}]},{"ID":"20230817161965-xi1515q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161965-xi1515q","updated":"20230817161965"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n  //借助于归并排序两个数组的有序性来加速求解\n    public int countRangeSum(int[] nums, int lower, int upper) {\n     long [] presum=new long[nums.length+1];\n     presum[0]=0;\n     for(int i=0;i\u003cnums.length;i++){\n       presum[i+1]=presum[i]+nums[i];\n     }\n     return mergeSort(presum,0,presum.length-1,lower,upper);\n    }\n    public int mergeSort(long []nums,int l,int r,int lower,int upper){\n       if(l\u003e=r)return 0;\n       int mid=(l+r)\u003e\u003e1;\n       int ans=0;\n       ans+=mergeSort(nums,l,mid,lower,upper);\n       ans+=mergeSort(nums,mid+1,r,lower,upper);\n       ans+=merge(nums,l,mid,mid+1,r,lower,upper);\n       int x=l,y=mid+1;\n       int k=0;\n       long [] temp=new long[r-l+1];\n       while(x\u003c=mid||y\u003c=r){\n         if(y\u003er||x\u003c=mid\u0026\u0026nums[x]\u003c=nums[y]){\n          temp[k++]=nums[x++];\n         }else{\n           temp[k++]=nums[y++];\n         }\n       }\n       for(int i=l;i\u003c=r;i++)nums[i]=temp[i-l];\n       return ans;\n    }\n    public int merge(long []nums,int l1,int r1,int l2,int r2,int lower,int upper){\n       int k1=l1,k2=l1;\n       int ans=0;\n       for(int j=l2;j\u003c=r2;j++){\n          long a=nums[j]-upper;\n          long b=nums[j]-lower;\n          while(k1\u003c=r1\u0026\u0026nums[k1]\u003ca)k1++;//注意这两个指针有可能找不到对应的值 所以最好错开找 能有效均衡\n          while(k2\u003c=r1\u0026\u0026nums[k2]\u003c=b)k2++;\n          ans+=(k2-k1);      \n       } \n      return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161966-nlzf28e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161966-nlzf28e","updated":"20230817161966"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/","TextMarkTextContent":"315. 计算右侧小于当前元素的个数"}]},{"ID":"20230817161967-zx8oxkp","Type":"NodeParagraph","Properties":{"id":"20230817161967-zx8oxkp","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"难度困难758"}]},{"ID":"20230817161968-ke7x0hy","Type":"NodeParagraph","Properties":{"id":"20230817161968-ke7x0hy","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums"},{"Type":"NodeText","Data":" ，按要求返回一个新数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counts"},{"Type":"NodeText","Data":" 。数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counts"},{"Type":"NodeText","Data":" 有该性质： "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"counts[i]"},{"Type":"NodeText","Data":" 的值是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums[i]"},{"Type":"NodeText","Data":" 右侧小于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"nums[i]"},{"Type":"NodeText","Data":" 的元素的数量。"}]},{"ID":"20230817161969-99w93hu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-99w93hu","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Solution {\n\n  public void mergeSort(Data []arr,int l,int r){\n     if(l\u003e=r)return;\n     int mid=(l+r)\u003e\u003e1;\n     mergeSort(arr,l,mid);\n     mergeSort(arr,mid+1,r);\n     int x=l,y=mid+1;\n     Data []temp=new Data[r-l+1];\n     int k=0;\n     while(x\u003c=mid||y\u003c=r){\n       if(y\u003er||x\u003c=mid\u0026\u0026arr[x].compareTo(arr[y])\u003e0){\n         arr[x].cnt+=(r-y+1);\n         temp[k++]=arr[x++];\n       }else{\n         temp[k++]=arr[y++];\n     }\n     }\n      for(int i=l;i\u003c=r;i++)arr[i]=temp[i-l];\n      return ;\n\n  }\n    public List\u003cInteger\u003e countSmaller(int[] nums) {//将结果封装在data数据中 方便对多个状态的管理\n       Data []arr=new Data[nums.length];\n       for(int i=0;i\u003carr.length;i++){\n         arr[i]=new Data(nums[i],i);\n       }\n       mergeSort(arr,0,arr.length-1);\n       Integer [] ans=new Integer[nums.length];\n       for(Data data:arr){\n         ans[data.index]=data.cnt;\n       }\n       return Arrays.asList(ans);\n    }\n}\nclass Data implements Comparable\u003cData\u003e {\n   int val;\n   int index;\n   int cnt;\n   public Data(int val ,int index){\n     this.val=val;\n     this.index=index;\n   }\n   public int compareTo(Data data){\n     return this.val-data.val;\n   }\n }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}