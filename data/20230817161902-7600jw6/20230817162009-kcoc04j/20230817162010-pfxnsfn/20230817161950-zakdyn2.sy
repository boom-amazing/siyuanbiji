{"ID":"20230817161950-zakdyn2","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161950-zakdyn2","title":"单调队列","updated":"20230817161950"},"Children":[{"ID":"20230817161951-ps8a0jp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161951-ps8a0jp","updated":"20230817161951"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"单调队列"}]},{"ID":"20230817161952-kjxt6jn","Type":"NodeParagraph","Properties":{"id":"20230817161952-kjxt6jn","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"可以以o(1）的时间复杂度得到单调队列的最大值和最小值 能够解决滑动窗口内的最值问题"}]},{"ID":"20230817161953-hwsqjmu","Type":"NodeParagraph","Properties":{"id":"20230817161953-hwsqjmu","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"剑指offer59：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。"}]},{"ID":"20230817161954-epec9eh","Type":"NodeParagraph","Properties":{"id":"20230817161954-epec9eh","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"若队列为空，pop_front 和 max_value 需要返回 -1"}]},{"ID":"20230817161955-jm7tv60","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161955-jm7tv60","updated":"20230817161955"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class MaxQueue {\n     LinkedList\u003cInteger\u003e q=new LinkedList\u003c\u003e();//记录当前队列\n    LinkedList\u003cInteger\u003e mq=new LinkedList\u003c\u003e();//记录当前队列的最大值\n    public MaxQueue() {\n\n    }\n\n    public int max_value() {\n    if(q.size()==0)return -1;\n    return mq.peekFirst();\n    }\n\n    public void push_back(int value) {\n      while ((!mq.isEmpty())\u0026\u0026(value\u003emq.getLast()))mq.pollLast();\n      mq.offerLast(value);\n      q.offerLast(value);\n         return;\n    }\n\n    public int pop_front() {\n     if(q.isEmpty())return -1;\n     if(q.peekFirst().equals(mq.peekFirst()))mq.pollFirst();//如果队列的最大值与当前值 相同 需要弹出mq的首部 有个坑这里需要用equals 而不是==\n     int ans=q.peekFirst();\n     q.pollFirst();\n     return ans;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161956-fvzvjja","Type":"NodeParagraph","Properties":{"id":"20230817161956-fvzvjja","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"LC239：滑动窗口的最值问题"}]},{"ID":"20230817161957-hjmug28","Type":"NodeParagraph","Properties":{"id":"20230817161957-hjmug28","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。"}]},{"ID":"20230817161958-8e9a4r6","Type":"NodeParagraph","Properties":{"id":"20230817161958-8e9a4r6","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"返回滑动窗口中的最大值。"}]},{"ID":"20230817161959-ezyyarz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161959-ezyyarz","updated":"20230817161959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque\u003cInteger\u003e deque=new LinkedList\u003c\u003e();\n        ArrayList\u003cInteger\u003e ans = new ArrayList\u003c\u003e();\n        for (int i = 0; i \u003c nums.length; i++) {\n            while (!deque.isEmpty()\u0026\u0026nums[deque.getLast()]\u003cnums[i])deque.pollLast();//更新单调队列的最值\n            deque.offerLast(i);\n            if(i-deque.getFirst()+1\u003ek)deque.pollFirst();//如果滑动窗口大小超过k 就需要从首部弹出元素\n            ans.add(deque.getFirst());\n        }\n       return ans.stream().mapToInt(i-\u003ei).toArray();\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161960-otu6np7","Type":"NodeParagraph","Properties":{"id":"20230817161960-otu6np7","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"LC862："}]},{"ID":"20230817161961-pelgeh7","Type":"NodeParagraph","Properties":{"id":"20230817161961-pelgeh7","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。"}]},{"ID":"20230817161962-1lmf8r5","Type":"NodeParagraph","Properties":{"id":"20230817161962-1lmf8r5","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"子数组 是数组中 连续 的一部分。"}]},{"ID":"20230817161963-g8f65c1","Type":"NodeParagraph","Properties":{"id":"20230817161963-g8f65c1","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"思路：因为找的是连续子数组的和 所以可以想到用前缀和进行处理 因为我们希望和尽可能的大 所以用一个单调队列维护当前队列里的最小值 来使每次加入元素与当前值的差更大 如果当我们找到一个满足条件的值 我们有希望当前找到的子数组的长度尽可能的小 所以当找到一个满足条件的值 我们对队列进行弹出 继续寻找更小的值"}]},{"ID":"20230817161964-fzdseiq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161964-fzdseiq","updated":"20230817161964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"  public int shortestSubarray(int[] nums, int k) {\n        LinkedList\u003cInteger\u003e list=new LinkedList\u003c\u003e();\n        long []presum=new long[nums.length+1];\n        presum[0]=0;\n        for (int i = 0; i \u003cnums.length ; i++) {\n             presum[i+1]=presum[i]+(long)nums[i];//处理前缀和\n        }\n        int ans=nums.length+1;\n        for (int i = 0; i \u003c presum.length; i++) {\n          while (!list.isEmpty()\u0026\u0026presum[list.peekLast()]\u003e=presum[i])list.pollLast();\n          list.offerLast(i);//更新单调队列\n            while (!list.isEmpty()\u0026\u0026presum[i]-presum[list.peekFirst()]\u003e=k){\n                ans=Math.min(ans,i-list.pollFirst());//得到满足条件的答案 如果已经找到就将其弹出 继续往后寻找来使子数组的数组长度变小\n            }\n        }\n     return ans\u003cnums.length+1? ans:-1;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161965-wsijpqk","Type":"NodeParagraph","Properties":{"id":"20230817161965-wsijpqk","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"LC1438："}]},{"ID":"20230817161966-p5im3db","Type":"NodeParagraph","Properties":{"id":"20230817161966-p5im3db","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。"}]},{"ID":"20230817161967-songlk6","Type":"NodeParagraph","Properties":{"id":"20230817161967-songlk6","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"如果不存在满足条件的子数组，则返回 0 。"}]},{"ID":"20230817161968-zzaumjp","Type":"NodeParagraph","Properties":{"id":"20230817161968-zzaumjp","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"思路：因为要使找到的子数组任意两个元素必须小于或等于limit 我们只需要满足最大值与最小值的差值小于等于limit即可 我们可以维护两个单调队列 一个单调递增 一个单调递减来获取最小值与最大值 同时我们可以利用滑动窗口来维持区间的变化"}]},{"ID":"20230817161969-xf3n7kw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-xf3n7kw","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"  public int longestSubarray(int[] nums, int limit) {\n        Deque\u003cInteger\u003e queMax = new LinkedList\u003cInteger\u003e();\n        Deque\u003cInteger\u003e queMin = new LinkedList\u003cInteger\u003e();\n        int n = nums.length;\n        int left = 0, right = 0;\n        int ret = 0;\n        while (right \u003c n) {\n            while (!queMax.isEmpty() \u0026\u0026 queMax.peekLast() \u003c nums[right]) {\n                queMax.pollLast();\n            }\n            while (!queMin.isEmpty() \u0026\u0026 queMin.peekLast() \u003e nums[right]) {\n                queMin.pollLast();\n            }\n            queMax.offerLast(nums[right]);\n            queMin.offerLast(nums[right]);//更新两个单调队列\n            while (!queMax.isEmpty() \u0026\u0026 !queMin.isEmpty() \u0026\u0026 queMax.peekFirst() - queMin.peekFirst() \u003e limit) {//在固定右边界的同时来调整左边界 通过弹出两个队列的元素 来使结果尽可能的满足条件\n                if (nums[left] == queMin.peekFirst()) {\n                    queMin.pollFirst();\n                }\n                if (nums[left] == queMax.peekFirst()) {\n                    queMax.pollFirst();\n                }\n                left++;//注意这个left不能置0 因为在left之前的都已经通过ret统计过了\n            }\n            ret = Math.max(ret, right - left + 1);//更新结果\n            right++;//右边界向右拓展\n        }\n        return ret;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}