{"ID":"20230817161951-h275hxc","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161951-h275hxc","title":"checkpoint","updated":"20230817161951"},"Children":[{"ID":"20230817161952-1ie57ae","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161952-1ie57ae","updated":"20230817161952"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"checkpoint"}]},{"ID":"20230817161953-yvjy97c","Type":"NodeParagraph","Properties":{"id":"20230817161953-yvjy97c","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"checkpoint的功能："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"1、checkpoint的写操作"}]},{"ID":"20230817161954-djnrg88","Type":"NodeParagraph","Properties":{"id":"20230817161954-djnrg88","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"将指定的RDD的数据通过checkpoint存储到指定的外部存储中"}]},{"ID":"20230817161955-4422zui","Type":"NodeParagraph","Properties":{"id":"20230817161955-4422zui","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"2、checkpoint的读操作"}]},{"ID":"20230817161956-qjlsszs","Type":"NodeParagraph","Properties":{"id":"20230817161956-qjlsszs","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"任务中的RDD数据在使用过程中丢失了 ，正好这个RDD之前做过checkpoint 所以这时需要通过checkpoint来恢复数据"}]},{"ID":"20230817161957-6drhh5y","Type":"NodeParagraph","Properties":{"id":"20230817161957-6drhh5y","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"写操作的过程分析："}]},{"ID":"20230817161958-vg3px9l","Type":"NodeParagraph","Properties":{"id":"20230817161958-vg3px9l","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"1：SparkContext设置checkpoint目录，用于存放checkpoint的数据；"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"对RDD调用checkpoint方法，然后它就会被RDDCheckpointData对象进行管理，此时这个RDD的checkpoint状态会被设置为Initialized"}]},{"ID":"20230817161959-jjvr7uj","Type":"NodeParagraph","Properties":{"id":"20230817161959-jjvr7uj","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"2：待RDD所在的job运行结束，会调用job中最后一个RDD的doCheckpoint方法，该方法沿着RDD的血缘关系向上查找被checkpoint()方法标记过的RDD，并将其checkpoint状态从Initialized设置为CheckpointingInProgress"}]},{"ID":"20230817161960-7sh1xix","Type":"NodeParagraph","Properties":{"id":"20230817161960-7sh1xix","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"3：启动一个单独的job，来将血缘关系中标记为CheckpointInProgress的RDD执行checkpoint操作，也就是将其数据写入checkpoint目录"}]},{"ID":"20230817161961-ql804nb","Type":"NodeParagraph","Properties":{"id":"20230817161961-ql804nb","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"4：将RDD数据写入checkpoint目录之后，会将RDD状态改变为Checkpointed；"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"并且还会改变RDD的血缘关系，即会清除掉RDD所有依赖的RDD；"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"最后还会设置其父RDD为新创建的CheckpointRDD"}]},{"ID":"20230817161962-n0hgqi6","Type":"NodeParagraph","Properties":{"id":"20230817161962-n0hgqi6","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"读操作过程分析："}]},{"ID":"20230817161963-j7n7ebw","Type":"NodeParagraph","Properties":{"id":"20230817161963-j7n7ebw","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"当RDD中的数据丢失了以后，需要通过checkpoint读取存储在hdfs上的数据，"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"2.1：这个时候还是会执行RDD中的iterator方法"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"由于我们没有做持久化，只做了checkpoint，所以还是会走"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"else"}]},{"ID":"20230817161964-fjrzzd2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161964-fjrzzd2","updated":"20230817161964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final def iterator(split: Partition, context: TaskContext): Iterator[T] = {\n  //如果StorageLevel不为空，表示该RDD已经持久化过了,可能是在内存，也有可能是在磁盘\n  if (storageLevel != StorageLevel.NONE) {\n    //直接从持久化存储中读取或者计算(如果数据丢失)\n    getOrCompute(split, context)\n  } else {\n    //进行rdd partition的计算或者从checkpoint中读取数据\n    computeOrReadCheckpoint(split, context)\n  }\n}\n代码块12345678910\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161965-xb25zaw","Type":"NodeParagraph","Properties":{"id":"20230817161965-xb25zaw","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"进入"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"computeOrReadCheckpoint"},{"Type":"NodeText","Data":"方法"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"此时rdd已经"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"checkpoint"},{"Type":"NodeText","Data":"并且物化，所以"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"if"},{"Type":"NodeText","Data":"分支满足"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"firstParent[T].iterator(split, context)"},{"Type":"NodeText","Data":"这行代码"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这行代码的意思是会找到当前这个RDD的父RDD，其实这个RDD执行过checkpoint之后，血缘关系已经被切断了，它的父RDD就是我们前面创建的那个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReliableCheckpointRDD"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReliableCheckpointRDD"},{"Type":"NodeText","Data":"中没有覆盖"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iterator"},{"Type":"NodeText","Data":"方法，所以在调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iterator"},{"Type":"NodeText","Data":"的时候还是执行RDD这个父类中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"iterator"},{"Type":"NodeText","Data":"，重新进来之后再判断，这个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReliableCheckpointRDD"},{"Type":"NodeText","Data":"再执行if判断的时候就不满足了，因为它的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"checkpoint"},{"Type":"NodeText","Data":"属性不满足，所以会走"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"else"},{"Type":"NodeText","Data":"，执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compute"}]},{"ID":"20230817161966-941f37n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161966-941f37n","updated":"20230817161966"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private[spark] def computeOrReadCheckpoint(split: Partition, context: TaskContext): Iterator[T] =\n{\n  //当前rdd是否已经checkpoint并且物化，如果已经checkpoint并且物化\n  //则调用firstParent的iterator方法获取\n  if (isCheckpointedAndMaterialized) {\n    //注意：针对checpoint操作，它的血缘关系已经被切断了，那么它的firstParent就是前面创建的CheckpointRDD\n    firstParent[T].iterator(split, context)\n  } else {\n    //如果没有，则表示持久化数据丢失，或者根本就没有持久化，\n    //需要调用rdd的compute方法开始重新计算，返回一个Iterator对象\n    compute(split, context)\n  }\n}\n代码块12345678910111213\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161967-0lp3z1e","Type":"NodeParagraph","Properties":{"id":"20230817161967-0lp3z1e","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"此时会执行"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ReliableCheckpointRDD"},{"Type":"NodeText","Data":"这个子类中的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"compute"},{"Type":"NodeText","Data":"方法"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这里面就会找到之前checkpoint的文件，从HDFS上恢复RDD中的数据。"}]},{"ID":"20230817161968-ayd95o8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161968-ayd95o8","updated":"20230817161968"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"override def compute(split: Partition, context: TaskContext): Iterator[T] = {\n  //获取checkpoint文件\n  val file = new Path(checkpointPath, ReliableCheckpointRDD.checkpointFileName(split.index))\n  //从HDFS上的checkpoint文件中读取checkpoint的数据\n  ReliableCheckpointRDD.readCheckpointFile(file, broadcastedConf, context)\n}\n代码块123456\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161969-638wbhg","Type":"NodeParagraph","Properties":{"id":"20230817161969-638wbhg","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"这是从checkpoint中读取数据的流程"}]}]}