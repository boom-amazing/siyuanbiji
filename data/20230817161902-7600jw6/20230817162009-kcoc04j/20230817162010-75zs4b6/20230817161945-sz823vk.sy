{"ID":"20230817161945-sz823vk","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161945-sz823vk","title":"RDD持久化原理","updated":"20230817161945"},"Children":[{"ID":"20230817161946-mwjnjib","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161946-mwjnjib","updated":"20230817161946"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"RDD持久化原理"}]},{"ID":"20230817161947-ndeqali","Type":"NodeParagraph","Properties":{"id":"20230817161947-ndeqali","updated":"20230817161947"},"Children":[{"Type":"NodeText","Data":"Spark中有一个非常重要的功能就是可以对RDD进行持久化。当对RDD执行持久化操作时，每个节点都会将自己操作的RDD的partition数据持久化到内存中，并且在之后对该RDD的反复使用中，直接使用内存中缓存的partition数据。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这样的话，针对一个RDD反复执行多个操作的场景，就只需要对RDD计算一次即可，后面直接使用该RDD，而不需要反复计算多次该RDD。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因为正常情况下这个RDD的数据使用过后内存中是不会一直保存的。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"例如这样的操作：针对mapRDD需要多次使用的"}]},{"ID":"20230817161948-fjh8cna","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161948-fjh8cna","updated":"20230817161948"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"val dataRDD = sc.parallelize(Array(1,2,3,4,5))\nval mapRDD = dataRDD.map(...)\nmapRDD.foreach(...)\nmapRDD.saveAsTextFile(...)\nmapRDD.collect()\n代码块12345\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161949-futd5up","Type":"NodeParagraph","Properties":{"id":"20230817161949-futd5up","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"巧妙使用RDD持久化，在某些场景下，对spark应用程序的性能有很大提升。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"特别是对于迭代式算法和快速交互式应用来说，RDD持久化，是非常重要的。"}]},{"ID":"20230817161950-kf9jkhl","Type":"NodeParagraph","Properties":{"id":"20230817161950-kf9jkhl","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"要持久化一个RDD，只需要调用它的cache()或者persist()方法就可以了。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"在该RDD第一次被计算出来时，就会直接缓存在每个节点中。而且Spark的持久化机制还是自动容错的，如果持久化的RDD的任何partition数据丢失了，那么Spark会自动通过其源RDD，使用transformation算子重新计算该partition的数据。"}]},{"ID":"20230817161951-465254m","Type":"NodeParagraph","Properties":{"id":"20230817161951-465254m","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"cache()和persist()的区别在于："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"cache()是persist()的一种简化方式，cache()的底层就是调用的persist()的无参版本，也就是调用persist(MEMORY_ONLY)，将数据持久化到内存中。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"如果需要从内存中清除缓存，那么可以使用unpersist()方法。"}]},{"ID":"20230817161952-xa7v8vl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161952-xa7v8vl","updated":"20230817161952"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"RDD持久化策略"}]},{"ID":"20230817161953-vezgeph","Type":"NodeParagraph","Properties":{"id":"20230817161953-vezgeph","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"下面看一下目前Spark支持的一些持久化策略"}]},{"ID":"20230817161954-s0vxjhv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161954-s0vxjhv","updated":"20230817161954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"策略\t\t\t\t\t介绍\nMEMORY_ONLY\t\t\t以非序列化的方式持久化在JVM内存中\nMEMORY_AND_DISK\t\t同上，但是当某些partition无法存储在内存中时，会持久化到磁盘中\nMEMORY_ONLY_SER\t\t同MEMORY_ONLY，但是会序列化\nMEMORY_AND_DISK_SER\t同MEMORY_AND_DSK，但是会序列化\nDISK_ONLY\t\t\t以非序列化的方式完全存储到磁盘上\nMEMORY_ONLY_2、MEMORY_AND_DISK_2等\t尾部加了2的持久化级别，表示会将持久化数据复制一份，保存到其他节点\n代码块1234567\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161955-ynymjm8","Type":"NodeParagraph","Properties":{"id":"20230817161955-ynymjm8","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"补充说明："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"MEMORY_ONLY：以非序列化的Java对象的方式持久化在JVM内存中。如果内存无法完全存储RDD所有的partition，那么那些没有持久化的partition就会在下一次需要使用它的时候，重新被计算。"}]},{"ID":"20230817161956-zuejvwv","Type":"NodeParagraph","Properties":{"id":"20230817161956-zuejvwv","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"MEMORY_AND_DISK：当某些partition无法存储在内存中时，会持久化到磁盘中。下次需要使用这些partition时，需要从磁盘上读取，不需要重新计算"}]},{"ID":"20230817161957-ap33063","Type":"NodeParagraph","Properties":{"id":"20230817161957-ap33063","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"MEMORY_ONLY_SER：同MEMORY_ONLY，但是会使用Java的序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是在使用的时候需要进行反序列化，因此会增加CPU开销。"}]},{"ID":"20230817161958-1n92clv","Type":"NodeParagraph","Properties":{"id":"20230817161958-1n92clv","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"MEMORY_AND_DISK_SER：同MEMORY_AND_DSK。但是会使用序列化方式持久化Java对象。"}]},{"ID":"20230817161959-krombvv","Type":"NodeParagraph","Properties":{"id":"20230817161959-krombvv","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"DISK_ONLY：使用非序列化Java对象的方式持久化，完全存储到磁盘上。"}]},{"ID":"20230817161960-boy4bk5","Type":"NodeParagraph","Properties":{"id":"20230817161960-boy4bk5","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"MEMORY_ONLY_2、MEMORY_AND_DISK_2等：如果是尾部加了2的持久化级别，表示会将持久化数据复制一份，保存到其它节点，从而在数据丢失时，不需要重新计算，只需要使用备份数据即可。"}]},{"ID":"20230817161961-8hjflbc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161961-8hjflbc","updated":"20230817161961"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"如何选择RDD持久化策略"}]},{"ID":"20230817161962-7ri4pl6","Type":"NodeParagraph","Properties":{"id":"20230817161962-7ri4pl6","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"Spark提供了多种持久化级别，主要是为了在CPU和内存消耗之间进行取舍。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"下面是一些通用的持久化级别的选择建议："}]},{"ID":"20230817161963-fa5bzml","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230817161963-fa5bzml","updated":"20230817161963"},"Children":[{"ID":"20230817161964-e4xryih","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20230817161964-e4xryih","updated":"20230817161964"},"Children":[{"ID":"20230817161965-md2oy8g","Type":"NodeParagraph","Properties":{"id":"20230817161965-md2oy8g","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"优先使用MEMORY_ONLY，纯内存速度最快，而且没有序列化不需要消耗CPU进行反序列化操作，缺点就是比较耗内存"}]}]},{"ID":"20230817161966-r3ho4cp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20230817161966-r3ho4cp","updated":"20230817161966"},"Children":[{"ID":"20230817161967-04k41j1","Type":"NodeParagraph","Properties":{"id":"20230817161967-04k41j1","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"MEMORY_ONLY_SER，将数据进行序列化存储，纯内存操作还是非常快，只是在使用的时候需要消耗CPU进行反序列化"}]}]}]},{"ID":"20230817161968-beudy5e","Type":"NodeBlockquote","Properties":{"id":"20230817161968-beudy5e","updated":"20230817161968"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161969-ysww00k","Type":"NodeParagraph","Properties":{"id":"20230817161969-ysww00k","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"如果需要进行数据的快速失败恢复，那么就选择带后缀为_2的策略，进行数据的备份，这样在失败时，就不需要重新计算了"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"能不使用DISK相关的策略，就不要使用，因为有的时候，从磁盘读取数据，还不如重新计算一次。"}]}]}]}