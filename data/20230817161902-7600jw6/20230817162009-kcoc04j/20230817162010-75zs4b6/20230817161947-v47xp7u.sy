{"ID":"20230817161947-v47xp7u","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161947-v47xp7u","title":"宽依赖和窄依赖","updated":"20230817161947"},"Children":[{"ID":"20230817161948-k7ldds5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161948-k7ldds5","updated":"20230817161948"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"宽依赖和窄依赖"}]},{"ID":"20230817161949-k2kfupi","Type":"NodeParagraph","Properties":{"id":"20230817161949-k2kfupi","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"先看一下什么是窄依赖："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"窄依赖(Narrow Dependency)：指父RDD的每个分区只被子RDD的一个分区所使用，例如map、filter等这些算子"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"一个RDD，对它的父RDD只有简单的一对一的关系，也就是说，RDD的每个partition仅仅依赖于父RDD中的一个partition，父RDD和子RDD的partition之间的对应关系，是一对一的。"}]},{"ID":"20230817161950-8mnjfde","Type":"NodeParagraph","Properties":{"id":"20230817161950-8mnjfde","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"宽依赖(Shuffle Dependency)：父RDD的每个分区都可能被子RDD的多个分区使用，例如groupByKey、reduceByKey，sortBykey等算子，这些算子其实都会产生shuffle操作"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"也就是说，每一个父RDD的partition中的数据都可能会传输一部分到下一个RDD的每个partition中。此时就会出现，父RDD和子RDD的partition之间，具有错综复杂的关系，那么，这种情况就叫做两个RDD之间是宽依赖，同时，他们之间会发生shuffle操作。"}]},{"ID":"20230817161951-bqq3imr","Type":"NodeParagraph","Properties":{"id":"20230817161951-bqq3imr","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"下面来看图具体分析一个案例"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"以单词计数案例来分析"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图片描述","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img.mukewang.com/wiki/5f564448098b643615930698.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161952-y5is886","Type":"NodeParagraph","Properties":{"id":"20230817161952-y5is886","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"最左侧是linesRDD，这个表示我们通过textFile读取文件中的数据之后获取的RDD"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"接着是我们使用flatMap算子，对每一行数据按照空格切开，然后可以获取到第二个RDD，这个RDD中包含的是切开的每一个单词"}]},{"ID":"20230817161953-ovo7omk","Type":"NodeParagraph","Properties":{"id":"20230817161953-ovo7omk","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"在这里这两个RDD就属于一个窄依赖，因为父RDD的每个分区只被子RDD的一个分区所使用，也就是说他们的分区是一对一的，这样就不需要经过shuffle了。"}]},{"ID":"20230817161954-jg9we9c","Type":"NodeParagraph","Properties":{"id":"20230817161954-jg9we9c","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"接着是使用map算子，将每一个单词转换成(单词,1)这种形式，"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"此时这两个RDD也是一个窄依赖的关系，父RDD的分区和子RDD的分区也是一对一的"}]},{"ID":"20230817161955-fbft5pv","Type":"NodeParagraph","Properties":{"id":"20230817161955-fbft5pv","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"最后我们会调用reduceByKey算子，此时会对相同key的数据进行分组，分到一个分区里面，并且进行聚合操作，此时父RDD的每个分区都可能被子RDD的多个分区使用，那这两个RDD就属于宽依赖了。"}]},{"ID":"20230817161956-2fx95lq","Type":"NodeParagraph","Properties":{"id":"20230817161956-2fx95lq","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"这就是宽窄依赖的区别，那我们在这区分宽窄依赖有什么意义吗？"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"不要着急，往下面看"}]},{"ID":"20230817161957-cg3boxs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161957-cg3boxs","updated":"20230817161957"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Stage"}]},{"ID":"20230817161958-9ydaeaj","Type":"NodeParagraph","Properties":{"id":"20230817161958-9ydaeaj","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"spark job是根据action算子触发的,遇到action算子就会起一个job"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"Spark Job会被划分为多个Stage，每一个Stage是由一组并行的Task组成的"}]},{"ID":"20230817161959-0ks4crl","Type":"NodeBlockquote","Properties":{"id":"20230817161959-0ks4crl","updated":"20230817161959"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161960-ixusyyy","Type":"NodeParagraph","Properties":{"id":"20230817161960-ixusyyy","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"注意：stage的划分依据就是看是否产生了shuflle(即宽依赖),遇到一个shuffle操作就划分为前后两个stage"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"stage是由一组并行的task组成，stage会将一批task用TaskSet来封装，提交给TaskScheduler进行分配，最后发送到Executor执行"}]}]},{"ID":"20230817161961-96w5qu4","Type":"NodeParagraph","Properties":{"id":"20230817161961-96w5qu4","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"下面来看一张图来具体分析一下"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图片描述","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img.mukewang.com/wiki/5f56445c098ad47a16430906.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161962-r5g044q","Type":"NodeBlockquote","Properties":{"id":"20230817161962-r5g044q","updated":"20230817161962"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161963-9vz6ki0","Type":"NodeParagraph","Properties":{"id":"20230817161963-9vz6ki0","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"注意：Stage的划分规则：从后往前，遇到宽依赖就划分Stage"}]}]},{"ID":"20230817161964-3smwams","Type":"NodeParagraph","Properties":{"id":"20230817161964-3smwams","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"为什么是从后往前呢？因为RDD之间是有血缘关系的，后面的RDD依赖前面的RDD，也就是说后面的RDD要等前面的RDD执行完,才会执行。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"所以从后往前遇到宽依赖就划分为两个stage，shuffle前一个,shuffle后一个。如果整个过程没有产生shuffle那就只会有一个stage"}]},{"ID":"20230817161965-gbr4xw6","Type":"NodeParagraph","Properties":{"id":"20230817161965-gbr4xw6","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"看这个图"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"RDD G 往前推，到RDD B的时候，是窄依赖，所以不切分Stage，再往前到RDD A，此时产生了宽依赖，所以RDD A属于一个Stage、RDD B 和 G属于一个Stage"}]},{"ID":"20230817161966-avyuel6","Type":"NodeParagraph","Properties":{"id":"20230817161966-avyuel6","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"再看下面，RDD G到RDD F，产生了宽依赖，所以RDD F属于一个Stage，因为RDD F和 RDD C、D、E这几个RDD没有产生宽依赖，都是窄依赖，所以他们属于一个Stage。"}]},{"ID":"20230817161967-xa1ogu4","Type":"NodeParagraph","Properties":{"id":"20230817161967-xa1ogu4","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"所以这个图中,RDD A 单独一个stage1,RDD C、D、E、F被划分在stage2中,"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"最后RDD B和RDD G划分在了stage3 里面."}]},{"ID":"20230817161968-sy0yiv9","Type":"NodeBlockquote","Properties":{"id":"20230817161968-sy0yiv9","updated":"20230817161968"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161969-o3og21d","Type":"NodeParagraph","Properties":{"id":"20230817161969-o3og21d","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"注意：Stage划分是从后往前划分，但是stage执行时从前往后的，这就是为什么后面先切割的stage为什么编号是3."}]}]}]}