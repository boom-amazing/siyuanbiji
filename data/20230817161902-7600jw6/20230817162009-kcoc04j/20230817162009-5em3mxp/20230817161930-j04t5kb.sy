{"ID":"20230817161930-j04t5kb","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161930-j04t5kb","title":"WaterMark引出","updated":"20230817161930"},"Children":[{"ID":"20230817161931-aktj62q","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161931-aktj62q","updated":"20230817161931"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"WaterMark引出"}]},{"ID":"20230817161932-200b5bc","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161932-200b5bc","updated":"20230817161932"},"Children":[{"ID":"20230817161933-66h44he","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161933-66h44he","updated":"20230817161933"},"Children":[{"ID":"20230817161934-dqy6jas","Type":"NodeParagraph","Properties":{"id":"20230817161934-dqy6jas","updated":"20230817161934"},"Children":[{"Type":"NodeText","Data":"实时计算中，数据时间比较敏感。有eventTime和processTime区分，一般来说eventTime是从原始的消息中提取过来的，processTime是Flink自己提供的，Flink中一个亮点就是可以基于eventTime计算，这个功能很有用，因为实时数据可能会经过比较长的链路，多少会有延时，并且有很大的不确定性，对于一些需要精确体现事件变化趋势的场景中，单纯使用processTime显然是不合理的。"}]},{"ID":"20230817161935-r5j4j3j","Type":"NodeParagraph","Properties":{"id":"20230817161935-r5j4j3j","updated":"20230817161935"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https:////upload-images.jianshu.io/upload_images/16969231-596bc925c6692e5f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161936-y7qny6c","Type":"NodeParagraph","Properties":{"id":"20230817161936-y7qny6c","updated":"20230817161936"},"Children":[{"Type":"NodeText","Data":"Flink-eventtime.png"}]}]}]},{"ID":"20230817161937-rjt0kt0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161937-rjt0kt0","updated":"20230817161937"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Flink WaterMark介绍"}]},{"ID":"20230817161938-j5t7rnz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161938-j5t7rnz","updated":"20230817161938"},"Children":[{"ID":"20230817161939-hfyz0up","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161939-hfyz0up","updated":"20230817161939"},"Children":[{"ID":"20230817161940-ri07uyg","Type":"NodeParagraph","Properties":{"id":"20230817161940-ri07uyg","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"watermark是一种衡量Event Time进展的机制，它是数据本身的一个隐藏属性。通常基于Event Time的数据，自身都包含一个timestamp.watermark是用于处理乱序事件的，而正确的处理乱序事件，通常用watermark机制结合window来实现。"}]}]},{"ID":"20230817161941-1dd6vij","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161941-1dd6vij","updated":"20230817161941"},"Children":[{"ID":"20230817161942-3j8bsgb","Type":"NodeParagraph","Properties":{"id":"20230817161942-3j8bsgb","updated":"20230817161942"},"Children":[{"Type":"NodeText","Data":"流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。"}]}]},{"ID":"20230817161943-kl0o0hi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161943-kl0o0hi","updated":"20230817161943"},"Children":[{"ID":"20230817161944-p8lj5f4","Type":"NodeParagraph","Properties":{"id":"20230817161944-p8lj5f4","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"但是对于late element，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark。"}]}]}]},{"ID":"20230817161945-bl3wyww","Type":"NodeParagraph","Properties":{"id":"20230817161945-bl3wyww","updated":"20230817161945"},"Children":[{"Type":"NodeText","Data":"在多并行度的时候 会取最低的水位线 来保证数据的可靠性"}]},{"ID":"20230817161946-mqw4x6l","Type":"NodeParagraph","Properties":{"id":"20230817161946-mqw4x6l","updated":"20230817161946"},"Children":[{"Type":"NodeText","Data":"watermark的生成方式"}]},{"ID":"20230817161947-cpg20vy","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161947-cpg20vy","updated":"20230817161947"},"Children":[{"ID":"20230817161948-tdv3jeo","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161948-tdv3jeo","updated":"20230817161948"},"Children":[{"ID":"20230817161949-oyytuo0","Type":"NodeParagraph","Properties":{"id":"20230817161949-oyytuo0","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"with perrodic watermarks 周期性的触发 即每隔N秒自动向流里面注入一个watermark 默认是200秒 但我们可以自己设置"}]},{"ID":"20230817161950-qs6628s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c2NhbGE=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161950-qs6628s","updated":"20230817161950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2NhbGE=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" env.getConfig.setAutoWatermarkInterval(200)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20230817161951-rhis5gx","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161951-rhis5gx","updated":"20230817161951"},"Children":[{"ID":"20230817161952-mk2in9z","Type":"NodeParagraph","Properties":{"id":"20230817161952-mk2in9z","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"with punctuated watermarks 基于事件触发watermark的生成 基于事件向流里面注入watermark"}]}]}]},{"ID":"20230817161953-8nm5nqz","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161953-8nm5nqz","updated":"20230817161953"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"window触发时机"}]},{"ID":"20230817161954-bi25cg2","Type":"NodeParagraph","Properties":{"id":"20230817161954-bi25cg2","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"1、watermark\u003e=window.endtime"}]},{"ID":"20230817161955-3dk5vte","Type":"NodeParagraph","Properties":{"id":"20230817161955-3dk5vte","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"2、且[window.startime,window.endtime）有数据时才会触发"}]},{"ID":"20230817161956-8usrhp9","Type":"NodeParagraph","Properties":{"id":"20230817161956-8usrhp9","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"watermark是可以处理乱序的问题 主要之前已经设置了一个迟到时间10秒 那么如果迟到时间超过了10秒怎么处理呢？"}]},{"ID":"20230817161957-bhxbcoc","Type":"NodeParagraph","Properties":{"id":"20230817161957-bhxbcoc","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"Late element处理方法："}]},{"ID":"20230817161958-qn4ef8y","Type":"NodeParagraph","Properties":{"id":"20230817161958-qn4ef8y","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"1、丢弃 默认"}]},{"ID":"20230817161959-7equ4b2","Type":"NodeParagraph","Properties":{"id":"20230817161959-7equ4b2","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"2、再给他多加点迟到时间 即"}]},{"ID":"20230817161960-8aqh1eq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161960-8aqh1eq","updated":"20230817161960"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"allowedLateness(Time.seconds(2))\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161961-4emf1zo","Type":"NodeParagraph","Properties":{"id":"20230817161961-4emf1zo","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"多加两秒 则之后在watermark\u003cwindowtime+allowedLateness(Time.seconds(2))之间的数据依然可以触发window"}]},{"ID":"20230817161962-p08t82a","Type":"NodeParagraph","Properties":{"id":"20230817161962-p08t82a","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"3、设置sideoutputlatedate 即给他收集起来然后 保存用于后期分析 2和3也可以结合使用"}]},{"ID":"20230817161963-omotj6k","Type":"NodeParagraph","Properties":{"id":"20230817161963-omotj6k","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"把迟到的数据可以存储在其他介质中"}]},{"ID":"20230817161964-hrmdlfv","Type":"NodeParagraph","Properties":{"id":"20230817161964-hrmdlfv","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"所有测试过程代码"}]},{"ID":"20230817161965-b3a09y7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"c2NhbGE=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161965-b3a09y7","updated":"20230817161965"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2NhbGE=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.flink.window\n\nimport java.text.SimpleDateFormat\nimport java.time.Duration\n\nimport org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, WatermarkStrategy}\nimport org.apache.flink.api.java.tuple.Tuple\nimport org.apache.flink.streaming.api.TimeCharacteristic\nimport org.apache.flink.streaming.api.scala.{OutputTag, StreamExecutionEnvironment}\nimport org.apache.flink.streaming.api.scala.function.WindowFunction\nimport org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows\nimport org.apache.flink.streaming.api.windowing.time.Time\nimport org.apache.flink.streaming.api.windowing.windows.TimeWindow\nimport org.apache.flink.util.Collector\n\nimport scala.collection.mutable.ArrayBuffer\nimport scala.util.Sorting\n\nobject WaterMarkOp {\n  def main(args: Array[String]): Unit = {\n    val env = StreamExecutionEnvironment.getExecutionEnvironment\n    //设置使用数据产生的时间：EventTime\n    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)\n    //设置全局并行度为1\n    env.setParallelism(1)\n\n    //设置自动周期性的产生watermark，默认值为200毫秒\n    env.getConfig.setAutoWatermarkInterval(200)\n\n\n    val text = env.socketTextStream(\"bigdata04\", 9001)\n    import org.apache.flink.api.scala._\n    //将数据转换为tuple2的形式\n    //第一列表示具体的数据，第二列表示是数据产生的时间戳\n    val tupStream = text.map(line =\u003e {\n      val arr = line.split(\",\")\n      (arr(0), arr(1).toLong)\n    })\n\n    //分配(提取)时间戳和watermark\n    val waterMarkStream = tupStream.assignTimestampsAndWatermarks(WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(10)) //最大允许的数据乱序时间 10s\n      .withTimestampAssigner(new SerializableTimestampAssigner[Tuple2[String, Long]] {\n        val sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n        var currentMaxTimstamp = 0L\n\n        //从数据流中抽取时间戳作为EventTime\n        override def extractTimestamp(element: (String, Long), recordTimestamp: Long): Long = {\n          val timestamp = element._2\n          currentMaxTimstamp = Math.max(timestamp, currentMaxTimstamp)\n          //计算当前watermark，为了打印出来方便观察数据，没有别的作用，watermark=currentMaxTimstamp-OutOfOrderness\n          val currentWatermark = currentMaxTimstamp - 10000L\n          //此print语句仅仅是为了在学习阶段观察数据的变化\n          println(\"key:\" + element._1 + \",\" + \"eventtime:[\" + element._2 + \"|\" + sdf.format(element._2) + \"],currentMaxTimstamp:[\" + currentWatermark + \"|\" + sdf.format(currentMaxTimstamp) + \"],watermark:[\" + currentWatermark + \"|\" + sdf.format(currentWatermark) + \"]\")\n          element._2\n        }\n      })\n    )\n    val outputtag=new OutputTag[Tuple2[String,Long]]();\n    val resstream = waterMarkStream.keyBy(0)\n      //按照消息的EventTime分配窗口，和调用TimeWindow效果一样\n      .window(TumblingEventTimeWindows.of(Time.seconds(3)))\n//      .allowedLateness(Time.seconds(2))\n      .sideOutputLateData(outputtag)\n      //使用全量聚合的方式处理window中的数据\n      .apply(new WindowFunction[Tuple2[String, Long], String, Tuple, TimeWindow] {\n        override def apply(key: Tuple, window: TimeWindow, input: Iterable[(String, Long)], out: Collector[String]): Unit = {\n          val keyStr = key.toString\n          //将window中的数据保存到arrBuff中\n          val arrBuff = ArrayBuffer[Long]()\n          input.foreach(tup =\u003e {\n            arrBuff.append(tup._2)\n          })\n          //将arrBuff转换为arr\n          val arr = arrBuff.toArray\n          //对arr中的数据进行排序\n          Sorting.quickSort(arr)\n\n          val sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n          //将目前window内排序后的数据，以及window的开始时间和window的结束时间打印出来，便于观察\n          val result = keyStr + \",\" + arr.length + \",\" + sdf.format(arr.head) + \",\" + sdf.format(arr.last) + \",\" + sdf.format(window.getStart) + \",\" + sdf.format(window.getEnd)\n          out.collect(result)\n        }\n      })\n    val sideoutput = resstream.getSideOutput(outputtag)\n    sideoutput.print()\n    resstream.print()\n    env.execute(\"WatermarkOpScala\")\n  }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161966-nhnfqen","Type":"NodeParagraph","Properties":{"id":"20230817161966-nhnfqen","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"watermark总结："}]},{"ID":"20230817161967-0r7vfql","Type":"NodeParagraph","Properties":{"id":"20230817161967-0r7vfql","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"要合理根据业务设定最大延时时间  如果时间设置太小 会导致乱序和迟到太多 如果设置过大会加重flink的负担 最终结果就是有很多数据被丢弃 对数据影响较大"}]},{"ID":"20230817161968-azsgde2","Type":"NodeParagraph","Properties":{"id":"20230817161968-azsgde2","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"是不是对eventtime要求很严格的数据尽量不要采用eventtime来解决"}]}]}