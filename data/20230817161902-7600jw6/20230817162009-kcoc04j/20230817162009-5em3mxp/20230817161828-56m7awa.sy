{"ID":"20230817161828-56m7awa","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161828-56m7awa","title":"Flink面试题收集","updated":"20230817161828"},"Children":[{"ID":"20230817161829-fndue4w","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161829-fndue4w","updated":"20230817161829"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Flink面试题收集？"}]},{"ID":"20230817161830-60dkf0a","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161830-60dkf0a","updated":"20230817161830"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1、Flink中的并行度可以在哪些地方设置？其优先级是怎样的？"}]},{"ID":"20230817161831-yjsbat1","Type":"NodeParagraph","Properties":{"id":"20230817161831-yjsbat1","updated":"20230817161831"},"Children":[{"Type":"NodeText","Data":"flink的并行度可以再算子层面设置 也可以在执行环境层面设置 还可以在向集群中提交作业时设置 同时还可以再flink的flink-conf.yaml设置 其优先级是算子层面设置 \u003e执行环境层面设置 \u003e向集群中提交作业时设置 \u003eflink的flink-conf.yaml设置"}]},{"ID":"20230817161832-8x7zksw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161832-8x7zksw","updated":"20230817161832"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2、Task slot的理解"}]},{"ID":"20230817161833-jgavd42","Type":"NodeParagraph","Properties":{"id":"20230817161833-jgavd42","updated":"20230817161833"},"Children":[{"Type":"NodeText","Data":"每个工作线程（TaskManager）都是一个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"JVM进程"},{"Type":"NodeText","Data":"，可以在单独的线程中执行一个或多个子任务。为了控制 TaskManager 接受的任务数，它具有所谓的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"任务槽"},{"Type":"NodeText","Data":"（至少一个）。"}]},{"ID":"20230817161834-3bpvwau","Type":"NodeParagraph","Properties":{"id":"20230817161834-3bpvwau","updated":"20230817161834"},"Children":[{"Type":"NodeText","Data":"每个"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"任务槽"},{"Type":"NodeText","Data":"都表示任务管理器的一个固定资源子集。例如，具有三个插槽的任务管理器会将其托管内存的 1/3 专用于每个插槽。插入资源意味着子任务不会与其他作业中的子任务争用托管内存，而是具有一定量的保留托管内存。请注意，这里不会发生 CPU 隔离。当前插槽仅分隔任务的托管内存。"}]},{"ID":"20230817161835-paftpge","Type":"NodeParagraph","Properties":{"id":"20230817161835-paftpge","updated":"20230817161835"},"Children":[{"Type":"NodeText","Data":"通过调整任务槽的数量，用户可以定义子任务如何彼此隔离。每个 TaskManager 有一个槽意味着每个任务组都在单独的 JVM 中运行（例如，可以在单独的容器中启动）。拥有多个插槽意味着更多的子任务共享同一个 JVM。同一 JVM 中的任务共享 TCP 连接（通过多路复用）和检测信号消息。它们还可以共享数据集和数据结构，从而减少每个任务的开销。"}]},{"ID":"20230817161836-8nvy6f3","Type":"NodeParagraph","Properties":{"id":"20230817161836-8nvy6f3","updated":"20230817161836"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"具有任务槽位和任务的任务管理器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://nightlies.apache.org/flink/flink-docs-release-1.13/fig/tasks_slots.svg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161837-umnlsgf","Type":"NodeParagraph","Properties":{"id":"20230817161837-umnlsgf","updated":"20230817161837"},"Children":[{"Type":"NodeText","Data":"默认情况下，Flink 允许子任务共享槽，即使它们是不同任务的子任务，只要它们来自同一作业。结果是，一个槽可以容纳作业的整个管道。允许此"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"插槽共享"},{"Type":"NodeText","Data":"有两个主要好处："}]},{"ID":"20230817161838-d7m1oia","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161838-d7m1oia","updated":"20230817161838"},"Children":[{"ID":"20230817161839-fgl7i23","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161839-fgl7i23","updated":"20230817161839"},"Children":[{"ID":"20230817161840-5itbhtr","Type":"NodeParagraph","Properties":{"id":"20230817161840-5itbhtr","updated":"20230817161840"},"Children":[{"Type":"NodeText","Data":"Flink 集群需要的任务槽数与作业中使用的最高并行度完全相同。无需计算程序总共包含多少个任务（具有不同的并行度）。"}]}]},{"ID":"20230817161841-n9xteza","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161841-n9xteza","updated":"20230817161841"},"Children":[{"ID":"20230817161842-auhlw31","Type":"NodeParagraph","Properties":{"id":"20230817161842-auhlw31","updated":"20230817161842"},"Children":[{"Type":"NodeText","Data":"更容易获得更好的资源利用率。如果没有插槽共享，非密集型"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"源/map（）"},{"Type":"NodeText","Data":" 子任务将阻止与资源密集型"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"窗口"},{"Type":"NodeText","Data":"子任务一样多的资源。通过槽共享，将示例中的基本并行度从 2 个增加到 6 个，可以充分利用槽内资源，同时确保繁重的子任务在 TaskManager 之间公平分配。"}]}]}]},{"ID":"20230817161843-l9mfzwl","Type":"NodeParagraph","Properties":{"id":"20230817161843-l9mfzwl","updated":"20230817161843"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"具有共享任务槽位的任务管理器","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://nightlies.apache.org/flink/flink-docs-release-1.13/fig/slot_sharing.svg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161844-87j5imw","Type":"NodeParagraph","Properties":{"id":"20230817161844-87j5imw","updated":"20230817161844"},"Children":[{"Type":"NodeText","Data":"taskslot与parallism的区别 其实taskslot就是理论上能够承载的最大并发数目 而parallism就是实际的并发数"}]},{"ID":"20230817161845-a45p869","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161845-a45p869","updated":"20230817161845"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3、union 和connect区别"}]},{"ID":"20230817161846-ynk17je","Type":"NodeParagraph","Properties":{"id":"20230817161846-ynk17je","updated":"20230817161846"},"Children":[{"Type":"NodeText","Data":"union 多流合并   数据类型必须相同"}]},{"ID":"20230817161847-c714ff0","Type":"NodeParagraph","Properties":{"id":"20230817161847-c714ff0","updated":"20230817161847"},"Children":[{"Type":"NodeText","Data":"而connect则可以是任意数据类型  双流合并 更加灵活"}]},{"ID":"20230817161848-ysrmiel","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161848-ysrmiel","updated":"20230817161848"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"4、Flink的分区策略"}]},{"ID":"20230817161849-9kyys3v","Type":"NodeParagraph","Properties":{"id":"20230817161849-9kyys3v","updated":"20230817161849"},"Children":[{"Type":"NodeText","Data":"flink的分区规则：从图中即可看出区别"}]},{"ID":"20230817161850-mh4uedl","Type":"NodeParagraph","Properties":{"id":"20230817161850-mh4uedl","updated":"20230817161850"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图片描述","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img.mukewang.com/wiki/5f8062ad0948cce217880689.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161851-dztyzjo","Type":"NodeParagraph","Properties":{"id":"20230817161851-dztyzjo","updated":"20230817161851"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"图片描述","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://img.mukewang.com/wiki/5f8062bb09a0f3fa12660487.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161852-utzqnko","Type":"NodeParagraph","Properties":{"id":"20230817161852-utzqnko","updated":"20230817161852"},"Children":[{"Type":"NodeText","Data":"shuffle是随机分区 既保证理论上的均匀"}]},{"ID":"20230817161853-hcc6kv0","Type":"NodeParagraph","Properties":{"id":"20230817161853-hcc6kv0","updated":"20230817161853"},"Children":[{"Type":"NodeText","Data":"rebalance是循环发送 能够做到每个分区的均匀"}]},{"ID":"20230817161854-gwdku3s","Type":"NodeParagraph","Properties":{"id":"20230817161854-gwdku3s","updated":"20230817161854"},"Children":[{"Type":"NodeText","Data":"rescale也是循环发送 但他是做分区的局部均匀"}]},{"ID":"20230817161855-b0jocn1","Type":"NodeParagraph","Properties":{"id":"20230817161855-b0jocn1","updated":"20230817161855"},"Children":[{"Type":"NodeText","Data":"broadcast则是将数据给每个分区发送一份"}]},{"ID":"20230817161856-ppazoj6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161856-ppazoj6","updated":"20230817161856"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"5、flink datastream中常用的的算子"}]},{"ID":"20230817161857-8aiy94i","Type":"NodeParagraph","Properties":{"id":"20230817161857-8aiy94i","updated":"20230817161857"},"Children":[{"Type":"NodeText","Data":"map、flatmap、keyby、sum、filter等"}]},{"ID":"20230817161858-dcgeqqj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161858-dcgeqqj","updated":"20230817161858"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"6、谈谈在数据清洗过程中做的工作？"}]},{"ID":"20230817161859-8d62uto","Type":"NodeParagraph","Properties":{"id":"20230817161859-8d62uto","updated":"20230817161859"},"Children":[{"Type":"NodeText","Data":"1、缺失值的清洗"}]},{"ID":"20230817161860-zlm0258","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161860-zlm0258","updated":"20230817161860"},"Children":[{"ID":"20230817161861-zebieu8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161861-zebieu8","updated":"20230817161861"},"Children":[{"ID":"20230817161862-7tznk9x","Type":"NodeParagraph","Properties":{"id":"20230817161862-7tznk9x","updated":"20230817161862"},"Children":[{"Type":"NodeText","Data":"确定缺失值范围"}]}]},{"ID":"20230817161863-r7qwm15","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161863-r7qwm15","updated":"20230817161863"},"Children":[{"ID":"20230817161864-zr7t08c","Type":"NodeParagraph","Properties":{"id":"20230817161864-zr7t08c","updated":"20230817161864"},"Children":[{"Type":"NodeText","Data":"删除不必要的字段"}]}]},{"ID":"20230817161865-cavcy6e","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161865-cavcy6e","updated":"20230817161865"},"Children":[{"ID":"20230817161866-l33uduw","Type":"NodeParagraph","Properties":{"id":"20230817161866-l33uduw","updated":"20230817161866"},"Children":[{"Type":"NodeText","Data":"填充缺失内容"}]}]},{"ID":"20230817161867-zf0syi7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161867-zf0syi7","updated":"20230817161867"},"Children":[{"ID":"20230817161868-zodx7sp","Type":"NodeParagraph","Properties":{"id":"20230817161868-zodx7sp","updated":"20230817161868"},"Children":[{"Type":"NodeText","Data":"重新取数"}]}]}]},{"ID":"20230817161869-vrt5xgx","Type":"NodeParagraph","Properties":{"id":"20230817161869-vrt5xgx","updated":"20230817161869"},"Children":[{"Type":"NodeText","Data":"2、格式内容的清洗"}]},{"ID":"20230817161870-d0d1hvu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161870-d0d1hvu","updated":"20230817161870"},"Children":[{"ID":"20230817161871-y97lz1s","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161871-y97lz1s","updated":"20230817161871"},"Children":[{"ID":"20230817161872-pkstivy","Type":"NodeParagraph","Properties":{"id":"20230817161872-pkstivy","updated":"20230817161872"},"Children":[{"Type":"NodeText","Data":"检测日期、时间、数值等的数字是否正确"}]}]},{"ID":"20230817161873-4gl4ecu","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161873-4gl4ecu","updated":"20230817161873"},"Children":[{"ID":"20230817161874-913tgw3","Type":"NodeParagraph","Properties":{"id":"20230817161874-913tgw3","updated":"20230817161874"},"Children":[{"Type":"NodeText","Data":"内容不应该存在的字段。。。"}]}]}]},{"ID":"20230817161875-b1p7rgm","Type":"NodeParagraph","Properties":{"id":"20230817161875-b1p7rgm","updated":"20230817161875"},"Children":[{"Type":"NodeText","Data":"3、逻辑错误的清洗"}]},{"ID":"20230817161876-3o3esoi","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161876-3o3esoi","updated":"20230817161876"},"Children":[{"ID":"20230817161877-kfybyyo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161877-kfybyyo","updated":"20230817161877"},"Children":[{"ID":"20230817161878-v7sxnnb","Type":"NodeParagraph","Properties":{"id":"20230817161878-v7sxnnb","updated":"20230817161878"},"Children":[{"Type":"NodeText","Data":"去除逻辑出现错误的问题 包括去重 去除不合理的值 矛盾的值"}]}]}]},{"ID":"20230817161879-qxsajxf","Type":"NodeParagraph","Properties":{"id":"20230817161879-qxsajxf","updated":"20230817161879"},"Children":[{"Type":"NodeText","Data":"4、非需求数据清洗"}]},{"ID":"20230817161880-e4ihb2j","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161880-e4ihb2j","updated":"20230817161880"},"Children":[{"ID":"20230817161881-ev058gt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161881-ev058gt","updated":"20230817161881"},"Children":[{"ID":"20230817161882-0vx9472","Type":"NodeParagraph","Properties":{"id":"20230817161882-0vx9472","updated":"20230817161882"},"Children":[{"Type":"NodeText","Data":"把跟业务逻辑不相关的值删去 但有可能后续又需要"}]}]}]},{"ID":"20230817161883-cs5lt9s","Type":"NodeParagraph","Properties":{"id":"20230817161883-cs5lt9s","updated":"20230817161883"},"Children":[{"Type":"NodeText","Data":"5、关联性验证"}]},{"ID":"20230817161884-bya99ep","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161884-bya99ep","updated":"20230817161884"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"7、在基于Flinkwindow处理时遇到了数据倾斜怎么解决？"}]},{"ID":"20230817161885-6x6o56f","Type":"NodeParagraph","Properties":{"id":"20230817161885-6x6o56f","updated":"20230817161885"},"Children":[{"Type":"NodeText","Data":"1、在数据进入窗口前做预聚合"}]},{"ID":"20230817161886-nympbwy","Type":"NodeParagraph","Properties":{"id":"20230817161886-nympbwy","updated":"20230817161886"},"Children":[{"Type":"NodeText","Data":"2、重新设计窗口聚合key"}]},{"ID":"20230817161887-f65jhlu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161887-f65jhlu","updated":"20230817161887"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"8、对WindowFuntion的认识"}]},{"ID":"20230817161888-cmjgmre","Type":"NodeParagraph","Properties":{"id":"20230817161888-cmjgmre","updated":"20230817161888"},"Children":[{"Type":"NodeText","Data":"常见的WindowFuntion有三种：reducefunction aagregatefunction processfunction 前两者都是增量聚合 最有一种是全量聚合 如果只是对基本的数据处理且不需要全量聚合运算时 可以使用前两种 如果涉及到窗口大小、窗口的发生和结束时间等其他信息时 或者需要全量计算时可以采用processfunction"}]},{"ID":"20230817161889-x333811","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161889-x333811","updated":"20230817161889"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"9、谈谈对时间语义的理解"}]},{"ID":"20230817161890-79x5hx8","Type":"NodeParagraph","Properties":{"id":"20230817161890-79x5hx8","updated":"20230817161890"},"Children":[{"Type":"NodeText","Data":"eventtime 是根据事件产生先后的顺序来处理"}]},{"ID":"20230817161891-gsk3twa","Type":"NodeParagraph","Properties":{"id":"20230817161891-gsk3twa","updated":"20230817161891"},"Children":[{"Type":"NodeText","Data":"processtime 是根据事件到达flink的时间顺序处理 可能会出现不准确"}]},{"ID":"20230817161892-rnrzde7","Type":"NodeParagraph","Properties":{"id":"20230817161892-rnrzde7","updated":"20230817161892"},"Children":[{"Type":"NodeText","Data":"比如关注的列子 1关注2关注3关注4不关注5关注 如果5比4先到达 那么最终的结果就是用户不关注 导致结果出错 所以说可以采用eventime来解决这个问题 但是基于eventtime  数据在传输时可能会出现网络延迟 导致"}]},{"ID":"20230817161893-4aszat1","Type":"NodeParagraph","Properties":{"id":"20230817161893-4aszat1","updated":"20230817161893"},"Children":[{"Type":"NodeText","Data":"乱序问题 这个可以引入watermark来解决"}]},{"ID":"20230817161894-auxl1c9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161894-auxl1c9","updated":"20230817161894"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"10、Flink的窗口有哪些 各自运用场景"}]},{"ID":"20230817161895-75uq9o7","Type":"NodeParagraph","Properties":{"id":"20230817161895-75uq9o7","updated":"20230817161895"},"Children":[{"Type":"NodeText","Data":"tumblingWindow即滚动窗口 业务场景可以统计某个服务每隔10秒的访问量"}]},{"ID":"20230817161896-oo2adcu","Type":"NodeParagraph","Properties":{"id":"20230817161896-oo2adcu","updated":"20230817161896"},"Children":[{"Type":"NodeText","Data":"slidingwindow 即滑动窗口 可以统计每隔1分钟 统计前五分钟的成交额"}]},{"ID":"20230817161897-grfc8f9","Type":"NodeParagraph","Properties":{"id":"20230817161897-grfc8f9","updated":"20230817161897"},"Children":[{"Type":"NodeText","Data":"sessionwindow会话窗口 当我们需要分析用户的一段交互的行为事件时，通常的想法是将用户的事件流按照“session”来分组。"}]},{"ID":"20230817161898-aimpfk8","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161898-aimpfk8","updated":"20230817161898"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"11、flink中乱序数据的解决方案"}]},{"ID":"20230817161899-jpl7hy1","Type":"NodeParagraph","Properties":{"id":"20230817161899-jpl7hy1","updated":"20230817161899"},"Children":[{"Type":"NodeText","Data":"主要是通过flink提供的watermark机制加上窗口延迟进行处理 延迟时间可以让窗口在延迟时间过后触发 相当于给了乱序数据的忍耐时间 超过了这个时间的数据可以通过sideoutput旁路输出进行二次开发"}]},{"ID":"20230817161900-f5hvyxu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161900-f5hvyxu","updated":"20230817161900"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"12、flink中的水印是什么意思 在实际处理过程中有什么作用"}]},{"ID":"20230817161901-vudvw9h","Type":"NodeParagraph","Properties":{"id":"20230817161901-vudvw9h","updated":"20230817161901"},"Children":[{"Type":"NodeText","Data":"水印是结合eventtime处理乱序问题的 他的值为当前eventtime的最大值-延迟时间的值 当水印到达了某个窗口的结束时间 那么该窗口的数据就会被触发执行 如果窗口已经触发 数据再来 那么该数据要么被丢弃 要么输出到sideoutput中"}]},{"ID":"20230817161902-tig6b4r","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161902-tig6b4r","updated":"20230817161902"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"13、flink的容错机制"}]},{"ID":"20230817161903-p1p9zdx","Type":"NodeParagraph","Properties":{"id":"20230817161903-p1p9zdx","updated":"20230817161903"},"Children":[{"Type":"NodeText","Data":"flink提供了checkpoint 容错机制 可以将内部的状态信息存储在外部存储中 这种状态信息一般都是一批数据的聚合信息以及任务的进展信息或者自定义的信息等等 也可以说是计算出来的中间结果 当我们手动或者flink自动重启任务后 如果指定了checkpoink 那么flink可以从外部存储中继续读取保留的状态信息继续消费 进而达到了容错的目的 就比如某个任务因为特殊原因挂掉了 下次重启机器后 如果设置了checkpoint 的backend为hdfs 那么可以从hdfs中继续读取状态的保留信息继续计算 而不是又重新计算"}]},{"ID":"20230817161904-hnbmgp5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161904-hnbmgp5","updated":"20230817161904"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"14、savepoint和checkpoint的区别"}]},{"ID":"20230817161905-2gw8anc","Type":"NodeParagraph","Properties":{"id":"20230817161905-2gw8anc","updated":"20230817161905"},"Children":[{"Type":"NodeText","Data":"checkpoint主要是为了容错 没有考虑移植性 当因为异常而导致任务中断时 会使用checkpoint去恢复作业"}]},{"ID":"20230817161906-acg6leb","Type":"NodeParagraph","Properties":{"id":"20230817161906-acg6leb","updated":"20230817161906"},"Children":[{"Type":"NodeText","Data":"savepoint更多的是我们手动暂停任务 如升级flink 先将任务的状态全部保留一次 待修改任务完成后 在恢复任务 考虑到了移植性"}]},{"ID":"20230817161907-spf6x79","Type":"NodeParagraph","Properties":{"id":"20230817161907-spf6x79","updated":"20230817161907"},"Children":[{"Type":"NodeText","Data":"同时savepoint是flink自动帮我们维护的 而savepoint的触发以及删除需要我们自己维护"}]},{"ID":"20230817161908-x0arfsx","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161908-x0arfsx","updated":"20230817161908"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"15、flink的状态存储"}]},{"ID":"20230817161909-lf7xsom","Type":"NodeParagraph","Properties":{"id":"20230817161909-lf7xsom","updated":"20230817161909"},"Children":[{"Type":"NodeText","Data":"默认是存储在jobmanager的jvm的内存中 flink执行任务时每隔一段时间就会对数据进行快照 然后将快照存储在taskmanager的内存中 然后周期性的刷新到jobmanager中(这种存储策略一旦任务异常 任务的状态信息会丢失 一般用于本地调试"}]},{"ID":"20230817161910-8sjy75i","Type":"NodeParagraph","Properties":{"id":"20230817161910-8sjy75i","updated":"20230817161910"},"Children":[{"Type":"NodeText","Data":"开发环境中推荐选择使用基于外部文件系统的存储 包括hdfs(本身就具有高可用) 本地目录等 且选择保留每次的数据"}]},{"ID":"20230817161911-rqed6f5","Type":"NodeParagraph","Properties":{"id":"20230817161911-rqed6f5","updated":"20230817161911"},"Children":[{"Type":"NodeText","Data":"还有一种是存储在flink内置rocksdb数据库中的 相比于外部文件存储 可以存储更大的窗口和状态 但吞吐量比较低"}]},{"ID":"20230817161912-0yqpov7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161912-0yqpov7","updated":"20230817161912"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"16、分组求topN的数据倾斜解决方案"}]},{"ID":"20230817161913-ctizfhe","Type":"NodeParagraph","Properties":{"id":"20230817161913-ctizfhe","updated":"20230817161913"},"Children":[{"Type":"NodeText","Data":"数据倾斜处理："}]},{"ID":"20230817161914-uaq16ri","Type":"NodeParagraph","Properties":{"id":"20230817161914-uaq16ri","updated":"20230817161914"},"Children":[{"Type":"NodeText","Data":"在第一次keyby的时候可能会出现数据倾斜、因为此时一条数据对因一条原始数据、可能会出现若干分组下数据量过大的情况"}]},{"ID":"20230817161915-gm40stc","Type":"NodeParagraph","Properties":{"id":"20230817161915-gm40stc","updated":"20230817161915"},"Children":[{"Type":"NodeText","Data":"而在第二次keyby的时候基于了类别+窗口时间 并且数据量已经时累加过后的 并且又间接引入了时间这一维度进行分组 又再一次打散了数据  所以不容易出现数据倾斜"}]},{"ID":"20230817161916-4z35lav","Type":"NodeParagraph","Properties":{"id":"20230817161916-4z35lav","updated":"20230817161916"},"Children":[{"Type":"NodeText","Data":"解决方案：首先是增加并行度"}]},{"ID":"20230817161917-yid44cl","Type":"NodeParagraph","Properties":{"id":"20230817161917-yid44cl","updated":"20230817161917"},"Children":[{"Type":"NodeText","Data":"其次是在分组的时候 为分组后的最后一个字段添加前缀可以是随机数 相当于增加了key的维度 打散了数据"}]},{"ID":"20230817161918-pz8aqcj","Type":"NodeParagraph","Properties":{"id":"20230817161918-pz8aqcj","updated":"20230817161918"},"Children":[{"Type":"NodeText","Data":"最后在定时器操作中取掉前缀来合并数据 最后进行排序 输出topN"}]},{"ID":"20230817161919-sa9gysp","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161919-sa9gysp","updated":"20230817161919"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"17、flink实现精准一次语义"}]},{"ID":"20230817161920-vg3ggaa","Type":"NodeParagraph","Properties":{"id":"20230817161920-vg3ggaa","updated":"20230817161920"},"Children":[{"Type":"NodeText","Data":"精准一次具体解析："}]},{"ID":"20230817161921-gxj9o32","Type":"NodeParagraph","Properties":{"id":"20230817161921-gxj9o32","updated":"20230817161921"},"Children":[{"Type":"NodeText","Data":"在kafka-\u003eflink-\u003eredis的过程中 即使在过程中redis挂掉了 flink的checkpoint机制会保留offset信息 每次运行完之后如果整个过程成功会更新状态 如果没有成功不会更新状态 下次重启时会继续从上次未提交的offset继续消费  redis保证的是at least once 但由于redis是覆盖类型的数据库 即update+insert 即有数据会更新 没有数据会提交 即使数据重复了他也会覆盖掉"}]},{"ID":"20230817161922-yb1sdnm","Type":"NodeParagraph","Properties":{"id":"20230817161922-yb1sdnm","updated":"20230817161922"},"Children":[{"Type":"NodeText","Data":"kafka的精准一次语义保证"}]},{"ID":"20230817161923-wm7u3fi","Type":"NodeParagraph","Properties":{"id":"20230817161923-wm7u3fi","updated":"20230817161923"},"Children":[{"Type":"NodeText","Data":"依托于flink的两阶段提交："}]},{"ID":"20230817161924-z94baqt","Type":"NodeParagraph","Properties":{"id":"20230817161924-z94baqt","updated":"20230817161924"},"Children":[{"Type":"NodeText","Data":"TwoPhaseCommitSinkFunction  2阶段提交"}]},{"ID":"20230817161925-gq1xs1k","Type":"NodeParagraph","Properties":{"id":"20230817161925-gq1xs1k","updated":"20230817161925"},"Children":[{"Type":"NodeText","Data":"第一阶段：数据写入kafka后 他不会提交事务"}]},{"ID":"20230817161926-6ktbqwi","Type":"NodeParagraph","Properties":{"id":"20230817161926-6ktbqwi","updated":"20230817161926"},"Children":[{"Type":"NodeText","Data":"第二阶段：数据写入成功后 才会提交事务 如果出现异常就回滚"}]},{"ID":"20230817161927-voqf4le","Type":"NodeParagraph","Properties":{"id":"20230817161927-voqf4le","updated":"20230817161927"},"Children":[{"Type":"NodeText","Data":"其实就是数据首先会预提交 然后会有一个监听器监听checkpoint的状态  如果所有状态都ok没有出现异常的话 数据才会真正的提交"}]},{"ID":"20230817161928-12o8o12","Type":"NodeParagraph","Properties":{"id":"20230817161928-12o8o12","updated":"20230817161928"},"Children":[{"Type":"NodeText","Data":"再具体点说 就是checkpoint的快照机制 假如设定了5秒钟 那么该快照机制就会将数据原有的状态连同kafka的offset一起作为状态存储 每次快照都会预提交 当所有提交都没有问题时 才会真正更新stackbackend里的状态 只要有一个过程失败了 那么就会回滚 即不会更新提交失败的状态"}]}]}