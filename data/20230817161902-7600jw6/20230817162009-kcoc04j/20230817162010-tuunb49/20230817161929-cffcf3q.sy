{"ID":"20230817161929-cffcf3q","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161929-cffcf3q","title":"多线程入门","updated":"20230817161929"},"Children":[{"ID":"20230817161930-r9mbr8e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161930-r9mbr8e","updated":"20230817161930"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多线程入门"}]},{"ID":"20230817161931-ki04cya","Type":"NodeParagraph","Properties":{"id":"20230817161931-ki04cya","updated":"20230817161931"},"Children":[{"Type":"NodeText","Data":"常见的线程创建方法 一是直接创建一个类继承thread方法 并且重写run方法 因为thread也是实现了runable接口"}]},{"ID":"20230817161932-grhosee","Type":"NodeParagraph","Properties":{"id":"20230817161932-grhosee","updated":"20230817161932"},"Children":[{"Type":"NodeText","Data":"第二种方法是给thread传递一个实现runable接口的类 该类也要实现run方法"}]},{"ID":"20230817161933-nvq0ywg","Type":"NodeParagraph","Properties":{"id":"20230817161933-nvq0ywg","updated":"20230817161933"},"Children":[{"Type":"NodeText","Data":"线程是并行执行的 创建的线程的入口方法是run方法 对于每个线程执行都有一个线程的方法栈用于记录临时变量 以及当前的方法"}]},{"ID":"20230817161934-e8mn55x","Type":"NodeParagraph","Properties":{"id":"20230817161934-e8mn55x","updated":"20230817161934"},"Children":[{"Type":"NodeText","Data":"入门案例："}]},{"ID":"20230817161935-p3pjm8g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161935-p3pjm8g","updated":"20230817161935"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class CreateThreadAppMain {\n    private  static  final String TEXT=\"小红帽静静的睡着了\";\n    public static void main(String[] args) {\n        System.out.println(\"程序开始\"+Thread.currentThread().getName());\n        for(int i=1;i\u003c=2;i++){\n            Thread thread=\n                    new Thread(new PrintStoryRunable(TEXT,200*i),\"我的线程\"+i);//第二个string参数是为线程指定名字\n            thread.start();\n        }\n        System.out.println(\"程序结束了\"+Thread.currentThread().getName());\n    }\n    static  class  PrintStoryRunable implements  Runnable{\n        public  String text;\n        public  int interval;\n\n        public PrintStoryRunable(String text, int interval) {\n            this.text = text;\n            this.interval = interval;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"执行这段代码的线程是：\"+Thread.currentThread().getName());\n            try {\n                printSlowly(text,interval);\n                System.out.println(Thread.currentThread().getName()+\"执行结束\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n        public  static  void  printSlowly(String text,int interval) throws InterruptedException {\n            for(char ch:text.toCharArray()){\n                Thread.sleep(interval);\n                System.out.print(ch);\n            }\n            System.out.println();\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161936-g040mxu","Type":"NodeParagraph","Properties":{"id":"20230817161936-g040mxu","updated":"20230817161936"},"Children":[{"Type":"NodeText","Data":"结果为："}]},{"ID":"20230817161937-k25orl3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161937-k25orl3","updated":"20230817161937"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"程序开始main\n程序结束了main\n执行这段代码的线程是：我的线程2\n执行这段代码的线程是：我的线程1\n小小红帽红静静帽的睡静着了\n我的线程1执行结束\n静的睡着了\n我的线程2执行结束\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161938-s71htek","Type":"NodeParagraph","Properties":{"id":"20230817161938-s71htek","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"所有线程执行完了 那么这个进程就执行完了"}]},{"ID":"20230817161939-z98dzz3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161939-z98dzz3","updated":"20230817161939"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"线程的状态"}]},{"ID":"20230817161940-al5fmdo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161940-al5fmdo","updated":"20230817161940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public enum State {\n        /**\n         * Thread state for a thread which has not yet started.\n         */\n        NEW,\n\n        /**\n         * Thread state for a runnable thread.  A thread in the runnable\n         * state is executing in the Java virtual machine but it may\n         * be waiting for other resources from the operating system\n         * such as processor.\n         */\n        RUNNABLE,\n\n        /**\n         * Thread state for a thread blocked waiting for a monitor lock.\n         * A thread in the blocked state is waiting for a monitor lock\n         * to enter a synchronized block/method or\n         * reenter a synchronized block/method after calling\n         * {@link Object#wait() Object.wait}.\n         */\n        BLOCKED,\n\n        /**\n         * Thread state for a waiting thread.\n         * A thread is in the waiting state due to calling one of the\n         * following methods:\n         * \u003cul\u003e\n         *   \u003cli\u003e{@link Object#wait() Object.wait} with no timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link #join() Thread.join} with no timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link LockSupport#park() LockSupport.park}\u003c/li\u003e\n         * \u003c/ul\u003e\n         *\n         * \u003cp\u003eA thread in the waiting state is waiting for another thread to\n         * perform a particular action.\n         *\n         * For example, a thread that has called \u003ctt\u003eObject.wait()\u003c/tt\u003e\n         * on an object is waiting for another thread to call\n         * \u003ctt\u003eObject.notify()\u003c/tt\u003e or \u003ctt\u003eObject.notifyAll()\u003c/tt\u003e on\n         * that object. A thread that has called \u003ctt\u003eThread.join()\u003c/tt\u003e\n         * is waiting for a specified thread to terminate.\n         */\n        WAITING,\n\n        /**\n         * Thread state for a waiting thread with a specified waiting time.\n         * A thread is in the timed waiting state due to calling one of\n         * the following methods with a specified positive waiting time:\n         * \u003cul\u003e\n         *   \u003cli\u003e{@link #sleep Thread.sleep}\u003c/li\u003e\n         *   \u003cli\u003e{@link Object#wait(long) Object.wait} with timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link #join(long) Thread.join} with timeout\u003c/li\u003e\n         *   \u003cli\u003e{@link LockSupport#parkNanos LockSupport.parkNanos}\u003c/li\u003e\n         *   \u003cli\u003e{@link LockSupport#parkUntil LockSupport.parkUntil}\u003c/li\u003e\n         * \u003c/ul\u003e\n         */\n        TIMED_WAITING,\n\n        /**\n         * Thread state for a terminated thread.\n         * The thread has completed execution.\n         */\n        TERMINATED;\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161941-ei8wy83","Type":"NodeParagraph","Properties":{"id":"20230817161941-ei8wy83","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"守护线程 就是守护某个线程结束 如果进程里面只剩下守护线程了 那么该进程就结束了"}]},{"ID":"20230817161942-opf0dmv","Type":"NodeParagraph","Properties":{"id":"20230817161942-opf0dmv","updated":"20230817161942"},"Children":[{"Type":"NodeText","Data":"interrupt方法 interrupt 方法会打断线程的执行"}]},{"ID":"20230817161943-nctuuf3","Type":"NodeParagraph","Properties":{"id":"20230817161943-nctuuf3","updated":"20230817161943"},"Children":[{"Type":"NodeText","Data":"stop方法会让线程结束 这样可能会导致资源没有被完全释放 造成极大的安全隐患"}]},{"ID":"20230817161944-lkhjdo2","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161944-lkhjdo2","updated":"20230817161944"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"同步控制之synchronized方法"}]},{"ID":"20230817161945-8ah783o","Type":"NodeParagraph","Properties":{"id":"20230817161945-8ah783o","updated":"20230817161945"},"Children":[{"Type":"NodeText","Data":"synchronized关键字用来"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"修饰成员方法"},{"Type":"NodeText","Data":" 代表这个方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"对于同一个对象"},{"Type":"NodeText","Data":"来说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同一时间只能有一个线程执行"},{"Type":"NodeText","Data":" 别的线程若想要执行就必须等待该线程执行完毕 //主要是针对一个对象 而不是多个对象 多个对象互不干扰"}]},{"ID":"20230817161946-7yeisow","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161946-7yeisow","updated":"20230817161946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MultiThreadDemo {\n    public static void main(String[] args) {\n       DataHodler dataHodler= new DataHodler();\n       DataHodler dataHodler1=new DataHodler();\n    Thread increasethread=new Thread(new ChangeData(2,100,dataHodler));\n    Thread decreasethread=new Thread(new ChangeData(-2,100,dataHodler1));\n        System.out.println(\"程序开始\");\n        increasethread.start();\n        decreasethread.start();\n\n    }\n}\n\n程序开始\nNUMBER=200\nNUMBER=-200\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161947-0frm0fw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161947-0frm0fw","updated":"20230817161947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class MultiThreadDemo {\n    public static void main(String[] args) {\n       DataHodler dataHodler= new DataHodler();\n\n    Thread increasethread=new Thread(new ChangeData(2,100,dataHodler));\n    Thread decreasethread=new Thread(new ChangeData(-2,100,dataHodler));\n        System.out.println(\"程序开始\");\n        increasethread.start();\n        decreasethread.start();\n\n    }\n}\n\n程序开始\nNUMBER=200\nNUMBER=0\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161948-2p9chdw","Type":"NodeParagraph","Properties":{"id":"20230817161948-2p9chdw","updated":"20230817161948"},"Children":[{"Type":"NodeText","Data":"synchronized也可以用来修饰代码块"}]},{"ID":"20230817161949-q7ekkcj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161949-q7ekkcj","updated":"20230817161949"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"  public  void  change1(long del){\n        int a=10;\n        synchronized (this){//this用来指定当前类\n            a+=del;\n        }\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161950-q087czg","Type":"NodeParagraph","Properties":{"id":"20230817161950-q087czg","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"synchronized也可以用来修饰静态方法"}]},{"ID":"20230817161951-h4bxlpm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161951-h4bxlpm","updated":"20230817161951"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static int num=10;  \npublic static synchronized void   change3(long del){\n        num+=del;\n    }  \n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161952-s9vb0cb","Type":"NodeParagraph","Properties":{"id":"20230817161952-s9vb0cb","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"wait 和notify"}]},{"ID":"20230817161953-e31oc1i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161953-e31oc1i","updated":"20230817161953"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.thread;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class ThreadWaitNotify {\n    public static void main(String[] args) throws InterruptedException {\n\n        Object locker = new Object();\n\n        int workingSec = 2;\n        int threadCount = 5;\n        for (int i = 0; i \u003c threadCount; i++) {\n            new Thread(() -\u003e {\n                System.out.println(getName() + \"：线程开始工作……\");\n                try {\n                    synchronized (locker) {\n                        sleepSec(workingSec);\n                        System.out.println(getName() + \"：进入等待\");\n                        // \u003e\u003e TODO wait 方法必须在进入相应对象的synchronized块中才能调用\n                        // \u003e\u003e TODO 执行 wait 方法之后，自动失去对象的 monitor，也就是说别的线程可以进入这个对象的synchronized代码块了\n                        locker.wait();\n                        // \u003e\u003e TODO 被唤醒的线程，就相当于执行过了wait方法，开始向下执行。\n                        // \u003e\u003e TODO 如果wait不是synchronized块中的最后一行，那么第一件事就是\"排队\"获取之前失去的monitor\n                        // \u003e\u003e TODO 排队加引号是因为synchronized是非公平的，也就是说，不是谁先等待谁就能先获得\n                        System.out.println(getName() + \"：线程继续……\");\n                        sleepSec(2);\n                        System.out.println(getName() + \"：结束\");\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }, \"工作线程\" + i).start();\n        }\n\n        // \u003e\u003e TODO 如果notify/notifyAll在wait之前，会怎么样？\n        System.out.println(\"------------- 唤醒线程开始sleep -------------\");\n        // TODO 人工划重点：如果执行notify的时候，线程还没有进入wait状态，那么notify是没有效果的\n        // TODO 人工划重点：先notify，后进入wait，就是所谓的 lost notification问题，可能造成线程无法进行\n        // TODO 人工划重点：如果让唤醒的线程 sleep 的比worker短（sleep 时间 +1变-1，或者干脆不sleep），也就是先进行notify，那么就可能会造成这个问题\n        // TODO 人工划重点：为什么说可能呢？因为synchronized还是阻碍了notify的执行，但是notify有机会在wait前执行了\n        sleepSec(workingSec -1);\n        System.out.println(\"------------- 唤醒线程sleep结束 -------------\");\n        synchronized (locker) {\n            // \u003e\u003e TODO notify/notifyAll 方法必须在进入相应对象的synchronized块中才能调用\n            System.out.println(\"------------- 开始唤醒所有 -------------\");\n            locker.notifyAll();\n\n//            for (int i = 0; i \u003c threadCount; i++) {\n//                System.out.println(\"------------- 开始逐个唤醒 -------------\");\n//                locker.notify();\n//            }\n        }\n\n    }\n\n    private static void sleepSec(int sec) {\n        try {\n            Thread.sleep(TimeUnit.SECONDS.toMillis(sec));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String getName() {\n        return Thread.currentThread().getName();\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161954-bwhrh7f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161954-bwhrh7f","updated":"20230817161954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"------------- 唤醒线程开始sleep -------------\n工作线程3：线程开始工作……\n工作线程4：线程开始工作……\n工作线程2：线程开始工作……\n工作线程0：线程开始工作……\n工作线程1：线程开始工作……\n工作线程3：进入等待\n------------- 唤醒线程sleep结束 -------------\n工作线程1：进入等待\n工作线程0：进入等待\n工作线程2：进入等待\n工作线程4：进入等待\n------------- 开始唤醒所有 -------------\n工作线程4：线程继续……\n工作线程4：结束\n工作线程2：线程继续……\n工作线程2：结束\n工作线程0：线程继续……\n工作线程0：结束\n工作线程1：线程继续……\n工作线程1：结束\n工作线程3：线程继续……\n工作线程3：结束\n\nProcess finished with exit code 0\n为什么主线程永远是最后一个抢到锁的呢 因为大概率其他线程在队列的前面 而主线程排在了后面 前面大概率的会抢到锁 sycronnized是不公平锁 这点一定要注意\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161955-b7avpc4","Type":"NodeParagraph","Properties":{"id":"20230817161955-b7avpc4","updated":"20230817161955"},"Children":[{"Type":"NodeText","Data":"join方法 要调用join方法一定要让线程启动 join方法就是等待线程结束"}]},{"ID":"20230817161956-1wg0e1l","Type":"NodeParagraph","Properties":{"id":"20230817161956-1wg0e1l","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"join方法结束要么是Thred方法已经结束了 要么就是调用了join方法 thread还没有开始"}]},{"ID":"20230817161957-nv2rq2j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161957-nv2rq2j","updated":"20230817161957"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.thread;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class ThreadJoinBeforeThread {\n    private static final List\u003cString\u003e CONTENTS = new ArrayList\u003c\u003e();\n\n    private static long WORKING_DURATION = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        long mainStart = System.currentTimeMillis();\n\n        List\u003cThread\u003e threads = new ArrayList\u003c\u003e();\n\n        for (int i = 0; i \u003c 10; i++) {\n            Thread thread = new Thread(() -\u003e {\n                System.out.println(Thread.currentThread().getName() + \":开始抓取网页内容\");\n                long start = System.currentTimeMillis();\n                String content = getContentFromWeb();\n                long threadWorkingDuration = System.currentTimeMillis() - start;\n                System.out.println(Thread.currentThread().getName() + \":抓取网页内容结束\");\n                synchronized (CONTENTS) {\n                    CONTENTS.add(content);\n                    WORKING_DURATION += threadWorkingDuration;\n                }\n            }, \"线程\" + i);\n\n            threads.add(thread);\n        }\n\n        // TODO sleep一下，让线程都启动起来\n//        Thread.sleep(1);\n\n        System.out.println(\" ------------ 主线程开始 join  ------------ \");\n\n        new Thread(() -\u003e {\n            for (Thread thread : threads) {\n                try {\n                    String name = thread.getName();\n                    System.out.println(\" ------------ 主线程开始join \" + name + \" ------------ \");\n                    thread.join();\n                    System.out.println(\" ------------ 主线程join \" + name + \" 结束 ------------ \");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\" ------------ 主线程join结束，获取的内容为： ------------ \");\n\n            CONTENTS.forEach(s -\u003e {\n                System.out.print(s.length() + \"：\");\n                System.out.println(s);\n            });\n\n            long mainWorkDuration = System.currentTimeMillis() - mainStart;\n\n            // TODO 多线程的意义就是让工作并发的处理，使用更多的资源（CPU，磁盘，网络等），以便让工作更快的完成。\n            System.out.println(\"工作线程累计工作时间：\" + WORKING_DURATION);\n            System.out.println(\"主线程工作时间：\" + mainWorkDuration);\n\n        }).start();\n\n        // TODO 如果在线程开始之前，主线程就开始join，会怎么样呢？\n        Thread.sleep(100);\n\n        threads.forEach(Thread::start);\n\n    }\n\n\n    private static String getContentFromWeb() {\n        StringBuilder ret = new StringBuilder();\n        int len = ((int) (Math.random() * 1000000)) % 4096 + 1024;\n        for (int i = 0; i \u003c len; i++) {\n            int rand = ((int) (Math.random() * 1000)) % 26;\n            char ch = (char) (rand + 'a');\n            ret.append(ch);\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return ret.toString();\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161958-2femm79","Type":"NodeParagraph","Properties":{"id":"20230817161958-2femm79","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"死锁 在申请下一个资源时 还没有释放前一个资源时 很容易发生死锁 尽量让资源顺序一致"}]},{"ID":"20230817161959-qw67nh9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161959-qw67nh9","updated":"20230817161959"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DeadLockAppMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"程序开始\");\n\n        AppResources appResources = new AppResources();\n        Thread t1 = new Thread(new Task1(appResources), \"Thread-For-Task1\");\n        t1.start();\n        Thread t2 = new Thread(new Task2(appResources), \"Thread-For-Task2\");\n        t2.start();\n\n        t1.join();\n        t2.join();\n        System.out.println(\"程序结束\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161960-qa23cav","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161960-qa23cav","updated":"20230817161960"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Task1 implements Runnable {\n    private AppResources appResources;\n\n    public Task1(AppResources appResources) {\n        this.appResources = appResources;\n    }\n\n    @Override\n    public void run() {\n        synchronized (appResources.getResourceInput()) {\n            System.out.println(\"Task1得到了Input资源\");\n            System.out.println(\"Task1开始工作……\");\n            // TODO 申请到input资源后，模拟工作2秒\n            try {\n                Thread.sleep(TimeUnit.SECONDS.toMillis(2));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            // TODO 然后在不释放input锁的情况下，继续申请printer资源\n            System.out.println(\"Task1尝试去获取Printer资源\");\n            synchronized (appResources.getResourcePrinter()) {\n                System.out.println(\"Task1得到了Printer资源\");\n                System.out.println(\"Task1继续工作……\");\n                try {\n                    Thread.sleep(TimeUnit.SECONDS.toMillis(3));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161961-r3dysds","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161961-r3dysds","updated":"20230817161961"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Task2 implements  Runnable {\n    private AppResources appResources;\n\n    public Task2(AppResources appResources) {\n        this.appResources = appResources;\n    }\n\n    @Override\n    public void run() {\n        // TODO 申请资源顺序不同，可能会造成死锁\n        differentSeq();\n\n        // TODO 申请资源顺序相同，可以避免死锁，但是会降低资源的使用效率\n//        sameSeq();\n    }\n\n    private void differentSeq(){\n        synchronized (appResources.getResourcePrinter()) {\n            // TODO 先申请printer资源\n            System.out.println(\"Task2得到了Printer资源\");\n            System.out.println(\"Task2开始工作……\");\n            try {\n                Thread.sleep(TimeUnit.SECONDS.toMillis(3));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            // TODO 工作3秒中，在不释放printer资源的情况下，继续申请input资源\n            System.out.println(\"Task2尝试去获取Input资源\");\n            synchronized (appResources.getResourceInput()) {\n                System.out.println(\"Task2得到了Input资源\");\n                System.out.println(\"Task2继续工作……\");\n                try {\n                    Thread.sleep(TimeUnit.SECONDS.toMillis(2));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void sameSeq(){\n        synchronized (appResources.getResourceInput()) {\n            System.out.println(\"Task2得到了Input资源\");\n            System.out.println(\"Task2开始工作……\");\n            try {\n                Thread.sleep(TimeUnit.SECONDS.toMillis(3));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Task2尝试去获取Printer资源\");\n            synchronized (appResources.getResourcePrinter()) {\n                System.out.println(\"Task2得到了Printer资源\");\n                System.out.println(\"Task2继续工作……\");\n                try {\n                    Thread.sleep(TimeUnit.SECONDS.toMillis(2));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161962-vassema","Type":"NodeParagraph","Properties":{"id":"20230817161962-vassema","updated":"20230817161962"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"volatile用来修饰成员变量 他可以尽可能的避免指令重排"}]},{"ID":"20230817161963-hyprs4p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161963-hyprs4p","updated":"20230817161963"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class DataHolder {\n    int a, b, c, d, f, g;\n        long e;\n    // TODO 有 volatile 修饰就会影响之前的指令重排\n//    volatile long e;\n\n    public void operateData() {\n        // TODO 按照这个顺序执行，g 的值是肯定小于等于 e 的。但是实际执行在执行的时候，可能会为了优化的目的重排\n        a += 1;\n        b += 1;\n        c += 1;\n        d += 1;\n\n        e += 1;\n\n        f += 1;\n        g += 1;\n    }\n\n    int counter;\n\n    public void check() {\n        // TODO 看似不可能的条件，实际可能被触发到\n        if (g \u003e e) {\n            System.out.println(\"got it \" + (counter++));\n        }\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161964-jw39ikm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161964-jw39ikm","updated":"20230817161964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VolatileAppMain {\n    public static void main(String[] args) {\n        DataHolder dataHolder = new DataHolder();\n        Thread operator = new Thread(() -\u003e {\n            while (true) {\n                dataHolder.operateData();\n            }\n        });\n        operator.start();\n\n        Thread checker = new Thread(() -\u003e {\n            while (true) {\n                dataHolder.check();\n            }\n        });\n        checker.start();\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161965-fa6rl6b","Type":"NodeParagraph","Properties":{"id":"20230817161965-fa6rl6b","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"不用volatile修饰 会一直执行"}]},{"ID":"20230817161966-uyenhwx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161966-uyenhwx","updated":"20230817161966"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"got it 144079\ngot it 144080\ngot it 144081\ngot it 144082\ngot it 144083\ngot it 144084\ngot it 144085\ngot it 144086\ngot it 144087\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161967-64zhfj9","Type":"NodeParagraph","Properties":{"id":"20230817161967-64zhfj9","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"用volatile修饰e 即保证了代码的执行顺序"}]},{"ID":"20230817161968-2whugq8","Type":"NodeParagraph","Properties":{"id":"20230817161968-2whugq8","updated":"20230817161968"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"同时他每次读取数据不是从cpu的缓存中读取 而是从线程的内存中读取"}]},{"ID":"20230817161969-sz0ubht","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161969-sz0ubht","updated":"20230817161969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.volatileDemo;\n\n/**\n * author pyy\n * version 1.0\n */\npublic class AccessMemoryVolatile {\n    public volatile long counterV = 0;\n    public long counter = 0;\n\n    public static void main(String[] args) {\n        int loopCount = Integer.MAX_VALUE / 30;\n        // TODO 只是为了演示 volatile 每次访问都要直达内存，不能使用缓存，所以耗费的时间略多\n        AccessMemoryVolatile accessMemoryVolatile = new AccessMemoryVolatile();\n        Thread volatileAdder = new Thread(() -\u003e {\n            long start = System.currentTimeMillis();\n            for (int i = 0; i \u003c loopCount; i++) {\n                accessMemoryVolatile.counterV++;\n            }\n            System.out.println(\"volatile adder takes \" + (System.currentTimeMillis() - start));\n        });\n        volatileAdder.start();\n\n        Thread justAdder = new Thread(() -\u003e {\n            long start = System.currentTimeMillis();\n            for (int i = 0; i \u003c loopCount; i++) {\n                accessMemoryVolatile.counter++;\n            }\n            System.out.println(\"simple adder takes \" + (System.currentTimeMillis() - start));\n        });\n        justAdder.start();\n    }\n}\n结果：\nsimple adder takes 9\nvolatile adder takes 374\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}