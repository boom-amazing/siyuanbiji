{"ID":"20230817161932-y3h9gc5","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161932-y3h9gc5","title":"javase","updated":"20230817161932"},"Children":[{"ID":"20230817161933-z0zukm9","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161933-z0zukm9","updated":"20230817161933"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"jdk、jvm、jre的区别"}]},{"ID":"20230817161934-vohcgb2","Type":"NodeParagraph","Properties":{"id":"20230817161934-vohcgb2","updated":"20230817161934"},"Children":[{"Type":"NodeText","Data":"jdk视功能齐全的sdk 它拥有jre所拥有的一切 同时它还拥有javac javadoc 它能够创建和编译程序"}]},{"ID":"20230817161935-o4tl0gg","Type":"NodeParagraph","Properties":{"id":"20230817161935-o4tl0gg","updated":"20230817161935"},"Children":[{"Type":"NodeText","Data":"jre是java运行时的环境 他是用来运行已经编译的java程序所需要的一切内容的集合 包括jvm、java类库、java命令等 但是他不能创建新的程序"}]},{"ID":"20230817161936-yzslrq7","Type":"NodeParagraph","Properties":{"id":"20230817161936-yzslrq7","updated":"20230817161936"},"Children":[{"Type":"NodeText","Data":"而jvm是用于执行java字节码的虚拟机 对于不同系统 jvm都有特定的实现 对于相同的字节码他都会产生相同的结果 这就是java一次编译 随处执行的关键所在"}]},{"ID":"20230817161937-96b0id7","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161937-96b0id7","updated":"20230817161937"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"java是编译性语言还是解释性语言？"}]},{"ID":"20230817161938-kzgcq6m","Type":"NodeParagraph","Properties":{"id":"20230817161938-kzgcq6m","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"java即是编译性语言也是解释性语言 因为java编写的程序需要先通过javac编译成.class文件 也就是生成字节码 然后这种字节码再被jvm中的JIT这种解释器解析成机器码执行"}]},{"ID":"20230817161939-e8v210j","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161939-e8v210j","updated":"20230817161939"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"静态方法为什么不能调用非静态方法？"}]},{"ID":"20230817161940-pepgi2f","Type":"NodeParagraph","Properties":{"id":"20230817161940-pepgi2f","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"1、静态方法是属于类的 在类加载过程就会分配内存 可以通过类名直接访问 而非静态方法是属于实例对象的 只有在对象实例化后才能被访问"}]},{"ID":"20230817161941-5mulo59","Type":"NodeParagraph","Properties":{"id":"20230817161941-5mulo59","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"2、在类的非静态成员不存在的时候静态成员就已经存在了 此时调用还不存在内存中的非静态方法自然不行"}]},{"ID":"20230817161942-zoeye5t","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161942-zoeye5t","updated":"20230817161942"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"==和equals的区别"}]},{"ID":"20230817161943-brgjp9j","Type":"NodeParagraph","Properties":{"id":"20230817161943-brgjp9j","updated":"20230817161943"},"Children":[{"Type":"NodeText","Data":"==对于基础数据类型是用来判断两个值是否相同 而对于引用类型是判断两个对象的地址是否相同"}]},{"ID":"20230817161944-cui1896","Type":"NodeParagraph","Properties":{"id":"20230817161944-cui1896","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"equals方法对于基础数据类型没有该方法 而对于引用数据类型 如果引用数据类型重写了该方法 那么就是用来判断两个对象的值是否相同 没有重写该方法 就会默认调用object的equals方法 object的equals方法是== 即判断两个对象地址是否相同"}]},{"ID":"20230817161945-9lks2ad","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161945-9lks2ad","updated":"20230817161945"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"重写和重载的区别"}]},{"ID":"20230817161946-keoytdz","Type":"NodeParagraph","Properties":{"id":"20230817161946-keoytdz","updated":"20230817161946"},"Children":[{"Type":"NodeText","Data":"重载发生在同一个类中 方法名必须相同 参数的个数 顺序 类型以及返回值可以不同"}]},{"ID":"20230817161947-yroi5e6","Type":"NodeParagraph","Properties":{"id":"20230817161947-yroi5e6","updated":"20230817161947"},"Children":[{"Type":"NodeText","Data":"重写发生在运行期"}]},{"ID":"20230817161948-huaachm","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161948-huaachm","updated":"20230817161948"},"Children":[{"ID":"20230817161949-yooz64z","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161949-yooz64z","updated":"20230817161949"},"Children":[{"ID":"20230817161950-8m3op69","Type":"NodeParagraph","Properties":{"id":"20230817161950-8m3op69","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"是子类对父类的方法进行重新编写 子类方法的返回值 以及抛出的异常值的返回必须比父类中的小 同时参数类型 顺序 个数必须一致 且修饰符的访问范围必须大于父类"}]}]},{"ID":"20230817161951-cjzrug4","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161951-cjzrug4","updated":"20230817161951"},"Children":[{"ID":"20230817161952-nn0e00f","Type":"NodeParagraph","Properties":{"id":"20230817161952-nn0e00f","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"父类被private、static、final修饰的方法不能够被重写"}]}]},{"ID":"20230817161953-2zn2zkt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161953-2zn2zkt","updated":"20230817161953"},"Children":[{"ID":"20230817161954-5w1dsxg","Type":"NodeParagraph","Properties":{"id":"20230817161954-5w1dsxg","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"构造方法也不能被重写"}]}]}]},{"ID":"20230817161955-gjtgm3w","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161955-gjtgm3w","updated":"20230817161955"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么重写equals时要重写hashcode？"}]},{"ID":"20230817161956-jv38hvt","Type":"NodeParagraph","Properties":{"id":"20230817161956-jv38hvt","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"因为在进行equals判断时 首先会进行hashcode的判断 如果hashcode值不相同的话 就会直接判定两个对象不相同 如果没有重写hashcode方法的话 默认会调用父类的hashcode方法 因为两个对象的地址值通过哈希算法所映射的散列码是不同的 所以这个equals方法就会返回false来判定这两个对象不同"}]},{"ID":"20230817161957-axt9nod","Type":"NodeParagraph","Properties":{"id":"20230817161957-axt9nod","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"那为什么equals方法中要加入hashcode方法呢"}]},{"ID":"20230817161958-ynjmiii","Type":"NodeParagraph","Properties":{"id":"20230817161958-ynjmiii","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"主要是可以提高equals判断的效率 因为大概率两个对象是不同的的 所以他们的hashcode也不同 这样如果两个对象的hashcode不同 那么就可以直接返回fasle了"}]},{"ID":"20230817161959-u2rgizd","Type":"NodeParagraph","Properties":{"id":"20230817161959-u2rgizd","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"那可不可以直接通过hashcode来判断两个对象是否相同呢？"}]},{"ID":"20230817161960-hn1v11f","Type":"NodeParagraph","Properties":{"id":"20230817161960-hn1v11f","updated":"20230817161960"},"Children":[{"Type":"NodeText","Data":"不能 因为再好的hash算法也可能会发生哈希碰撞 这样的话会导致两个可能不同的对象因为哈希碰撞而判定为相同"}]},{"ID":"20230817161961-dsqw7fz","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161961-dsqw7fz","updated":"20230817161961"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"包装类型的常量池技术"}]},{"ID":"20230817161962-nah3ewu","Type":"NodeParagraph","Properties":{"id":"20230817161962-nah3ewu","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"java中的基本类型 列入Byte，Short、Integer、Long这四种包装类都会创建数值为【-128，127】相应类型的缓存区域 Character会创建数值为[0,127]的缓存区域"}]},{"ID":"20230817161963-lm0qwba","Type":"NodeParagraph","Properties":{"id":"20230817161963-lm0qwba","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"Float 和Double没有实现常量池计数"}]},{"ID":"20230817161964-wca0ocd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161964-wca0ocd","updated":"20230817161964"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"  public static void main(String[] args) {\n        Integer a=40;\n        Integer b=40;\n        System.out.println(a==b);//true 会调用常量池\n        Float f1=10.0f;\n        Float f2=10.0f;\n        System.out.println(f1==f2);//不会调用常量池\n        Integer i1=40;//会自动装箱 调用Integer.valueOf(num)方法 然后该方法会调用常量池中的数据\n        Integer i2=new Integer(40);\n        System.out.println(i1==i2);//false\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161965-2ptfmat","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161965-2ptfmat","updated":"20230817161965"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动装箱与拆箱"}]},{"ID":"20230817161966-dwksbab","Type":"NodeParagraph","Properties":{"id":"20230817161966-dwksbab","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"装箱：就是将基本类型用它对应的引用类型包装起来"}]},{"ID":"20230817161967-zgltn2m","Type":"NodeParagraph","Properties":{"id":"20230817161967-zgltn2m","updated":"20230817161967"},"Children":[{"Type":"NodeText","Data":"拆箱：将包装类型转化为基本数据类型"}]},{"ID":"20230817161968-alh015r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161968-alh015r","updated":"20230817161968"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":" public static void main(String[] args) {\n        Integer i1=10;//装箱 调用valueof方法\n        int n=i1;//拆箱 调用intvalue方法\n    }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161969-kpvg4ti","Type":"NodeParagraph","Properties":{"id":"20230817161969-kpvg4ti","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"注意：尽量不要频繁使用装箱 和拆箱 会影响程序性能"}]}]}