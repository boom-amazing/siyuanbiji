{"ID":"20230817161926-5usvnhu","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161926-5usvnhu","title":"java实现生产者与消费者模式","updated":"20230817161926"},"Children":[{"ID":"20230817161927-zgjxnze","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161927-zgjxnze","updated":"20230817161927"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"java实现生产者与消费者模式"}]},{"ID":"20230817161928-1uvisd9","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161928-1uvisd9","updated":"20230817161928"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"消费者的消费方式"}]},{"ID":"20230817161929-8xb7bsi","Type":"NodeParagraph","Properties":{"id":"20230817161929-8xb7bsi","updated":"20230817161929"},"Children":[{"Type":"NodeText","Data":"消费者每次消费数据时会查找上次消费所记录的offset 按照offset进行最新的数据消费"}]},{"ID":"20230817161930-welzs1w","Type":"NodeParagraph","Properties":{"id":"20230817161930-welzs1w","updated":"20230817161930"},"Children":[{"Type":"NodeText","Data":"同时每次消费数据时会记录当前消费数据的offset 默认是自动提交 且每隔五秒提交一次"}]},{"ID":"20230817161931-t149twn","Type":"NodeParagraph","Properties":{"id":"20230817161931-t149twn","updated":"20230817161931"},"Children":[{"Type":"NodeText","Data":"当第一次消费数据或者是消费的数据过期时就会重新启动消费模式 但默认还是消费最新的数据"}]},{"ID":"20230817161932-qxsmxzf","Type":"NodeParagraph","Properties":{"id":"20230817161932-qxsmxzf","updated":"20230817161932"},"Children":[{"Type":"NodeText","Data":"也可以设置成earliest 、none这两种其他类型"}]},{"ID":"20230817161933-0ayxgi8","Type":"NodeParagraph","Properties":{"id":"20230817161933-0ayxgi8","updated":"20230817161933"},"Children":[{"Type":"NodeText","Data":"生产者代码："}]},{"ID":"20230817161934-29x3ql0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161934-29x3ql0","updated":"20230817161934"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.kafak;\n\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\n\nimport java.util.Properties;\n\npublic class ProducerDemo {\n    public static void main(String[] args) {\n        Properties properties = new Properties();\n        properties.put(\"bootstrap.servers\",\"bigdata01:9092,bigdata02:9092,bigdata03:9092\");\n        properties.put(\"key.serializer\", StringSerializer.class.getName());\n        properties.put(\"value.serializer\", StringSerializer.class.getName());\n\n        KafkaProducer\u003cString, String\u003e producer =\n                new KafkaProducer\u003cString, String\u003e(properties);\n        String topic=\"hello\";\n        producer.send(new ProducerRecord\u003cString, String\u003e(topic,\"hello kafka\"));\n        producer.close();\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161935-jgxcoxw","Type":"NodeParagraph","Properties":{"id":"20230817161935-jgxcoxw","updated":"20230817161935"},"Children":[{"Type":"NodeText","Data":"消费者代码："}]},{"ID":"20230817161936-xrvbmyu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161936-xrvbmyu","updated":"20230817161936"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"package com.pyy.kafak;\n\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\n\nimport java.lang.reflect.Array;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Properties;\n\npublic class ConsumerDemo {\n    public static void main(String[] args) {\n        Properties properties = new Properties();\n        properties.put(\"bootstrap.servers\",\"bigdata01:9092,bigdata02:9092,bigdata03:9092\");\n        properties.put(\"key.deserializer\", StringDeserializer.class.getName());\n        properties.put(\"value.deserializer\", StringDeserializer.class.getName());\n        properties.put(\"enable.auto.commit\",\"true\");\n\n        properties.put(\"group.id\",\"con-2\");\n        properties.put(\"enable.auto.commit\",\"true\");//默认\n        properties.put(\"auto.commit.interval.ms\",\"5000\");//默认\n        properties.put(\"auto.offset.reset\",\"earliest\");//这个只能在数据第一次消费 以及查找到的\n        //offset过期时才会触发 其他任何时候都是默认消费最新的数据\n        KafkaConsumer\u003cString, String\u003e consumer =\n                new KafkaConsumer(properties);\n        Collection\u003cString\u003etopics=new ArrayList\u003cString\u003e();\n        topics.add(\"hello\");\n        consumer.subscribe(topics);\n        while (true){\n            ConsumerRecords\u003cString, String\u003e polls = consumer.poll(Duration.ofSeconds(1));\n            for(ConsumerRecord\u003cString,String\u003e record:polls){\n                System.out.println(record);\n            }\n\n        }\n    }\n}\n\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161937-ruhzj91","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161937-ruhzj91","updated":"20230817161937"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Consumer消费offset查询"}]},{"ID":"20230817161938-j1r9bhu","Type":"NodeParagraph","Properties":{"id":"20230817161938-j1r9bhu","updated":"20230817161938"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"kafka0.9"},{"Type":"NodeText","Data":"版本以前，消费者的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"offset"},{"Type":"NodeText","Data":"信息保存在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"zookeeper"},{"Type":"NodeText","Data":"中"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"从"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"kafka0.9"},{"Type":"NodeText","Data":"开始，使用了新的消费API，消费者的信息会保存在kafka里面的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"__consumer_offsets"},{"Type":"NodeText","Data":"这个topic中"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"因为频繁操作zookeeper性能不高，所以kafka在自己的topic中负责维护消费者的offset信息。"}]},{"ID":"20230817161939-ex6u4fk","Type":"NodeBlockquote","Properties":{"id":"20230817161939-ex6u4fk","updated":"20230817161939"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161940-z9zrw3f","Type":"NodeParagraph","Properties":{"id":"20230817161940-z9zrw3f","updated":"20230817161940"},"Children":[{"Type":"NodeText","Data":"如何查询保存在kafka中的Consumer的offset信息呢？"}]}]},{"ID":"20230817161941-7lx860v","Type":"NodeParagraph","Properties":{"id":"20230817161941-7lx860v","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"kafka-consumer-groups.sh"},{"Type":"NodeText","Data":"这个脚本可以查看"}]},{"ID":"20230817161942-qn0izjq","Type":"NodeParagraph","Properties":{"id":"20230817161942-qn0izjq","updated":"20230817161942"},"Children":[{"Type":"NodeText","Data":"查看目前所有的consumer group"}]},{"ID":"20230817161943-tow7yep","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161943-tow7yep","updated":"20230817161943"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[root@bigdata01 kafka_2.12-2.4.1]# bin/kafka-consumer-groups.sh --list  --bootstrap-server localhost:9092\ncon-1\ncon-2\n代码块123\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161944-s9byx6z","Type":"NodeParagraph","Properties":{"id":"20230817161944-s9byx6z","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"具体查看某一个consumer group的信息"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"GROUP：当前消费者组，通过group.id指定的值"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"TOPIC：当前消费的topic"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"PARTITION：消费的分区"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"CURRENT-OFFSET：消费者消费到这个分区的offset"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"LOG-END-OFFSET：当前分区中数据的最大offset"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"LAG：当前分区未消费数据量"}]},{"ID":"20230817161945-s53ml1j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161945-s53ml1j","updated":"20230817161945"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[root@bigdata01 kafka_2.12-2.4.1]# bin/kafka-consumer-groups.sh --describe  --bootstrap-server localhost:9092 --group con-1\nGROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID\ncon-1           hello           4          1               1               0               -               -               -\ncon-1           hello           2          1               1               0               -               -               -\ncon-1           hello           3          1               1               0               -               -               -\ncon-1           hello           0          0               0               0               -               -               -\ncon-1           hello           1          0               0               0               -               -               -\n代码块1234567\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161946-b3eb8i7","Type":"NodeParagraph","Properties":{"id":"20230817161946-b3eb8i7","updated":"20230817161946"},"Children":[{"Type":"NodeText","Data":"此时再执行一次生产者代码，生产一条数据，重新查看一下这个消费者的offset情况"}]},{"ID":"20230817161947-jfl7or7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161947-jfl7or7","updated":"20230817161947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"[root@bigdata01 kafka_2.12-2.4.1]# bin/kafka-consumer-groups.sh --describe  --bootstrap-server localhost:9092 --group con-1\nGROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID\ncon-1           hello           4          1               2               1               -               -               -\ncon-1           hello           2          1               1               0               -               -               -\ncon-1           hello           3          1               1               0               -               -               -\ncon-1           hello           0          0               0               0               -               -               -\ncon-1           hello           1          0               0               0               -               -               -\n代码块1234567\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161948-5wd17w5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161948-5wd17w5","updated":"20230817161948"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Consumer消费顺序"}]},{"ID":"20230817161949-y91qj46","Type":"NodeParagraph","Properties":{"id":"20230817161949-y91qj46","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"当一个消费者消费一个partition时候，消费的数据顺序和此partition数据的生产顺序是一致的"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当一个消费者消费多个partition时候，消费者按照partition的顺序，首先消费一个partition，当消费完一个partition最新的数据后再消费其它partition中的数据"}]},{"ID":"20230817161950-y2s104m","Type":"NodeBlockquote","Properties":{"id":"20230817161950-y2s104m","updated":"20230817161950"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161951-f22sxxx","Type":"NodeParagraph","Properties":{"id":"20230817161951-f22sxxx","updated":"20230817161951"},"Children":[{"Type":"NodeText","Data":"总之：如果一个消费者消费多个partiton，只能保证消费的数据顺序在一个partition内是有序的"}]}]},{"ID":"20230817161952-73ydgtg","Type":"NodeParagraph","Properties":{"id":"20230817161952-73ydgtg","updated":"20230817161952"},"Children":[{"Type":"NodeText","Data":"也就是说消费kafka中的数据只能保证消费partition内的数据是有序的，多个partition之间是无序的。"}]},{"ID":"20230817161953-t3a529u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161953-t3a529u","updated":"20230817161953"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"Kafka的三种语义"}]},{"ID":"20230817161954-cp89c30","Type":"NodeParagraph","Properties":{"id":"20230817161954-cp89c30","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"kafka可以实现以下三种语义，这三种语义是针对消费者而言的："}]},{"ID":"20230817161955-jgf6vyy","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161955-jgf6vyy","updated":"20230817161955"},"Children":[{"ID":"20230817161956-39e949y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161956-39e949y","updated":"20230817161956"},"Children":[{"ID":"20230817161957-tah1ny5","Type":"NodeParagraph","Properties":{"id":"20230817161957-tah1ny5","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"至少一次：at-least-once"}]}]}]},{"ID":"20230817161958-nk433j1","Type":"NodeParagraph","Properties":{"id":"20230817161958-nk433j1","updated":"20230817161958"},"Children":[{"Type":"NodeText","Data":"这种语义有可能会对数据重复处理"}]},{"ID":"20230817161959-zyy7g3z","Type":"NodeParagraph","Properties":{"id":"20230817161959-zyy7g3z","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"实现至少一次消费语义的消费者也很简单。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"1: 设置enable.auto.commit为false，禁用自动提交offset"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"2: 消息处理完之后手动调用consumer.commitSync()提交offset"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这种方式是在消费数据之后，手动调用函数consumer.commitSync()异步提交offset，"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"有可能处理多次的场景是消费者的消息处理完并输出到结果库，但是offset还没提交，这个时候消费者挂掉了，再重启的时候会重新消费并处理消息，所以至少会处理一次"}]},{"ID":"20230817161960-lcixx68","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161960-lcixx68","updated":"20230817161960"},"Children":[{"ID":"20230817161961-krmqmz2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161961-krmqmz2","updated":"20230817161961"},"Children":[{"ID":"20230817161962-hzd7k4r","Type":"NodeParagraph","Properties":{"id":"20230817161962-hzd7k4r","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"至多一次：at-most-once"}]}]}]},{"ID":"20230817161963-95pwc60","Type":"NodeParagraph","Properties":{"id":"20230817161963-95pwc60","updated":"20230817161963"},"Children":[{"Type":"NodeText","Data":"这种语义有可能会丢失数据"}]},{"ID":"20230817161964-uvciidg","Type":"NodeParagraph","Properties":{"id":"20230817161964-uvciidg","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"至多一次消费语义是kafka消费者的默认实现。配置这种消费者最简单的方式是"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"1: enable.auto.commit设置为true。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"2: auto.commit.interval.ms设置为一个较低的时间范围。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"由于上面的配置，此时kafka会有一个独立的线程负责按照指定间隔提交offset。"}]},{"ID":"20230817161965-ium7kl6","Type":"NodeParagraph","Properties":{"id":"20230817161965-ium7kl6","updated":"20230817161965"},"Children":[{"Type":"NodeText","Data":"消费者的offset已经提交，但是消息还在处理中(还没有处理完)，这个时候程序挂了，导致数据没有被成功处理，再重启的时候会从上次提交的offset处消费，导致上次没有被成功处理的消息就丢失了。"}]},{"ID":"20230817161966-rk25728","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161966-rk25728","updated":"20230817161966"},"Children":[{"ID":"20230817161967-lmvradp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161967-lmvradp","updated":"20230817161967"},"Children":[{"ID":"20230817161968-o11o2zn","Type":"NodeParagraph","Properties":{"id":"20230817161968-o11o2zn","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"仅一次：exactly-once"}]}]}]},{"ID":"20230817161969-7jgbjry","Type":"NodeParagraph","Properties":{"id":"20230817161969-7jgbjry","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"这种语义可以保证数据只被消费处理一次。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"实现仅一次语义的思路如下："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"1: 将enable.auto.commit设置为false，禁用自动提交offset"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"2: 使用consumer.seek(topicPartition，offset)来指定offset"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"3: 在处理消息的时候，要同时保存住每个消息的offset。以原子事务的方式保存offset和处理的消息结果，这个时候相当于自己保存offset信息了，把offset和具体的数据绑定到一块，数据真正处理成功的时候才会保存offset信息"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"这样就可以保证数据仅被处理一次了。"}]}]}