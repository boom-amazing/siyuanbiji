{"ID":"20230817161712-cdw8w97","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161712-cdw8w97","title":"kafka核心原理","updated":"20230817161712"},"Children":[{"ID":"20230817161713-1kzib8l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20230817161713-1kzib8l","updated":"20230817161713"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"核心原理"}]},{"ID":"20230817161714-hu48349","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161714-hu48349","updated":"20230817161714"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"生产者消息分区特性剖析"}]},{"ID":"20230817161715-tcedxcs","Type":"NodeParagraph","Properties":{"id":"20230817161715-tcedxcs","updated":"20230817161715"},"Children":[{"Type":"NodeText","Data":"首先为什么要分区？"}]},{"ID":"20230817161716-jcfdqi9","Type":"NodeParagraph","Properties":{"id":"20230817161716-jcfdqi9","updated":"20230817161716"},"Children":[{"Type":"NodeText","Data":"分区可以是系统达到负载均很 同时能够提高系统的伸缩性 同时他在一定程度上还可以实现业务级别的消息顺序处理"}]},{"ID":"20230817161717-xa4jbck","Type":"NodeParagraph","Properties":{"id":"20230817161717-xa4jbck","updated":"20230817161717"},"Children":[{"Type":"NodeText","Data":"分区策略："}]},{"ID":"20230817161718-lc7wrnl","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161718-lc7wrnl","updated":"20230817161718"},"Children":[{"ID":"20230817161719-gdct0s6","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161719-gdct0s6","updated":"20230817161719"},"Children":[{"ID":"20230817161720-imt2522","Type":"NodeParagraph","Properties":{"id":"20230817161720-imt2522","updated":"20230817161720"},"Children":[{"Type":"NodeText","Data":"轮询策略 就是顺序分配策略 给每个分区按照顺序依次发送消息 默认情况就是轮询"}]}]},{"ID":"20230817161721-l2a9jje","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161721-l2a9jje","updated":"20230817161721"},"Children":[{"ID":"20230817161722-umwlhpg","Type":"NodeParagraph","Properties":{"id":"20230817161722-umwlhpg","updated":"20230817161722"},"Children":[{"Type":"NodeText","Data":"随即策略 字面上意思就是随机发送"}]}]},{"ID":"20230817161723-qmwcrn9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161723-qmwcrn9","updated":"20230817161723"},"Children":[{"ID":"20230817161724-29dnjoc","Type":"NodeParagraph","Properties":{"id":"20230817161724-29dnjoc","updated":"20230817161724"},"Children":[{"Type":"NodeText","Data":"还有一种就是跨地区的分区策略 根据地区所在的ip来分区"}]}]},{"ID":"20230817161725-urj8g0i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161725-urj8g0i","updated":"20230817161725"},"Children":[{"ID":"20230817161726-dvr2ovk","Type":"NodeParagraph","Properties":{"id":"20230817161726-dvr2ovk","updated":"20230817161726"},"Children":[{"Type":"NodeText","Data":"按消息键保存的策略：Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。特别是在 Kafka 不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略"}]},{"ID":"20230817161727-eb8f9pc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161727-eb8f9pc","updated":"20230817161727"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\nList\u003cPartitionInfo\u003e partitions = cluster.partitionsForTopic(topic);\nreturn Math.abs(key.hashCode()) % partitions.size();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161728-or0ath8","Type":"NodeParagraph","Properties":{"id":"20230817161728-or0ath8","updated":"20230817161728"},"Children":[{"Type":"NodeText","Data":"前面提到的 Kafka 默认分区策略实际上同时实现了两种策略：如果指定了 Key，那么默认实现按消息键保序策略；如果没有指定 Key，则使用轮询策略。"}]},{"ID":"20230817161729-k6dbxem","Type":"NodeParagraph","Properties":{"id":"20230817161729-k6dbxem","updated":"20230817161729"},"Children":[{"Type":"NodeText","Data":"真实案例：实现业务级别的消息顺序处理 具有因果关系"}]},{"ID":"20230817161730-u8kte8k","Type":"NodeParagraph","Properties":{"id":"20230817161730-u8kte8k","updated":"20230817161730"},"Children":[{"Type":"NodeText","Data":"可以根据业务将消息体中固定的标志位设置专门的分区策略 让相同的key能够在同一个分区"}]}]}]},{"ID":"20230817161731-gmy8bbq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161731-gmy8bbq","updated":"20230817161731"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"生产者压缩算法选择"}]},{"ID":"20230817161732-mef2fem","Type":"NodeParagraph","Properties":{"id":"20230817161732-mef2fem","updated":"20230817161732"},"Children":[{"Type":"NodeText","Data":"首先为什么要压缩 压缩可以减少数据传输时所消耗网络资源 极大的节省时间"}]},{"ID":"20230817161733-40l00ng","Type":"NodeParagraph","Properties":{"id":"20230817161733-40l00ng","updated":"20230817161733"},"Children":[{"Type":"NodeText","Data":"什么时候会发生压缩 在kafka中producer端压缩 broker保持压缩 comsumer解压"}]},{"ID":"20230817161734-290gwso","Type":"NodeParagraph","Properties":{"id":"20230817161734-290gwso","updated":"20230817161734"},"Children":[{"Type":"NodeText","Data":"但有两种情况可能会使broker重新压缩 一是压缩格式转换 但默认broker是尊重producer的压缩方法 二是消息格式的转换 所以在生产中尽量不要让消息格式频繁转换"}]},{"ID":"20230817161735-c6dygod","Type":"NodeParagraph","Properties":{"id":"20230817161735-c6dygod","updated":"20230817161735"},"Children":[{"Type":"NodeText","Data":"对kafka来说 常见的压缩算法性能对比"}]},{"ID":"20230817161736-l6s1ss8","Type":"NodeParagraph","Properties":{"id":"20230817161736-l6s1ss8","updated":"20230817161736"},"Children":[{"Type":"NodeText","Data":"吞吐量：LZ4\u003eSnappy\u003ezstd和GZIP 压缩比方面：zstd\u003eLZ4\u003eGZIP\u003eSNAPPY  吞吐量的含义其是就是压缩速率的比较"}]},{"ID":"20230817161737-fyb0giw","Type":"NodeParagraph","Properties":{"id":"20230817161737-fyb0giw","updated":"20230817161737"},"Children":[{"Type":"NodeText","Data":"所以如果cpu资源充足 且带宽资源匮乏的情况下(一般都是千兆带宽 ) 最好使用压缩比搞得zstd"}]},{"ID":"20230817161738-eprb41j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161738-eprb41j","updated":"20230817161738"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无消息丢失配置"}]},{"ID":"20230817161739-yg0y9bm","Type":"NodeParagraph","Properties":{"id":"20230817161739-yg0y9bm","updated":"20230817161739"},"Children":[{"Type":"NodeText","Data":"首先对kafka的无消息丢失怎么定义"}]},{"ID":"20230817161740-eg1at52","Type":"NodeParagraph","Properties":{"id":"20230817161740-eg1at52","updated":"20230817161740"},"Children":[{"Type":"NodeText","Data":"一句话描述就是 只对已提交的消息进行有限度的持久化 前提是还有broker节点存在"}]},{"ID":"20230817161741-v4m5bkb","Type":"NodeParagraph","Properties":{"id":"20230817161741-v4m5bkb","updated":"20230817161741"},"Children":[{"Type":"NodeText","Data":"什么情况会发生消息丢失呢？"}]},{"ID":"20230817161742-ilpgunz","Type":"NodeParagraph","Properties":{"id":"20230817161742-ilpgunz","updated":"20230817161742"},"Children":[{"Type":"NodeText","Data":"1、生产者丢失数据 说白了就是生产者程序没有将消息成功发送给kafka 也就是kafak没有确认已提交"}]},{"ID":"20230817161743-cnxqzl7","Type":"NodeParagraph","Properties":{"id":"20230817161743-cnxqzl7","updated":"20230817161743"},"Children":[{"Type":"NodeText","Data":"常见的解决方案是使用producer.send(msg, callback) 来显示提示数据是否发送数据成功"}]},{"ID":"20230817161744-wzmoyir","Type":"NodeParagraph","Properties":{"id":"20230817161744-wzmoyir","updated":"20230817161744"},"Children":[{"Type":"NodeText","Data":"二是可以将acks设置为all 即表明所有的分区leader以及flower都受到该消息了 才确认返回收到"}]},{"ID":"20230817161745-ds89lcb","Type":"NodeParagraph","Properties":{"id":"20230817161745-ds89lcb","updated":"20230817161745"},"Children":[{"Type":"NodeText","Data":"三是设置retires的个数 设置为retries\u003e 0 可以在消息发送失败时 重新发送"}]},{"ID":"20230817161746-skv1iz3","Type":"NodeParagraph","Properties":{"id":"20230817161746-skv1iz3","updated":"20230817161746"},"Children":[{"Type":"NodeText","Data":"四是将min.insync.replicas \u003e 1  这个1可以修改。//这个的理解是 如果有flower挂掉了 那么至少要有1个分区响应收到"}]},{"ID":"20230817161747-b7h83py","Type":"NodeParagraph","Properties":{"id":"20230817161747-b7h83py","updated":"20230817161747"},"Children":[{"Type":"NodeText","Data":"五就是多设置几个副本 通过消息冗余的方式来尽量让消息不丢失"}]},{"ID":"20230817161748-5lluiwk","Type":"NodeParagraph","Properties":{"id":"20230817161748-5lluiwk","updated":"20230817161748"},"Children":[{"Type":"NodeText","Data":"2、消费者丢失数据"}]},{"ID":"20230817161749-0ojsea1","Type":"NodeParagraph","Properties":{"id":"20230817161749-0ojsea1","updated":"20230817161749"},"Children":[{"Type":"NodeText","Data":"因为消费者在消费数据时 是按照offset进行消费的 如果某次消费过程消费还没有结束 offset已经更新 那么如果此时消费程序挂掉了 下次在消费的时候 就会导致数据少消费了 列如我只消费了90-95 这个时候offset已经更新到了 100 那么96-99 数据就丢失了"}]},{"ID":"20230817161750-wr3h4gw","Type":"NodeParagraph","Properties":{"id":"20230817161750-wr3h4gw","updated":"20230817161750"},"Children":[{"Type":"NodeText","Data":"解决方法是可以将默认的自动提交改为手动提交 即等到消费程序执行完毕后再更新offset 但其实这种情况可能会导致重复消费 但至少不会数据丢失(比如消费者已经消费完数据 但是在提交offset时 程序挂掉了 那么offset没有自动更新 下次在消费时 又会重新消费这段数据)"}]},{"ID":"20230817161751-7of5mv8","Type":"NodeParagraph","Properties":{"id":"20230817161751-7of5mv8","updated":"20230817161751"},"Children":[{"Type":"NodeText","Data":"在上述情况下也可能发生Consumer 程序从 Kafka 获取到消息后开启了多个线程异步处理消息，而 Consumer 程序自动地向前更新位移。假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于 Consumer 而言实际上是丢失了。"}]},{"ID":"20230817161752-953yhvu","Type":"NodeParagraph","Properties":{"id":"20230817161752-953yhvu","updated":"20230817161752"},"Children":[{"Type":"NodeText","Data":"解决方法更上面一样 就是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移。"}]},{"ID":"20230817161753-vjr2bt5","Type":"NodeParagraph","Properties":{"id":"20230817161753-vjr2bt5","updated":"20230817161753"},"Children":[{"Type":"NodeText","Data":"3、重新指定分区"}]},{"ID":"20230817161754-jixspg0","Type":"NodeParagraph","Properties":{"id":"20230817161754-jixspg0","updated":"20230817161754"},"Children":[{"Type":"NodeText","Data":"如果对某个topic重新增加了分区 这个时候producer感知到了 但consumer还没有感知到 如果在此期间向该分区写入了消息 consumer在下一次感知到时 只会默认读取最新的数据 那么之前的消息就丢失掉了"}]},{"ID":"20230817161755-88c7rvt","Type":"NodeParagraph","Properties":{"id":"20230817161755-88c7rvt","updated":"20230817161755"},"Children":[{"Type":"NodeText","Data":"解决方法其实就是让kafka的默认最新读取改为从最早读取 但这种方式其实也是重复读取了"}]},{"ID":"20230817161756-ber6skg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161756-ber6skg","updated":"20230817161756"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"auto.offset.reset=earliest\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161757-vju2h9d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161757-vju2h9d","updated":"20230817161757"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"kafka消息交付的可靠性以及精确一次语义的实现"}]},{"ID":"20230817161758-uplxnxj","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161758-uplxnxj","updated":"20230817161758"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"所谓消息交付可靠性保证 是指kafka对producer和consumer要处理的消息提供什么承诺"}]},{"ID":"20230817161759-1oaz35m","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161759-1oaz35m","updated":"20230817161759"},"Children":[{"ID":"20230817161760-eb77evn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161760-eb77evn","updated":"20230817161760"},"Children":[{"ID":"20230817161761-zwygt6k","Type":"NodeParagraph","Properties":{"id":"20230817161761-zwygt6k","updated":"20230817161761"},"Children":[{"Type":"NodeText","Data":"最多一次：消息可能会丢失 但绝不会重复"}]}]},{"ID":"20230817161762-oxbwzr3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161762-oxbwzr3","updated":"20230817161762"},"Children":[{"ID":"20230817161763-9p8m6rl","Type":"NodeParagraph","Properties":{"id":"20230817161763-9p8m6rl","updated":"20230817161763"},"Children":[{"Type":"NodeText","Data":"最少一次：消息不会丢失 但会重复"}]}]},{"ID":"20230817161764-vys1qza","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161764-vys1qza","updated":"20230817161764"},"Children":[{"ID":"20230817161765-f0w0rp1","Type":"NodeParagraph","Properties":{"id":"20230817161765-f0w0rp1","updated":"20230817161765"},"Children":[{"Type":"NodeText","Data":"精准一次：消息及不丢失也不重复"}]}]}]},{"ID":"20230817161766-6pry4ck","Type":"NodeParagraph","Properties":{"id":"20230817161766-6pry4ck","updated":"20230817161766"},"Children":[{"Type":"NodeText","Data":"在生产者默认提供的是最少一次的保证、即生产者要确认broker端接收到了消息 如果因为网络延时而没有得到broker端的响应 超过一段时间 生产者就会重发消息"}]},{"ID":"20230817161767-0pay506","Type":"NodeParagraph","Properties":{"id":"20230817161767-0pay506","updated":"20230817161767"},"Children":[{"Type":"NodeText","Data":"在消费者默认提供的是最多一次的保证 因为默认是自动提交 提交动作和消费动作是不具有原子性的 他们两个是两个线程处理 所以如果消费offset已经提交 而消费线程挂掉 下次再消费时就会丢失消息"}]},{"ID":"20230817161768-x05aaiu","Type":"NodeParagraph","Properties":{"id":"20230817161768-x05aaiu","updated":"20230817161768"},"Children":[{"Type":"NodeText","Data":"生产者如果业务对消息的丢失不那么重要 也可以开启最多一次 将重写机制关掉即可 反观消费者 如果想要保证数据不丢失 也可以关闭自动提交 改为手动提交 即消息消费完毕后异步提交"}]},{"ID":"20230817161769-y3oig2p","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161769-y3oig2p","updated":"20230817161769"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"无论怎样 最多一次和最少一次都没有精准一次更有诱惑力"}]},{"ID":"20230817161770-fduwcmq","Type":"NodeParagraph","Properties":{"id":"20230817161770-fduwcmq","updated":"20230817161770"},"Children":[{"Type":"NodeText","Data":"在producer端 如果要保证精准一次 有两种方法 一个是幂等生产者 一个是事务生产者"}]},{"ID":"20230817161771-t9zhez0","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161771-t9zhez0","updated":"20230817161771"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"幂等生产者"}]},{"ID":"20230817161772-jume4zk","Type":"NodeParagraph","Properties":{"id":"20230817161772-jume4zk","updated":"20230817161772"},"Children":[{"Type":"NodeText","Data":"在计算机中什么是幂等的呢 就是无论重试多少次程序 都不会改变系统原有的状态"}]},{"ID":"20230817161773-cnhmbdn","Type":"NodeParagraph","Properties":{"id":"20230817161773-cnhmbdn","updated":"20230817161773"},"Children":[{"Type":"NodeText","Data":"实现：在 0.11 之后，指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即"}]},{"ID":"20230817161774-j8rlt17","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161774-j8rlt17","updated":"20230817161774"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"props.put(“enable.idempotence”, ture)\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161775-z5gmvy1","Type":"NodeParagraph","Properties":{"id":"20230817161775-z5gmvy1","updated":"20230817161775"},"Children":[{"Type":"NodeText","Data":"原理：Kafka 自动帮你做消息的重复去重。底层具体的原理很简单，就是经典的用空间去换时间的优化思路，即在 Broker 端多保存一些字段。当 Producer 发送了具有相同字段值的消息后，Broker 能够自动知晓这些消息已经重复了，于是可以在后台默默地把它们“丢弃”掉。"}]},{"ID":"20230817161776-zam68w2","Type":"NodeParagraph","Properties":{"id":"20230817161776-zam68w2","updated":"20230817161776"},"Children":[{"Type":"NodeText","Data":"缺陷：首先，它只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。其次，它只能实现单会话上的幂等性，不能实现跨会话的幂等性。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了。"}]},{"ID":"20230817161777-umoy9kt","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161777-umoy9kt","updated":"20230817161777"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"事务生产者"}]},{"ID":"20230817161778-c1g8bci","Type":"NodeParagraph","Properties":{"id":"20230817161778-c1g8bci","updated":"20230817161778"},"Children":[{"Type":"NodeText","Data":"在数据库领域，事务提供的安全性保障是经典的 ACID，即原子性（Atomicity）、一致性 (Consistency)、隔离性 (Isolation) 和持久性 (Durability)。"}]},{"ID":"20230817161779-n553dbl","Type":"NodeParagraph","Properties":{"id":"20230817161779-n553dbl","updated":"20230817161779"},"Children":[{"Type":"NodeText","Data":"隔离性表明并发执行的事务彼此相互隔离，互不影响"}]},{"ID":"20230817161780-zbhf2bx","Type":"NodeParagraph","Properties":{"id":"20230817161780-zbhf2bx","updated":"20230817161780"},"Children":[{"Type":"NodeText","Data":"实现："}]},{"ID":"20230817161781-3jw2oa5","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161781-3jw2oa5","updated":"20230817161781"},"Children":[{"ID":"20230817161782-gpctpsl","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161782-gpctpsl","updated":"20230817161782"},"Children":[{"ID":"20230817161783-nbi2nnj","Type":"NodeParagraph","Properties":{"id":"20230817161783-nbi2nnj","updated":"20230817161783"},"Children":[{"Type":"NodeText","Data":"和幂等性 Producer 一样，开启 enable.idempotence = true。"}]}]},{"ID":"20230817161784-wngq72v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161784-wngq72v","updated":"20230817161784"},"Children":[{"ID":"20230817161785-8650lxl","Type":"NodeParagraph","Properties":{"id":"20230817161785-8650lxl","updated":"20230817161785"},"Children":[{"Type":"NodeText","Data":"设置 Producer 端参数 transactional. id。最好为其设置一个有意义的名字。"}]}]}]},{"ID":"20230817161786-zhxeukk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161786-zhxeukk","updated":"20230817161786"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"producer.initTransactions();\ntry {\n            producer.beginTransaction();\n            producer.send(record1);\n            producer.send(record2);\n            producer.commitTransaction();\n} catch (KafkaException e) {\n            producer.abortTransaction();\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161787-spnzi4j","Type":"NodeParagraph","Properties":{"id":"20230817161787-spnzi4j","updated":"20230817161787"},"Children":[{"Type":"NodeText","Data":"优点：能够精准实现exactly once 并且能够保证所有分区 所有回话都不重复"}]},{"ID":"20230817161788-jk0s86v","Type":"NodeParagraph","Properties":{"id":"20230817161788-jk0s86v","updated":"20230817161788"},"Children":[{"Type":"NodeText","Data":"缺点: 比起幂等性 Producer，事务型 Producer 的性能要更差，在实际使用过程中，我们需要仔细评估引入事务的开销，切不可无脑地启用事务。"}]},{"ID":"20230817161789-v9c933u","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20230817161789-v9c933u","updated":"20230817161789"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"消费者组以及重平衡"}]},{"ID":"20230817161790-k4aoprt","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161790-k4aoprt","updated":"20230817161790"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"comsumer的三大特性："}]},{"ID":"20230817161791-r7vwn7e","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161791-r7vwn7e","updated":"20230817161791"},"Children":[{"ID":"20230817161792-wrpsack","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161792-wrpsack","updated":"20230817161792"},"Children":[{"ID":"20230817161793-doz0bc5","Type":"NodeParagraph","Properties":{"id":"20230817161793-doz0bc5","updated":"20230817161793"},"Children":[{"Type":"NodeText","Data":"Consumer Group 下可以有一个或多个 Consumer 实例。这里的实例可以是一个单独的进程，也可以是同一进程下的线程。在实际场景中，使用进程更为常见一些。"}]}]},{"ID":"20230817161794-prlkipe","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161794-prlkipe","updated":"20230817161794"},"Children":[{"ID":"20230817161795-rf0iy73","Type":"NodeParagraph","Properties":{"id":"20230817161795-rf0iy73","updated":"20230817161795"},"Children":[{"Type":"NodeText","Data":"Group ID 是一个字符串，在一个 Kafka 集群中，它标识唯一的一个 Consumer Group。"}]}]},{"ID":"20230817161796-fn6ynzw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161796-fn6ynzw","updated":"20230817161796"},"Children":[{"ID":"20230817161797-399h1dj","Type":"NodeParagraph","Properties":{"id":"20230817161797-399h1dj","updated":"20230817161797"},"Children":[{"Type":"NodeText","Data":"Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的某个 Consumer 实例消费。这个分区当然也可以被其他的 Group 消费。"}]}]}]},{"ID":"20230817161798-7agpo85","Type":"NodeParagraph","Properties":{"id":"20230817161798-7agpo85","updated":"20230817161798"},"Children":[{"Type":"NodeText","Data":"常见的消费模型以及缺陷："}]},{"ID":"20230817161799-0qa7bnd","Type":"NodeParagraph","Properties":{"id":"20230817161799-0qa7bnd","updated":"20230817161799"},"Children":[{"Type":"NodeText","Data":"模型：点对点模型 以及发布订阅模型"}]},{"ID":"20230817161800-5kfv5tl","Type":"NodeParagraph","Properties":{"id":"20230817161800-5kfv5tl","updated":"20230817161800"},"Children":[{"Type":"NodeText","Data":"缺陷：点对点模型可能会导致大量的消费者都要抢队列的一个资源 伸缩性很差 而发布订阅模型每个消费者都必须订阅一个主题下的所有分 区 并不灵活"}]},{"ID":"20230817161801-yc46fr6","Type":"NodeParagraph","Properties":{"id":"20230817161801-yc46fr6","updated":"20230817161801"},"Children":[{"Type":"NodeText","Data":"而group的优势就在于可以订阅一个主题下的所有分区 并且能由组内多个消费者消费"}]},{"ID":"20230817161802-dtcp403","Type":"NodeParagraph","Properties":{"id":"20230817161802-dtcp403","updated":"20230817161802"},"Children":[{"Type":"NodeText","Data":"消费者如何管理位移？"}]},{"ID":"20230817161803-gh8952b","Type":"NodeParagraph","Properties":{"id":"20230817161803-gh8952b","updated":"20230817161803"},"Children":[{"Type":"NodeText","Data":"如果用 Java 来表示的话，你大致可以认为是这样的数据结构，即 Map，其中 TopicPartition 表示一个分区，而 Long 表示位移的类型 即\u003cpartiton ,long\u003e这种结构 。"}]},{"ID":"20230817161804-qpej1hk","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161804-qpej1hk","updated":"20230817161804"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"reblance的爱恨情仇"}]},{"ID":"20230817161805-jb9sgyo","Type":"NodeParagraph","Properties":{"id":"20230817161805-jb9sgyo","updated":"20230817161805"},"Children":[{"Type":"NodeText","Data":"Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区。比如某个 Group 下有 20 个 Consumer 实例，它订阅了一个具有 100 个分区的 Topic。正常情况下，Kafka 平均会为每个 Consumer 分配 5 个分区。这个分配的过程就叫 Rebalance。"}]},{"ID":"20230817161806-i80x18j","Type":"NodeParagraph","Properties":{"id":"20230817161806-i80x18j","updated":"20230817161806"},"Children":[{"Type":"NodeText","Data":"那么 Consumer Group 何时进行 Rebalance 呢？Rebalance 的触发条件有 3 个。"}]},{"ID":"20230817161807-g9g3jan","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161807-g9g3jan","updated":"20230817161807"},"Children":[{"ID":"20230817161808-y3y802i","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161808-y3y802i","updated":"20230817161808"},"Children":[{"ID":"20230817161809-h41byii","Type":"NodeParagraph","Properties":{"id":"20230817161809-h41byii","updated":"20230817161809"},"Children":[{"Type":"NodeText","Data":"组成员数发生变更。比如有新的 Consumer 实例加入组或者离开组，抑或是有 Consumer 实例崩溃被“踢出”组。"}]}]},{"ID":"20230817161810-vchud7f","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161810-vchud7f","updated":"20230817161810"},"Children":[{"ID":"20230817161811-mnw9mz1","Type":"NodeParagraph","Properties":{"id":"20230817161811-mnw9mz1","updated":"20230817161811"},"Children":[{"Type":"NodeText","Data":"订阅主题数发生变更。Consumer Group 可以使用正则表达式的方式订阅主题，比如 consumer.subscribe(Pattern.compile(\"t.*c\")) 就表明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主题。"}]}]},{"ID":"20230817161812-1l3czgo","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161812-1l3czgo","updated":"20230817161812"},"Children":[{"ID":"20230817161813-1h673m9","Type":"NodeParagraph","Properties":{"id":"20230817161813-1h673m9","updated":"20230817161813"},"Children":[{"Type":"NodeText","Data":"在 Consumer Group 的运行过程中，你新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance。订阅主题的分区数发生变更。Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。"}]}]}]},{"ID":"20230817161814-xqghydi","Type":"NodeParagraph","Properties":{"id":"20230817161814-xqghydi","updated":"20230817161814"},"Children":[{"Type":"NodeText","Data":"优势：rebalace可以尽量保证每个消费者有趋于相同的分区"}]},{"ID":"20230817161815-pqmd6nz","Type":"NodeParagraph","Properties":{"id":"20230817161815-pqmd6nz","updated":"20230817161815"},"Children":[{"Type":"NodeText","Data":"劣势：1、在 Rebalance 过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成。这是 Rebalance 为人诟病的一个方面。"}]},{"ID":"20230817161816-eobi147","Type":"NodeParagraph","Properties":{"id":"20230817161816-eobi147","updated":"20230817161816"},"Children":[{"Type":"NodeText","Data":"2、其次，目前 Rebalance 的设计是所有 Consumer 实例共同参与，全部重新分配所有分区。其实更高效的做法是尽量减少分配方案的变动"}]},{"ID":"20230817161817-2kknmia","Type":"NodeParagraph","Properties":{"id":"20230817161817-2kknmia","updated":"20230817161817"},"Children":[{"Type":"NodeText","Data":"3、最后，Rebalance 实在是太慢了。曾经，有个国外用户的 Group 内有几百个 Consumer 实例，成功 Rebalance 一次要几个小时！这完全是不能忍受的。"}]},{"ID":"20230817161818-rj65tnq","Type":"NodeParagraph","Properties":{"id":"20230817161818-rj65tnq","updated":"20230817161818"},"Children":[{"Type":"NodeText","Data":"要想避免reblacnce就要尽可能不触发reblance条件 对于开发来讲 就是尽量不要让不应该被group踢掉的实例被踢掉"}]},{"ID":"20230817161819-kj30e64","Type":"NodeParagraph","Properties":{"id":"20230817161819-kj30e64","updated":"20230817161819"},"Children":[{"Type":"NodeText","Data":"Coordinator 会在什么情况下认为某个 Consumer 实例已挂从而要退组呢？那就要来看看消费者端配置的几个参数："}]},{"ID":"20230817161820-fqmfbi4","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161820-fqmfbi4","updated":"20230817161820"},"Children":[{"ID":"20230817161821-7bzc4ai","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161821-7bzc4ai","updated":"20230817161821"},"Children":[{"ID":"20230817161822-7g4x6zf","Type":"NodeParagraph","Properties":{"id":"20230817161822-7g4x6zf","updated":"20230817161822"},"Children":[{"Type":"NodeText","Data":"session.timeout.ms 设置了超时时间"}]}]},{"ID":"20230817161823-euz967j","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161823-euz967j","updated":"20230817161823"},"Children":[{"ID":"20230817161824-adb9710","Type":"NodeParagraph","Properties":{"id":"20230817161824-adb9710","updated":"20230817161824"},"Children":[{"Type":"NodeText","Data":"heartbeat.interval.ms 心跳时间间隔"}]}]},{"ID":"20230817161825-xyr53p7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161825-xyr53p7","updated":"20230817161825"},"Children":[{"ID":"20230817161826-jd31apq","Type":"NodeParagraph","Properties":{"id":"20230817161826-jd31apq","updated":"20230817161826"},"Children":[{"Type":"NodeText","Data":"max.poll.interval.ms 每次消费的处理时间"}]}]},{"ID":"20230817161827-akzo086","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161827-akzo086","updated":"20230817161827"},"Children":[{"ID":"20230817161828-75ek5sl","Type":"NodeParagraph","Properties":{"id":"20230817161828-75ek5sl","updated":"20230817161828"},"Children":[{"Type":"NodeText","Data":"max.poll.records 每次消费的消息数"}]}]}]},{"ID":"20230817161829-zruieu7","Type":"NodeParagraph","Properties":{"id":"20230817161829-zruieu7","updated":"20230817161829"},"Children":[{"Type":"NodeText","Data":"如何避免Reblance"}]},{"ID":"20230817161830-eok71u3","Type":"NodeParagraph","Properties":{"id":"20230817161830-eok71u3","updated":"20230817161830"},"Children":[{"Type":"NodeText","Data":"简单来说，非必要 Rebalance 有下面两个点："}]},{"ID":"20230817161831-9megsg2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161831-9megsg2","updated":"20230817161831"},"Children":[{"ID":"20230817161832-cnbitvw","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161832-cnbitvw","updated":"20230817161832"},"Children":[{"ID":"20230817161833-bzaprrc","Type":"NodeParagraph","Properties":{"id":"20230817161833-bzaprrc","updated":"20230817161833"},"Children":[{"Type":"NodeText","Data":"消费者心跳超时，导致 Rebalance。"}]}]},{"ID":"20230817161834-fuud3ie","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161834-fuud3ie","updated":"20230817161834"},"Children":[{"ID":"20230817161835-67eleqb","Type":"NodeParagraph","Properties":{"id":"20230817161835-67eleqb","updated":"20230817161835"},"Children":[{"Type":"NodeText","Data":"消费者处理时间过长，导致 Rebalance。"}]}]}]},{"ID":"20230817161836-s8uxsg1","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161836-s8uxsg1","updated":"20230817161836"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"6.1 消费者心跳超时"}]},{"ID":"20230817161837-hyavql0","Type":"NodeParagraph","Properties":{"id":"20230817161837-hyavql0","updated":"20230817161837"},"Children":[{"Type":"NodeText","Data":"我们知道消费者是通过心跳和协调者保持通讯的，如果协调者收不到心跳，那么协调者会认为这个消费者死亡了，从而发起 Rebalance。"}]},{"ID":"20230817161838-mlmsq29","Type":"NodeParagraph","Properties":{"id":"20230817161838-mlmsq29","updated":"20230817161838"},"Children":[{"Type":"NodeText","Data":"这里给一下业界主流推荐的值，可以根据自己的业务可做相应的调整："}]},{"ID":"20230817161839-y92gpuu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161839-y92gpuu","updated":"20230817161839"},"Children":[{"ID":"20230817161840-flm6a0u","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161840-flm6a0u","updated":"20230817161840"},"Children":[{"ID":"20230817161841-hrsbvf2","Type":"NodeParagraph","Properties":{"id":"20230817161841-hrsbvf2","updated":"20230817161841"},"Children":[{"Type":"NodeText","Data":"设置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"session.timeout.ms = 6s"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20230817161842-jvpvpkv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161842-jvpvpkv","updated":"20230817161842"},"Children":[{"ID":"20230817161843-72wt72t","Type":"NodeParagraph","Properties":{"id":"20230817161843-72wt72t","updated":"20230817161843"},"Children":[{"Type":"NodeText","Data":"设置 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"heartbeat.interval.ms = 2s"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20230817161844-4jwrzi3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161844-4jwrzi3","updated":"20230817161844"},"Children":[{"ID":"20230817161845-ucdkrfe","Type":"NodeParagraph","Properties":{"id":"20230817161845-ucdkrfe","updated":"20230817161845"},"Children":[{"Type":"NodeText","Data":"要保证 Consumer 实例在被判定为 “dead” 之前，能够发送至少 3 轮的心跳请求，即 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"session.timeout.ms \u0026gt;= 3 * heartbeat.interval.ms"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20230817161846-wzaywe5","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161846-wzaywe5","updated":"20230817161846"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"6.2 消费者处理时间过长"}]},{"ID":"20230817161847-w039e8k","Type":"NodeParagraph","Properties":{"id":"20230817161847-w039e8k","updated":"20230817161847"},"Children":[{"Type":"NodeText","Data":"如果消费者处理时间过长，那么同样会导致协调者认为该 Consumer 死亡了，从而发起重平衡。"}]},{"ID":"20230817161848-lqko9wm","Type":"NodeParagraph","Properties":{"id":"20230817161848-lqko9wm","updated":"20230817161848"},"Children":[{"Type":"NodeText","Data":"而 Kafka 的消费者参数设置中，跟消费处理的两个参数为："}]},{"ID":"20230817161849-wfmbn6u","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161849-wfmbn6u","updated":"20230817161849"},"Children":[{"ID":"20230817161850-108qy16","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161850-108qy16","updated":"20230817161850"},"Children":[{"ID":"20230817161851-jtki0mf","Type":"NodeParagraph","Properties":{"id":"20230817161851-jtki0mf","updated":"20230817161851"},"Children":[{"Type":"NodeText","Data":"max.poll.interval.ms 每次消费的处理最大时间"}]}]},{"ID":"20230817161852-3733aio","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20230817161852-3733aio","updated":"20230817161852"},"Children":[{"ID":"20230817161853-fvqj93y","Type":"NodeParagraph","Properties":{"id":"20230817161853-fvqj93y","updated":"20230817161853"},"Children":[{"Type":"NodeText","Data":"max.poll.records 每次消费的消息数"}]}]}]},{"ID":"20230817161854-5fhjjq6","Type":"NodeParagraph","Properties":{"id":"20230817161854-5fhjjq6","updated":"20230817161854"},"Children":[{"Type":"NodeText","Data":"对于这种情况，一般来说就是增加消费者处理的时间（即提高 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"max.poll.interval.ms"},{"Type":"NodeText","Data":" 的值），减少每次处理的消息数（即减少 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"max.poll.records"},{"Type":"NodeText","Data":" 的值）。"}]},{"ID":"20230817161855-9ocqm9h","Type":"NodeParagraph","Properties":{"id":"20230817161855-9ocqm9h","updated":"20230817161855"},"Children":[{"Type":"NodeText","Data":"我们上面的那个例子就是这个场景触发的 Rebalance，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"max.poll.interval.ms"},{"Type":"NodeText","Data":" 每次消费的处理最大时间设置的是 60000ms，也就是 1min。而我在 consumer.poll 方法里休眠了 2min 来模拟处理业务的时间，处理业务的时间大于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"max.poll.interval.ms"},{"Type":"NodeText","Data":" ，导致 Rebalance。"}]},{"ID":"20230817161856-h97vh4u","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161856-h97vh4u","updated":"20230817161856"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"6.3 Consumer 端的 GC 表现"}]},{"ID":"20230817161857-b69ypm6","Type":"NodeParagraph","Properties":{"id":"20230817161857-b69ypm6","updated":"20230817161857"},"Children":[{"Type":"NodeText","Data":"如果上面两种从 Kafka 层面还无法避免 Rebalance，那我建议你去排查下 Consumer 端的 GC 表现，比如是否出现了频繁的 Full GC 导致的长时间停顿，从而引发了 Rebalance。"}]},{"ID":"20230817161858-aq7pkf4","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161858-aq7pkf4","updated":"20230817161858"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"位移提交剖析"}]},{"ID":"20230817161859-rbw5l0i","Type":"NodeParagraph","Properties":{"id":"20230817161859-rbw5l0i","updated":"20230817161859"},"Children":[{"Type":"NodeText","Data":"Consumer 需要向 Kafka 汇报自己的位移数据，这个汇报过程被称为提交位移（Committing Offsets）。因为 Consumer 能够同时消费多个分区的数据，所以位移的提交实际上是在分区粒度上进行的，即 Consumer 需要为分配给它的每个分区提交各自的位移数据。"}]},{"ID":"20230817161860-voggikw","Type":"NodeParagraph","Properties":{"id":"20230817161860-voggikw","updated":"20230817161860"},"Children":[{"Type":"NodeText","Data":"位移提交的语义保障是由你来负责的，Kafka 只会“无脑”地接受你提交的位移"}]},{"ID":"20230817161861-o7o54oa","Type":"NodeParagraph","Properties":{"id":"20230817161861-o7o54oa","updated":"20230817161861"},"Children":[{"Type":"NodeText","Data":"从用户的角度来说，位移提交分为自动提交和手动提交；从 Consumer 端的角度来说，位移提交分为同步提交和异步提交。"}]},{"ID":"20230817161862-lnkxxwz","Type":"NodeParagraph","Properties":{"id":"20230817161862-lnkxxwz","updated":"20230817161862"},"Children":[{"Type":"NodeText","Data":"一旦设置了 enable.auto.commit 为 true，Kafka 会保证在开始调用 poll 方法时，提交上次 poll 返回的所有消息。从顺序上来说，poll 方法的逻辑是先提交上一批消息的位移，再处理下一批消息，因此它能保证不出现消费丢失的情况。但自动提交位移的一个问题在于，它可能会出现重复消费。"}]},{"ID":"20230817161863-m9pb02d","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161863-m9pb02d","updated":"20230817161863"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"自动提交缺陷 会导致消息重复消费"}]},{"ID":"20230817161864-bn7wnrz","Type":"NodeParagraph","Properties":{"id":"20230817161864-bn7wnrz","updated":"20230817161864"},"Children":[{"Type":"NodeText","Data":"在默认情况下，Consumer 每 5 秒自动提交一次位移。现在，我们假设提交位移之后的 3 秒发生了 Rebalance 操作。在 Rebalance 之后，所有 Consumer 从上一次提交的位移处继续消费，但该位移已经是 3 秒前的位移数据了，故在 Rebalance 发生前 3 秒消费的所有数据都要重新再消费一次。虽然你能够通过减少 auto.commit.interval.ms 的值来提高提交频率，但这么做只能缩小重复消费的时间窗口，不可能完全消除它。这是自动提交机制的一个缺陷。"}]},{"ID":"20230817161865-5s43zi1","Type":"NodeHeading","HeadingLevel":6,"Properties":{"id":"20230817161865-5s43zi1","updated":"20230817161865"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"###### ","Properties":{"id":""}},{"Type":"NodeText","Data":"同步提交与异步提交"}]},{"ID":"20230817161866-5u25cxn","Type":"NodeParagraph","Properties":{"id":"20230817161866-5u25cxn","updated":"20230817161866"},"Children":[{"Type":"NodeText","Data":"commitSync()：同步提交 缺陷是就是在调用 commitSync() 时，Consumer 程序会处于阻塞状态，直到远端的 Broker 返回提交结果，这个状态才会结束。在任何系统中，因为程序而非资源限制而导致的阻塞都可能是系统的瓶颈，会影响整个应用程序的 TPS。当然，你可以选择拉长提交间隔，但这样做的后果是 Consumer 的提交频率下降，在下次 Consumer 重启回来后，会有更多的消息被重新消费。"}]},{"ID":"20230817161867-vr719mv","Type":"NodeParagraph","Properties":{"id":"20230817161867-vr719mv","updated":"20230817161867"},"Children":[{"Type":"NodeText","Data":"commitAsync()：异步提交 优点：它会立即返回，不会阻塞，因此不会影响 Consumer 应用的 TPS。由于它是异步的，Kafka 提供了回调函数（callback），供你实现提交之后的逻辑，比如记录日志或处理异常等。"}]},{"ID":"20230817161868-mjpip12","Type":"NodeParagraph","Properties":{"id":"20230817161868-mjpip12","updated":"20230817161868"},"Children":[{"Type":"NodeText","Data":"缺点是：他不会管是否提交成功 重试对他也没有意义 因为他重新提交的数据或许早已过期"}]},{"ID":"20230817161869-h706cnk","Type":"NodeParagraph","Properties":{"id":"20230817161869-h706cnk","updated":"20230817161869"},"Children":[{"Type":"NodeText","Data":"显然，如果是手动提交，我们需要将 commitSync 和 commitAsync 组合使用才能达到最理想的效果，原因有两个：我们可以利用 commitSync 的自动重试来规避那些瞬时错误，比如网络的瞬时抖动，Broker 端 GC 等。因为这些问题都是短暂的，自动重试通常都会成功，因此，我们不想自己重试，而是希望 Kafka Consumer 帮我们做这件事。我们不希望程序总处于阻塞状态，影响 TPS。我们来看一下下面这段代码，它展示的是如何将两个 API 方法结合使用进行手动提交。"}]},{"ID":"20230817161870-xu7u12v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161870-xu7u12v","updated":"20230817161870"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\n   try {\n           while(true) {\n                        ConsumerRecords\u003cString, String\u003e records = \n                                    consumer.poll(Duration.ofSeconds(1));\n                        process(records); // 处理消息\n                        commitAysnc(); // 使用异步提交规避阻塞\n            }\n} catch(Exception e) {\n            handle(e); // 处理异常\n} finally {\n            try {\n                        consumer.commitSync(); // 最后一次提交使用同步阻塞式提交\n  } finally {\n       consumer.close();\n}\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161871-j49aets","Type":"NodeParagraph","Properties":{"id":"20230817161871-j49aets","updated":"20230817161871"},"Children":[{"Type":"NodeText","Data":"将两者结合后，我们既实现了异步无阻塞式的位移管理，也确保了 Consumer 位移的正确性，所以，如果你需要自行编写代码开发一套 Kafka Consumer 应用，那么我推荐你使用上面的代码范例来实现手动的位移提交。"}]},{"ID":"20230817161872-mqltiwj","Type":"NodeParagraph","Properties":{"id":"20230817161872-mqltiwj","updated":"20230817161872"},"Children":[{"Type":"NodeText","Data":"上述默认是提交最新的消息位移"}]},{"ID":"20230817161873-3eu4e0t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161873-3eu4e0t","updated":"20230817161873"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\nprivate Map\u003cTopicPartition, OffsetAndMetadata\u003e offsets = new HashMap\u003c\u003e();\nint count = 0;\n……\nwhile (true) {\n            ConsumerRecords\u003cString, String\u003e records = \n  consumer.poll(Duration.ofSeconds(1));\n            for (ConsumerRecord\u003cString, String\u003e record: records) {\n                        process(record);  // 处理消息\n                        offsets.put(new TopicPartition(record.topic(), record.partition()),\n                                   new OffsetAndMetadata(record.offset() + 1)；\n                       if（count % 100 == 0）\n                                    consumer.commitAsync(offsets, null); // 回调处理逻辑是null\n                        count++;\n  }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20230817161874-kx3vofm","Type":"NodeParagraph","Properties":{"id":"20230817161874-kx3vofm","updated":"20230817161874"},"Children":[{"Type":"NodeText","Data":"上述代码可以按照消息粒度来提交位移"}]},{"ID":"20230817161875-y7sau10","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161875-y7sau10","updated":"20230817161875"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"CommitFailedException异常怎么处理？"}]},{"ID":"20230817161876-jy3prcb","Type":"NodeParagraph","Properties":{"id":"20230817161876-jy3prcb","updated":"20230817161876"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所谓 CommitFailedException，顾名思义就是 Consumer 客户端在提交位移时出现了错误或异常，而且还是那种不可恢复的严重异常。"}]},{"ID":"20230817161877-mf2aakm","Type":"NodeParagraph","Properties":{"id":"20230817161877-mf2aakm","updated":"20230817161877"},"Children":[{"Type":"NodeText","Data":"这种异常主要原因就是消费者发生了重平衡"}]},{"ID":"20230817161878-jbvtths","Type":"NodeParagraph","Properties":{"id":"20230817161878-jbvtths","updated":"20230817161878"},"Children":[{"Type":"NodeText","Data":"解决办法："}]},{"ID":"20230817161879-vjm9049","Type":"NodeParagraph","Properties":{"id":"20230817161879-vjm9049","updated":"20230817161879"},"Children":[{"Type":"NodeText","Data":"缩短下游业务的处理时间"}]},{"ID":"20230817161880-6i9erv0","Type":"NodeParagraph","Properties":{"id":"20230817161880-6i9erv0","updated":"20230817161880"},"Children":[{"Type":"NodeText","Data":"增加期望的时间间隔 max.poll.interval.ms 参数值。"}]},{"ID":"20230817161881-v5dqa2h","Type":"NodeParagraph","Properties":{"id":"20230817161881-v5dqa2h","updated":"20230817161881"},"Children":[{"Type":"NodeText","Data":"减少 poll 方法一次性返回的消息数量，即减少 max.poll.records 参数值。"}]},{"ID":"20230817161882-yq17hn6","Type":"NodeParagraph","Properties":{"id":"20230817161882-yq17hn6","updated":"20230817161882"},"Children":[{"Type":"NodeText","Data":"下游系统使用多线程来加速消费。(比较难以理解)"}]},{"ID":"20230817161883-08ahlbj","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20230817161883-08ahlbj","updated":"20230817161883"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### ","Properties":{"id":""}},{"Type":"NodeText","Data":"多线程开发消费者实例"}]},{"ID":"20230817161884-tz541tv","Type":"NodeParagraph","Properties":{"id":"20230817161884-tz541tv","updated":"20230817161884"},"Children":[{"Type":"NodeText","Data":"两种方案："}]},{"ID":"20230817161885-3e5c8kl","Type":"NodeParagraph","Properties":{"id":"20230817161885-3e5c8kl","updated":"20230817161885"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1.消费者程序启动多个线程，每个线程维护专属的 KafkaConsumer 实例，负责完整的消息获取、消息处理流程。"},{"Type":"NodeText","Data":"对于处理先后顺序很友好"}]},{"ID":"20230817161886-we43i3v","Type":"NodeParagraph","Properties":{"id":"20230817161886-we43i3v","updated":"20230817161886"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2.消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑"}]},{"ID":"20230817161887-rbwn1ko","Type":"NodeParagraph","Properties":{"id":"20230817161887-rbwn1ko","updated":"20230817161887"},"Children":[{"Type":"NodeText","Data":"建议使用第一种 第二种在是实现层面太高 虽然将消息获取与消息处理解耦 但在位移提交简直就是灾难"}]},{"ID":"20230817161888-7brtjqe","Type":"NodeParagraph","Properties":{"id":"20230817161888-7brtjqe","updated":"20230817161888"},"Children":[{"Type":"NodeText","Data":"第一种方案代码："}]},{"ID":"20230817161889-4v3x78d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20230817161889-4v3x78d","updated":"20230817161889"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"\npublic class KafkaConsumerRunner implements Runnable {\n     private final AtomicBoolean closed = new AtomicBoolean(false);\n     private final KafkaConsumer consumer;\n\n\n     public void run() {\n         try {\n             consumer.subscribe(Arrays.asList(\"topic\"));\n             while (!closed.get()) {\n      ConsumerRecords records = \n        consumer.poll(Duration.ofMillis(10000));\n                 //  执行消息处理逻辑\n             }\n         } catch (WakeupException e) {\n             // Ignore exception if closing\n             if (!closed.get()) throw e;\n         } finally {\n             consumer.close();\n         }\n     }\n\n\n     // Shutdown hook which can be called from a separate thread\n     public void shutdown() {\n         closed.set(true);\n         consumer.wakeup();\n     }\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}