{"ID":"20230817161923-nq23p8u","Spec":"1","Type":"NodeDocument","Properties":{"id":"20230817161923-nq23p8u","title":"LSM树详解","updated":"20230817161923"},"Children":[{"ID":"20230817161924-azydhhs","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20230817161924-azydhhs","updated":"20230817161924"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# ","Properties":{"id":""}},{"Type":"NodeText","Data":"LSM树详解"}]},{"ID":"20230817161925-k0vslj3","Type":"NodeParagraph","Properties":{"id":"20230817161925-k0vslj3","updated":"20230817161925"},"Children":[{"Type":"NodeText","Data":"LSM树(Log-Structured-Merge-Tree)的名字往往会给初识者一个错误的印象，事实上，LSM树并不像B+树、红黑树一样是一颗严格的树状数据结构，它其实是一种存储结构，目前HBase,LevelDB,RocksDB这些NoSQL存储都是采用的LSM树。"}]},{"ID":"20230817161926-oqh6j60","Type":"NodeParagraph","Properties":{"id":"20230817161926-oqh6j60","updated":"20230817161926"},"Children":[{"Type":"NodeText","Data":"LSM树的核心特点是利用顺序写来提高写性能，但因为分层(此处分层是指的分为内存和文件两部分)的设计会稍微降低读性能，但是通过牺牲小部分读性能换来高性能写，使得LSM树成为非常流行的存储结构。"}]},{"ID":"20230817161927-b6d0cbd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161927-b6d0cbd","updated":"20230817161927"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、LSM树的核心思想"}]},{"ID":"20230817161928-65klqko","Type":"NodeParagraph","Properties":{"id":"20230817161928-65klqko","updated":"20230817161928"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic2.zhimg.com/80/v2-37576525d52091fd713bb13556c92861_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161929-m5we9sp","Type":"NodeParagraph","Properties":{"id":"20230817161929-m5we9sp","updated":"20230817161929"},"Children":[{"Type":"NodeText","Data":"如上图所示，LSM树有以下三个重要组成部分："}]},{"ID":"20230817161930-ko98uba","Type":"NodeParagraph","Properties":{"id":"20230817161930-ko98uba","updated":"20230817161930"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em strong","TextMarkTextContent":"1) MemTable"}]},{"ID":"20230817161931-jmrhjuc","Type":"NodeParagraph","Properties":{"id":"20230817161931-jmrhjuc","updated":"20230817161931"},"Children":[{"Type":"NodeText","Data":"MemTable是在***内存"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"**中的数据结构，用于保存最近更新的数据，会按照Key有序地组织这些数据，LSM树对于具体如何组织有序地组织数据并没有明确的数据结构定义，例如Hbase使跳跃表来保证内存中key的有序。"}]},{"ID":"20230817161932-gja4xix","Type":"NodeParagraph","Properties":{"id":"20230817161932-gja4xix","updated":"20230817161932"},"Children":[{"Type":"NodeText","Data":"因为数据暂时保存在内存中，内存并不是可靠存储，如果断电会丢失数据，因此通常会通过WAL(Write-ahead logging，预写式日志)的方式来保证数据的可靠性。"}]},{"ID":"20230817161933-yr6l0j3","Type":"NodeParagraph","Properties":{"id":"20230817161933-yr6l0j3","updated":"20230817161933"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em strong","TextMarkTextContent":"2) Immutable MemTable"}]},{"ID":"20230817161934-cp0z7s4","Type":"NodeParagraph","Properties":{"id":"20230817161934-cp0z7s4","updated":"20230817161934"},"Children":[{"Type":"NodeText","Data":"当 MemTable达到一定大小后，会转化成Immutable MemTable。Immutable MemTable是将转MemTable变为SSTable的一种中间状态。写操作由新的MemTable处理，在转存过程中不阻塞数据更新操作。"}]},{"ID":"20230817161935-8ma7i8o","Type":"NodeParagraph","Properties":{"id":"20230817161935-8ma7i8o","updated":"20230817161935"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em strong","TextMarkTextContent":"3) SSTable(Sorted String Table)"}]},{"ID":"20230817161936-yditknf","Type":"NodeParagraph","Properties":{"id":"20230817161936-yditknf","updated":"20230817161936"},"Children":[{"Type":"NodeText","Data":"**"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"有序键值对"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em strong","TextMarkTextContent":"集合，是LSM树组在"},{"Type":"NodeText","Data":"磁盘"},{"Type":"NodeBackslash","Properties":{"id":""},"Children":[{"Type":"NodeBackslashContent","Data":"*","Properties":{"id":""}}]},{"Type":"NodeText","Data":"**中的数据结构。为了加快SSTable的读取，可以通过建立key的索引以及布隆过滤器来加快key的查找。"}]},{"ID":"20230817161937-tt40n9e","Type":"NodeParagraph","Properties":{"id":"20230817161937-tt40n9e","updated":"20230817161937"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic3.zhimg.com/80/v2-9eeda5082f56b1df20fa555d36b0e0ae_720w.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161938-pe55meu","Type":"NodeParagraph","Properties":{"id":"20230817161938-pe55meu","updated":"20230817161938"},"Children":[{"Type":"NodeText","Data":"这里需要关注一个重点，LSM树(Log-Structured-Merge-Tree)正如它的名字一样，LSM树会将所有的数据插入、修改、删除等操作记录(注意是操作记录)保存在内存之中，当此类操作达到一定的数据量后，再批量地顺序写入到磁盘当中。这与B+树不同，B+树数据的更新会直接在原数据所在处修改对应的值，但是LSM数的数据更新是日志式的，当一条数据更新是直接append一条更新记录完成的。这样设计的目的就是为了顺序写，不断地将Immutable MemTable flush到持久化存储即可，而不用去修改之前的SSTable中的key，保证了顺序写。"}]},{"ID":"20230817161939-4twpwue","Type":"NodeParagraph","Properties":{"id":"20230817161939-4twpwue","updated":"20230817161939"},"Children":[{"Type":"NodeText","Data":"因此当MemTable达到一定大小flush到持久化存储变成SSTable后，在不同的SSTable中，可能存在相同Key的记录，当然最新的那条记录才是准确的。这样设计的虽然大大提高了写性能，但同时也会带来一些问题："}]},{"ID":"20230817161940-ax7h669","Type":"NodeBlockquote","Properties":{"id":"20230817161940-ax7h669","updated":"20230817161940"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161941-05160fc","Type":"NodeParagraph","Properties":{"id":"20230817161941-05160fc","updated":"20230817161941"},"Children":[{"Type":"NodeText","Data":"1）冗余存储，对于某个key，实际上除了最新的那条记录外，其他的记录都是冗余无用的，但是仍然占用了存储空间。因此需要进行Compact操作(合并多个SSTable)来清除冗余的记录。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"2）读取时需要从最新的倒着查询，直到找到某个key的记录。最坏情况需要查询完所有的SSTable，这里可以通过前面提到的索引/布隆过滤器来优化查找速度。"}]}]},{"ID":"20230817161942-1o39px6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161942-1o39px6","updated":"20230817161942"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"2、LSM树的Compact策略"}]},{"ID":"20230817161943-iyym3zt","Type":"NodeParagraph","Properties":{"id":"20230817161943-iyym3zt","updated":"20230817161943"},"Children":[{"Type":"NodeText","Data":"从上面可以看出，Compact操作是十分关键的操作，否则SSTable数量会不断膨胀。在Compact策略上，主要介绍两种基本策略：size-tiered和leveled。"}]},{"ID":"20230817161944-09y3bl5","Type":"NodeParagraph","Properties":{"id":"20230817161944-09y3bl5","updated":"20230817161944"},"Children":[{"Type":"NodeText","Data":"不过在介绍这两种策略之前，先介绍三个比较重要的概念，事实上不同的策略就是围绕这三个概念之间做出权衡和取舍。"}]},{"ID":"20230817161945-w6t3oce","Type":"NodeBlockquote","Properties":{"id":"20230817161945-w6t3oce","updated":"20230817161945"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20230817161946-61nafoh","Type":"NodeParagraph","Properties":{"id":"20230817161946-61nafoh","updated":"20230817161946"},"Children":[{"Type":"NodeText","Data":"1）读放大:读取数据时实际读取的数据量大于真正的数据量。例如在LSM树中需要先在MemTable查看当前key是否存在，不存在继续从SSTable中寻找。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"2）写放大:写入数据时实际写入的数据量大于真正的数据量。例如在LSM树中写入时可能触发Compact操作，导致实际写入的数据量远大于该key的数据量。"},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"3）空间放大:数据实际占用的磁盘空间比数据的真正大小更多。上面提到的冗余存储，对于一个key来说，只有最新的那条记录是有效的，而之前的记录都是可以被清理回收的。"}]}]},{"ID":"20230817161947-nqfv28p","Type":"NodeParagraph","Properties":{"id":"20230817161947-nqfv28p","updated":"20230817161947"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em strong","TextMarkTextContent":"1) size-tiered 策略"}]},{"ID":"20230817161948-v2jzcs8","Type":"NodeParagraph","Properties":{"id":"20230817161948-v2jzcs8","updated":"20230817161948"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic2.zhimg.com/80/v2-bedb057fde7a4ce4d5be2ea34fe86f59_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161949-d7r2ftu","Type":"NodeParagraph","Properties":{"id":"20230817161949-d7r2ftu","updated":"20230817161949"},"Children":[{"Type":"NodeText","Data":"size-tiered策略保证每层SSTable的大小相近，同时限制每一层SSTable的数量。如上图，每层限制SSTable为N，当每层SSTable达到N后，则触发Compact操作合并这些SSTable，并将合并后的结果写入到下一层成为一个更大的sstable。"}]},{"ID":"20230817161950-inc9m71","Type":"NodeParagraph","Properties":{"id":"20230817161950-inc9m71","updated":"20230817161950"},"Children":[{"Type":"NodeText","Data":"由此可以看出，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"当层数达到一定数量时，最底层的单个SSTable的大小会变得非常大"},{"Type":"NodeText","Data":"。并且"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em","TextMarkTextContent":"size-tiered策略会导致空间放大比较严重"},{"Type":"NodeText","Data":"。即使对于同一层的SSTable，每个key的记录是可能存在多份的，只有当该层的SSTable执行compact操作才会消除这些key的冗余记录。"}]},{"ID":"20230817161951-el4ddln","Type":"NodeParagraph","Properties":{"id":"20230817161951-el4ddln","updated":"20230817161951"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"em strong","TextMarkTextContent":"2) leveled策略"}]},{"ID":"20230817161952-n0k5vx4","Type":"NodeParagraph","Properties":{"id":"20230817161952-n0k5vx4","updated":"20230817161952"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic3.zhimg.com/80/v2-5f8de2e435e979936693631617a60d16_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"每一层的总大小固定，从上到下逐渐变大"}]},{"ID":"20230817161953-yycm7uo","Type":"NodeParagraph","Properties":{"id":"20230817161953-yycm7uo","updated":"20230817161953"},"Children":[{"Type":"NodeText","Data":"leveled策略也是采用分层的思想，每一层限制总文件的大小。"}]},{"ID":"20230817161954-03svnol","Type":"NodeParagraph","Properties":{"id":"20230817161954-03svnol","updated":"20230817161954"},"Children":[{"Type":"NodeText","Data":"但是跟size-tiered策略不同的是，leveled会将每一层切分成多个大小相近的SSTable。这些SSTable是这一层是"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"全局有序"},{"Type":"NodeText","Data":"的，意味着一个key在每一层至多只有1条记录，不存在冗余记录。之所以可以保证全局有序，是因为合并策略和size-tiered不同，接下来会详细提到。"}]},{"ID":"20230817161955-vbsd2yc","Type":"NodeParagraph","Properties":{"id":"20230817161955-vbsd2yc","updated":"20230817161955"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic1.zhimg.com/80/v2-8274669affe5b9602aff45ddff29e628_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"每一层的SSTable是全局有序的"}]},{"ID":"20230817161956-8wn6vd7","Type":"NodeParagraph","Properties":{"id":"20230817161956-8wn6vd7","updated":"20230817161956"},"Children":[{"Type":"NodeText","Data":"假设存在以下这样的场景:"}]},{"ID":"20230817161957-s9032ee","Type":"NodeParagraph","Properties":{"id":"20230817161957-s9032ee","updated":"20230817161957"},"Children":[{"Type":"NodeText","Data":"\\1) L1的总大小超过L1本身大小限制："}]},{"ID":"20230817161958-xz9ssay","Type":"NodeParagraph","Properties":{"id":"20230817161958-xz9ssay","updated":"20230817161958"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic1.zhimg.com/80/v2-2546095c6b6e02af02de10cd236302f8_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"此时L1超过了最大阈值限制"}]},{"ID":"20230817161959-whh5r7i","Type":"NodeParagraph","Properties":{"id":"20230817161959-whh5r7i","updated":"20230817161959"},"Children":[{"Type":"NodeText","Data":"\\2) 此时会从L1中选择至少一个文件，然后把它跟L2"},{"Type":"NodeTextMark","TextMarkType":"em strong","TextMarkTextContent":"有交集的部分(非常关键)"},{"Type":"NodeText","Data":"进行合并。生成的文件会放在L2:"}]},{"ID":"20230817161960-gei8dg3","Type":"NodeParagraph","Properties":{"id":"20230817161960-gei8dg3","updated":"20230817161960"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic2.zhimg.com/80/v2-663d136cefaaf6f8301833bf29c833e9_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161961-w81nx5h","Type":"NodeParagraph","Properties":{"id":"20230817161961-w81nx5h","updated":"20230817161961"},"Children":[{"Type":"NodeText","Data":"如上图所示，此时L1第二SSTable的key的范围覆盖了L2中前三个SSTable，那么就需要将L1中第二个SSTable与L2中前三个SSTable执行Compact操作。"}]},{"ID":"20230817161962-ajsnmfr","Type":"NodeParagraph","Properties":{"id":"20230817161962-ajsnmfr","updated":"20230817161962"},"Children":[{"Type":"NodeText","Data":"\\3) 如果L2合并后的结果仍旧超出L5的阈值大小，需要重复之前的操作 —— 选至少一个文件然后把它合并到下一层:"}]},{"ID":"20230817161963-eo1m3w0","Type":"NodeParagraph","Properties":{"id":"20230817161963-eo1m3w0","updated":"20230817161963"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic1.zhimg.com/80/v2-715d76154b33abbe51e158b0cfcdc2bc_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161964-warfyx6","Type":"NodeParagraph","Properties":{"id":"20230817161964-warfyx6","updated":"20230817161964"},"Children":[{"Type":"NodeText","Data":"需要注意的是，*"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多个不相干的合并是可以并发进行的"},{"Type":"NodeText","Data":"："}]},{"ID":"20230817161965-75et89b","Type":"NodeParagraph","Properties":{"id":"20230817161965-75et89b","updated":"20230817161965"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"https://pic3.zhimg.com/80/v2-2065db94c8837edd583b6ec639eaae6e_720w.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20230817161966-rhlu9a3","Type":"NodeParagraph","Properties":{"id":"20230817161966-rhlu9a3","updated":"20230817161966"},"Children":[{"Type":"NodeText","Data":"leveled策略相较于size-tiered策略来说，每层内key是不会重复的，即使是最坏的情况，除开最底层外，其余层都是重复key，按照相邻层大小比例为10来算，冗余占比也很小。因此空间放大问题得到缓解。但是写放大问题会更加突出。举一个最坏场景，如果LevelN层某个SSTable的key的范围跨度非常大，覆盖了LevelN+1层所有key的范围，那么进行Compact时将涉及LevelN+1层的全部数据。"}]},{"ID":"20230817161967-wvog8yv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20230817161967-wvog8yv","updated":"20230817161967"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"3、总结"}]},{"ID":"20230817161968-7qryqiw","Type":"NodeParagraph","Properties":{"id":"20230817161968-7qryqiw","updated":"20230817161968"},"Children":[{"Type":"NodeText","Data":"LSM树是非常值得了解的知识，理解了LSM树可以很自然地理解Hbase，LevelDb等存储组件的架构设计。ClickHouse中的MergeTree也是LSM树的思想，Log-Structured还可以联想到Kafka的存储方式。"}]},{"ID":"20230817161969-zaf2l52","Type":"NodeParagraph","Properties":{"id":"20230817161969-zaf2l52","updated":"20230817161969"},"Children":[{"Type":"NodeText","Data":"虽然介绍了上面两种策略，但是各个存储都在自己的Compact策略上面做了很多特定的优化，例如Hbase分为Major和Minor两种Compact，这里不再做过多介绍，推荐阅读文末的RocksDb合并策略介绍。"}]}]}